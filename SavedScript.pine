//
// ðŸš¨================================================================================================ðŸš¨
// ðŸš¨ EZ ALGO TRADER - DEVELOPER & AI DIRECTIVES
// ðŸš¨================================================================================================ðŸš¨
//
// PRIMARY DIRECTIVE: PRESERVE CORE FUNCTIONALITY
// This is a pure strategy script focused on execution performance. The core logic is battle-tested and must not be altered.
// Any modifications must be strictly limited to approved areas to prevent unintended consequences.
//
// --------------------------------------------------------------------------------------------------
// ðŸ”’ CORE SYSTEMS - DO NOT MODIFY ðŸ”’
// --------------------------------------------------------------------------------------------------
// 1.  SIGNAL PROCESSING: Multi-signal detection, combination, and entry signal generation.
// 2.  EXIT ARCHITECTURE: Coordinated exits (Smart Profit Locker, Fixed SL/TP, MA-based) and intrabar execution.
// 3.  TREND-RIDING LOGIC: Signal-driven trend mode, exit interception, and safety nets.
// 4.  DIRECTIONAL BIAS FILTERS: Confluence voting and bias application from internal indicators.
// 5.  STRATEGY EXECUTION: `strategy.entry()` and `strategy.exit()` calls, webhook integration, and risk management.
//
// --------------------------------------------------------------------------------------------------
// ðŸš« STRICT PROHIBITIONS ðŸš«
// --------------------------------------------------------------------------------------------------
// - DO NOT alter, simplify, or "optimize" any mathematical formulas.
// - DO NOT modify the fundamental structure of the signal processing or exit systems.
// - DO NOT add heavy visual elements; focus on performance and minimal chart pollution.
//
// --------------------------------------------------------------------------------------------------
// âœ… APPROVED MODIFICATION AREAS âœ…
// --------------------------------------------------------------------------------------------------
// - ADDING NEW FILTERS: New directional bias filters may be added if they follow the existing pattern.
// - PARAMETER TUNING: Default input values can be adjusted for optimization.
// - MINIMAL VISUALS: Essential `plot()` or `plotshape()` for debugging or critical signals are acceptable.
//
// Any deviation from these directives requires express permission. When in doubt, do not modify.
// ðŸš¨================================================================================================ðŸš¨

// --------------------------------------------------------------------------------------------------
// SECTION: SCRIPT CONFIGURATION & METADATA
// --------------------------------------------------------------------------------------------------
// Â© 2025 Andres Garcia â€” EZ Algo Trader
// This script provides a professional-grade framework for multi-signal quantitative strategies.
// Key Features:
// â€¢ Coordinated multi-method exit system (Smart Profit Locker, Fixed SL/TP, MA-based).
// â€¢ Flexible, multi-source signal processing for entries and trend-based exits.
// â€¢ Integrated with TradersPost for full automation via webhooks.
// â€¢ Memory-safe debugging and label management for high performance.
//
//@version=5

// --------------------------------------------------------------------------------------------------
// SECTION: MEMORY-SAFE DEBUG SYSTEM
// KEYWORDS: Debug, Logging, Trace, Error, Info, Performance
// --------------------------------------------------------------------------------------------------
// Provides a set of functions for logging information without causing memory leaks from persistent labels.
// This system uses the `log.*` functions, which are efficient for debugging in the Strategy Tester.

// User Input: Globally enables or disables all debug log outputs.
debugEnabled = input.bool(false, 'ðŸ” Enable Debug Labels', group = 'ðŸ› ï¸ Debug System', tooltip = 'Show debug information in strategy tester logs')

// Wrapper functions for different log levels (Info, Warning, Error, Trace).
debugLog(string message) =>
    if debugEnabled
        log.info("DEBUG: " + message)

debugInfo(string message) =>
    if debugEnabled
        log.info("INFO: " + message)

debugWarn(string message) =>
    if debugEnabled
        log.warning("WARN: " + message)

debugError(string message) =>
    if debugEnabled
        log.error("ERROR: " + message)

debugTrace(string message) =>
    if debugEnabled
        log.info("TRACE: " + message)

// --------------------------------------------------------------------------------------------------
// SECTION: MEMORY-SAFE LABEL POOL
// KEYWORDS: Label Pool, Chart Labels, Visualization, Performance, Memory Management
// --------------------------------------------------------------------------------------------------
// Manages a fixed-size pool of labels to display information on the chart without creating new labels
// on every bar, which would lead to memory and performance issues.

var int MAX_LABELS = 50 // Defines the maximum number of labels to keep in the pool.
var label[] longLabelPool = array.new<label>()
var label[] shortLabelPool = array.new<label>()

// Recycles labels from the pool to avoid exceeding TradingView's label limits.
getPooledLabel(bool isLong) =>
    pool = isLong ? longLabelPool : shortLabelPool
    label lbl = na
    if array.size(pool) < MAX_LABELS
        lbl := label.new(bar_index, na, '', color = color.new(color.white, 100), textcolor = color.white, size = size.small, style = label.style_label_left)
        array.push(pool, lbl)
    else
        lbl := array.get(pool, bar_index % MAX_LABELS)
    lbl

// Updates the properties of a given label from the pool.
updateLabel(label lbl, int x, float y, string txt, color col) =>
    if not na(lbl)
        label.set_x(lbl, x)
        label.set_y(lbl, y)
        label.set_text(lbl, txt)
        label.set_textcolor(lbl, col)
        label.set_color(lbl, color.new(col, 80))
        label.set_style(lbl, label.style_label_left)
        label.set_size(lbl, size.small)

// --------------------------------------------------------------------------------------------------
// SECTION: STRATEGY DECLARATION & CORE SETTINGS
// KEYWORDS: Strategy, Pyramiding, Backtest, Execution, Orders
// --------------------------------------------------------------------------------------------------
strategy('EZ Algo Trade Manager', 
         overlay=true,  // Strategy plots directly on the main chart.
         pyramiding=1,  // Allows up to 1 additional entry in the same direction.
         default_qty_type=strategy.fixed,  // Order size is a fixed number of contracts/shares.
         default_qty_value=1,  // Default order size (can be overridden by user input).
         calc_on_order_fills=true,  // Recalculates the script each time an order is filled.
         process_orders_on_close=true,  // Processes orders only on the close of a bar for backtesting consistency.
         calc_on_every_tick=false) // Script calculates on bar close. Set to 'true' for intrabar exits, but use with caution.
// --------------------------------------------------------------------------------------------------
// SECTION: GLOBAL VARIABLE DECLARATIONS
// KEYWORDS: Global Variables, State Management, Strategy State
// --------------------------------------------------------------------------------------------------
// These variables use the `var` keyword to maintain their state across multiple bars.

// --- Exit System State ---
var float smartOffset = na          // Stores the calculated offset for the Smart Profit Locker.
var string exitComment = na         // Stores the comment for the webhook exit message.
var string exitReason = na          // Stores the reason for the exit (e.g., 'SL', 'TP', 'MA Exit').
var bool allowTrendExit = false     // Flag to permit trend-based exits.

// --- Legacy Trend-Riding State (for compatibility) ---
var bool inTrendRidingMode = false  // Tracks if the strategy is currently in trend-riding mode.
var int trendRidingStartBar = na    // The bar_index when trend-riding mode was initiated.

// --- Hybrid Exit Mode removed (replaced by allowTrendExit system) ---

// --- Adaptive SuperTrend K-means Clustering State ---
// These variables support the full K-means implementation for volatility analysis.
var array<float> adaptive_hv = array.new_float()       // High volatility cluster data.
var array<float> adaptive_mv = array.new_float()       // Medium volatility cluster data.
var array<float> adaptive_lv = array.new_float()       // Low volatility cluster data.
var array<float> adaptive_amean = array.new_float(1, 0) // Centroid for cluster A.
var array<float> adaptive_bmean = array.new_float(1, 0) // Centroid for cluster B.
var array<float> adaptive_cmean = array.new_float(1, 0) // Centroid for cluster C.
var float adaptive_assigned_centroid = na              // The centroid assigned to the current bar.
var int adaptive_iterations = 0                        // Tracks iterations for the K-means algorithm.

// --- Adaptive SuperTrend Exit Filter State ---
var bool adaptiveExitBlocked = false // True if the adaptive filter is currently blocking an exit.
var bool adaptivePendingExit = false // True if an exit is waiting for the adaptive filter to be cleared.
var string adaptiveExitReason = na   // The reason for the pending exit.

// --- Missing Signal Count Variables ---
var int longSignalCount = 0
var int shortSignalCount = 0

// --- Missing Trend Variables ---
var bool quadrantBullish = false

// --- Missing Control Variables ---
var bool entryAllowed = true
var bool scalpModeActive = false

// --- Missing Exit System Variables (will be assigned from inputs) ---
var bool fixedSlTpEnable = false
var float fixedStopLoss = na
var float fixedTakeProfit = na

// --- Missing MA Exit Variables ---
var float maExitLine = na

// --- Missing Trend Rider Variables ---
var bool trendRiderSignalExit = false

// --------------------------------------------------------------------------------------------------
// SECTION: POSITION SIZING INPUT
// KEYWORDS: Risk Management, Position Size, Quantity, Contracts
// --------------------------------------------------------------------------------------------------
positionQty = input.int(1, 'Number of Contracts', minval = 1, maxval = 1000, group = 'Position Size', tooltip = 'Set the number of contracts/shares to trade per signal')
atrVal = ta.atr(14)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MULTI-SIGNAL INPUT SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Support for multiple buy/sell indicators with AI-style quality assessment

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SIGNAL SOURCE INPUTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
signal1Enable = input.bool(true, 'ðŸ† Signal 1', inline = 'sig1', group = 'ðŸ¹ Multi-Signals', tooltip = 'Primary signal source')
signal1LongSrc = input.source(close, 'Long', inline = 'sig1', group = 'ðŸ¹ Multi-Signals')
signal1ShortSrc = input.source(close, 'Short', inline = 'sig1', group = 'ðŸ¹ Multi-Signals')
signal1Name = input.string('LuxAlgo', 'Name', inline = 'sig1name', group = 'ðŸ¹ Multi-Signals')
signal1Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig1name', group = 'ðŸ¹ Multi-Signals')

signal2Enable = input.bool(false, 'ðŸ† Signal 2', inline = 'sig2', group = 'ðŸ¹ Multi-Signals')
signal2LongSrc = input.source(close, 'Long', inline = 'sig2', group = 'ðŸ¹ Multi-Signals')
signal2ShortSrc = input.source(close, 'Short', inline = 'sig2', group = 'ðŸ¹ Multi-Signals')
signal2Name = input.string('UTBot', 'Name', inline = 'sig2name', group = 'ðŸ¹ Multi-Signals')
signal2Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig2name', group = 'ðŸ¹ Multi-Signals')

signal3Enable = input.bool(false, 'ðŸ† Signal 3', inline = 'sig3', group = 'ðŸ¹ Multi-Signals')
signal3LongSrc = input.source(close, 'Long', inline = 'sig3', group = 'ðŸ¹ Multi-Signals')
signal3ShortSrc = input.source(close, 'Short', inline = 'sig3', group = 'ðŸ¹ Multi-Signals')
signal3Name = input.string('VIDYA', 'Name', inline = 'sig3name', group = 'ðŸ¹ Multi-Signals')
signal3Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig3name', group = 'ðŸ¹ Multi-Signals')

signal4Enable = input.bool(false, 'ðŸ† Signal 4', inline = 'sig4', group = 'ðŸ¹ Multi-Signals')
signal4LongSrc = input.source(close, 'Long', inline = 'sig4', group = 'ðŸ¹ Multi-Signals')
signal4ShortSrc = input.source(close, 'Short', inline = 'sig4', group = 'ðŸ¹ Multi-Signals')
signal4Name = input.string('KyleAlgo', 'Name', inline = 'sig4name', group = 'ðŸ¹ Multi-Signals')
signal4Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig4name', group = 'ðŸ¹ Multi-Signals')

signal5Enable = input.bool(false, 'ðŸ† Signal 5', inline = 'sig5', group = 'ðŸ¹ Multi-Signals')
signal5LongSrc = input.source(close, 'Long', inline = 'sig5', group = 'ðŸ¹ Multi-Signals')
signal5ShortSrc = input.source(close, 'Short', inline = 'sig5', group = 'ðŸ¹ Multi-Signals')
signal5Name = input.string('Wonder', 'Name', inline = 'sig5name', group = 'ðŸ¹ Multi-Signals')
signal5Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig5name', group = 'ðŸ¹ Multi-Signals')

signal6Enable = input.bool(false, 'ðŸ† Signal 6', inline = 'sig6', group = 'ðŸ¹ Multi-Signals')
signal6LongSrc = input.source(close, 'Long', inline = 'sig6', group = 'ðŸ¹ Multi-Signals')
signal6ShortSrc = input.source(close, 'Short', inline = 'sig6', group = 'ðŸ¹ Multi-Signals')
signal6Name = input.string('Custom1', 'Name', inline = 'sig6name', group = 'ðŸ¹ Multi-Signals')
signal6Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig6name', group = 'ðŸ¹ Multi-Signals')

signal7Enable = input.bool(false, 'ðŸ† Signal 7', inline = 'sig7', group = 'ðŸ¹ Multi-Signals')
signal7LongSrc = input.source(close, 'Long', inline = 'sig7', group = 'ðŸ¹ Multi-Signals')
signal7ShortSrc = input.source(close, 'Short', inline = 'sig7', group = 'ðŸ¹ Multi-Signals')
signal7Name = input.string('Custom2', 'Name', inline = 'sig7name', group = 'ðŸ¹ Multi-Signals')
signal7Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig7name', group = 'ðŸ¹ Multi-Signals')

signal8Enable = input.bool(false, 'ðŸ† Signal 8', inline = 'sig8', group = 'ðŸ¹ Multi-Signals')
signal8LongSrc = input.source(close, 'Long', inline = 'sig8', group = 'ðŸ¹ Multi-Signals')
signal8ShortSrc = input.source(close, 'Short', inline = 'sig8', group = 'ðŸ¹ Multi-Signals')
signal8Name = input.string('Custom3', 'Name', inline = 'sig8name', group = 'ðŸ¹ Multi-Signals')
signal8Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig8name', group = 'ðŸ¹ Multi-Signals')

signal9Enable = input.bool(false, 'ðŸ† Signal 9', inline = 'sig9', group = 'ðŸ¹ Multi-Signals')
signal9LongSrc = input.source(close, 'Long', inline = 'sig9', group = 'ðŸ¹ Multi-Signals')
signal9ShortSrc = input.source(close, 'Short', inline = 'sig9', group = 'ðŸ¹ Multi-Signals')
signal9Name = input.string('Custom4', 'Name', inline = 'sig9name', group = 'ðŸ¹ Multi-Signals')
signal9Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig9name', group = 'ðŸ¹ Multi-Signals')

signal10Enable = input.bool(false, 'ðŸ† Signal 10', inline = 'sig10', group = 'ðŸ¹ Multi-Signals')
signal10LongSrc = input.source(close, 'Long', inline = 'sig10', group = 'ðŸ¹ Multi-Signals')
signal10ShortSrc = input.source(close, 'Short', inline = 'sig10', group = 'ðŸ¹ Multi-Signals')
signal10Name = input.string('Custom5', 'Name', inline = 'sig10name', group = 'ðŸ¹ Multi-Signals')
signal10Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig10name', group = 'ðŸ¹ Multi-Signals')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LABELING OPTIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
displayEntryLabels = input.bool(true,  'Show Entry Labels', group = 'ðŸ·ï¸ Labeling')
labelColorLong     = input.color(color.green, 'Long Label Colour',  group = 'ðŸ·ï¸ Labeling', inline='lblcl')
labelColorShort    = input.color(color.red,   'Short Label Colour', group = 'ðŸ·ï¸ Labeling', inline='lblcl')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MA EXIT SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
maExitEnable = input.bool(true, 'Enable MA Exit', group = 'MA Exit')
maExitLength = input.int(21, 'MA Length', minval = 1, group = 'MA Exit')
maExitType = input.string('EMA', 'MA Type', options = ['SMA', 'EMA', 'WMA', 'HMA'], group = 'MA Exit')
maExitSrc = input.source(close, 'MA Source', group = 'MA Exit')

// Smart Profit Locker (Aggressive Profit Protection)
smartProfitEnable = input.bool(false, 'ðŸŽ¯ Enable Smart Profit Locker', group = 'Smart Profit Locker', tooltip = 'Aggressive profit-taking with adjustable pullback sensitivity')
smartProfitType = input.string('ATR', 'Type', options = ['ATR', 'Points', 'Percent'], group = 'Smart Profit Locker')
smartProfitVal = input.float(3.1, 'Value', step = 0.1, group = 'Smart Profit Locker')
smartProfitOffset = input.float(0.10, 'Pullback %', step = 0.05, minval = 0.01, maxval = 1.0, group = 'Smart Profit Locker', tooltip = 'Pullback percentage to trigger exit (0.10 = 10%)')

// Traditional Trailing Stop - REMOVED (use Smart Profit Locker with 100% offset for traditional behavior)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FIXED SL/TP SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
fixedEnable = input.bool(false, 'Enable Fixed SL/TP', group = 'Fixed SL/TP')
fixedUnit = input.string('ATR', 'Unit', options = ['ATR', 'Ticks', 'Points'], group = 'Fixed SL/TP')
fixedStop = input.float(1.0, 'Stop Loss (ATR)', step = 0.1, minval = 0.0, group = 'Fixed SL/TP')
tp1Enable = input.bool(false, 'Enable TP1', inline = 'tp1', group = 'Fixed SL/TP')
tp1Size = input.float(50.0, 'TP1 Size %', inline = 'tp1', group = 'Fixed SL/TP')
tp1Profit = input.float(1.5, 'TP1 Distance (ATR)', step = 0.1, minval = 0.0, group = 'Fixed SL/TP')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STEP CHANNEL SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
stepChannelEnable = input.bool(true, "Enable Step Channel Filter", group="ðŸ› ï¸ Dual-Layer Mode Selection")
stepChannelLength = input.int(3, "Step Channel Length", minval=1, maxval=50, group="ðŸ› ï¸ Dual-Layer Mode Selection")
stepChannelMultiplier = input.float(0.6, "Step Channel Multiplier", minval=0.1, maxval=5.0, step=0.1, group="ðŸ› ï¸ Dual-Layer Mode Selection")
stepChannelShowVisuals = input.bool(true, "Show Step Channel Visuals", group="ðŸ› ï¸ Dual-Layer Mode Selection")
stepChannelColorUp = input.color(color.rgb(26, 190, 127), "Momentum Up Color", inline="SC Colors", group="ðŸ› ï¸ Dual-Layer Mode Selection")
stepChannelColorRange = input.color(color.orange, "Range Color", inline="SC Colors", group="ðŸ› ï¸ Dual-Layer Mode Selection")
stepChannelColorDown = input.color(color.rgb(202, 38, 65), "Momentum Down Color", inline="SC Colors", group="ðŸ› ï¸ Dual-Layer Mode Selection")
stepChannelShowPivots = input.bool(true, "Show Pivot Points", group="ðŸ› ï¸ Dual-Layer Mode Selection")
stepChannelShowCandles = input.bool(true, "Show Momentum Candles", group="ðŸ› ï¸ Dual-Layer Mode Selection")
stepChannelShowLines = input.bool(true, "Show Channel Lines", group="ðŸ› ï¸ Dual-Layer Mode Selection")
stepChannelShowLabel = input.bool(true, "Show Market State Label", group="ðŸ› ï¸ Dual-Layer Mode Selection")

// --------------------------------------------------------------------------------------------------
// SECTION: CONTINUATION ENTRY SYSTEM
// KEYWORDS: Continuation Entry, Entry Precision, False Signal Filter
// --------------------------------------------------------------------------------------------------
// This system improves entry precision by waiting for price to move a specified distance in the
// signal's direction before executing the trade, helping to filter out false signals.

// --- Continuation Entry User Inputs ---
continuationEnable = input.bool(false, 'ðŸŽ¯ Enable Continuation Entry', group='ðŸŽ¯ Continuation Entry System', tooltip='Wait for price continuation before entering trades - improves entry precision and reduces false signals')
continuationValue = input.float(0.25, 'Continuation Distance', step=0.01, minval=0.01, group='ðŸŽ¯ Continuation Entry System', tooltip='Distance price must move in signal direction before entry (supports 2 decimal precision)')
continuationType = input.string('ATR', 'Continuation Type', options=['ATR', 'Points', 'Ticks'], group='ðŸŽ¯ Continuation Entry System', tooltip='ATR: Multiple of ATR value | Points: Absolute price points | Ticks: Number of minimum tick movements')
continuationShowDebug = input.bool(false, 'Show Debug Info', group='ðŸŽ¯ Continuation Entry System', tooltip='Display continuation status and levels on chart for debugging')
continuationTimeoutBars = input.int(10, 'Timeout (Bars)', minval=1, group='ðŸŽ¯ Continuation Entry System', tooltip='Number of bars to wait for continuation before cancelling the pending entry.')

// --- Continuation Entry State Management ---
var float longContinuationLevel = na   // The price level that must be broken for a long entry.
var float shortContinuationLevel = na  // The price level that must be broken for a short entry.
var bool longContinuationActive = false  // True if waiting for a long continuation signal.
var bool shortContinuationActive = false // True if waiting for a short continuation signal.
var int continuationStartBar = na      // The bar_index when the continuation was initiated.
var float continuationStartPrice = na  // The price when the continuation was initiated.

// --------------------------------------------------------------------------------------------------
// SECTION: EXIT SYSTEMS
// KEYWORDS: Exit Logic, Profit Taking, Stop Loss, Risk Management
// --------------------------------------------------------------------------------------------------

// Duplicate exit system inputs removed - restored to correct separate sections above

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND-EXIT FILTERS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
adaptiveExitFilterEnable = input.bool(false, 'ðŸ”¥ Adaptive ST "3" Hold', group='ðŸ› ï¸ Trend-Exit Filters', inline='te1', tooltip='Hold trades when Adaptive SuperTrend shows "3" (high volatility). Simple rule: "If you see a 3, don\'t exit"')
adaptiveRegimeInput = input.source(close, 'Regime Number', group='ðŸ› ï¸ Trend-Exit Filters', inline='av0', tooltip='Connect this to the "Volatility Regime Number" plot from the Adaptive SuperTrend indicator')
adaptiveHoldOn3 = input.bool(true, 'Hold on "3"', group='ðŸ› ï¸ Trend-Exit Filters', inline='te1', tooltip='Do not exit when Adaptive SuperTrend displays "3" (high volatility regime)')
adaptiveHoldOn2 = input.bool(false, 'Hold on "2"', group='ðŸ› ï¸ Trend-Exit Filters', inline='te1', tooltip='Do not exit when Adaptive SuperTrend displays "2" (medium volatility regime)')
adaptiveHoldOn1 = input.bool(false, 'Hold on "1"', group='ðŸ› ï¸ Trend-Exit Filters', inline='te1', tooltip='Do not exit when Adaptive SuperTrend displays "1" (low volatility regime)')

maCrossoverFilterEnable = input.bool(false, 'ðŸ”„ MA Crossover Hold', group='ðŸ› ï¸ Trend-Exit Filters', inline='te2', tooltip='Hold trades until moving averages cross over. Clear visual crossover signal on chart.')
maCrossoverFastLength = input.int(8, 'Fast MA', minval=1, maxval=50, group='ðŸ› ï¸ Trend-Exit Filters', inline='te2', tooltip='Fast moving average length (e.g., 8 SMA)')
maCrossoverSlowLength = input.int(35, 'Slow MA', minval=10, maxval=200, group='ðŸ› ï¸ Trend-Exit Filters', inline='te2', tooltip='Slow moving average length (e.g., 35 SMA)')
maCrossoverType = input.string('SMA', 'MA Type', options=['SMA', 'EMA', 'WMA'], group='ðŸ› ï¸ Trend-Exit Filters', inline='te2b', tooltip='Type of moving average to use for crossover detection')

indicatorExitHeader = input.string('--- Individual Trend Indicator Exits ---', 'Indicator Exit Config', group='ðŸ› ï¸ Trend-Exit Filters', inline='te3', tooltip='Each trend indicator can be used as an individual trend exit. Allows testing each indicator as sole trend exit method.')

hullTrendExit = input.bool(false, 'ðŸŒŠ Hull Exit', group='ðŸ› ï¸ Trend-Exit Filters', inline='te4', tooltip='Exit when Hull Suite trend changes direction')
quadrantTrendExit = input.bool(false, 'ðŸŽ¯ Quadrant Exit', group='ðŸ› ï¸ Trend-Exit Filters', inline='te4', tooltip='Exit when Quadrant NW trend changes')

adaptiveTrendExit = input.bool(false, 'ðŸ”„ Adaptive Exit', group='ðŸ› ï¸ Trend-Exit Filters', inline='te5', tooltip='Exit when Adaptive SuperTrend trend changes')
volumaticTrendExit = input.bool(false, 'ðŸ“Š Volumatic Exit', group='ðŸ› ï¸ Trend-Exit Filters', inline='te5', tooltip='Exit when Volumatic VIDYA trend changes')
smoothHATrendExit = input.bool(false, 'ðŸ•¯ï¸ Smooth HA Exit', group='ðŸ› ï¸ Trend-Exit Filters', inline='te5', tooltip='Exit when Smooth Heiken Ashi trend changes')

trendExitSignalEnable = input.bool(false, 'ðŸ“¡ External Trend Exit', group='ðŸ› ï¸ Trend-Exit Filters', inline='te6', tooltip='Use external indicator (like Trend Strength) for trend exit signals. Connect to buy/sell signal from external indicator.')
trendExitSignalSrc = input.source(close, 'Signal Source', group='ðŸ› ï¸ Trend-Exit Filters', inline='te6', tooltip='Connect this to the buy/sell signal output from your external trend exit indicator (e.g., Trend Strength arrows)')

trendExitLogic = input.string('Any Filter Triggers Exit', 'Exit Logic', options=['Any Filter Triggers Exit', 'All Filters Must Agree'], group='ðŸ› ï¸ Trend-Exit Filters', inline='te7', tooltip='ANY: Exit when first filter condition is met. ALL: Wait for all enabled filters to agree before exiting.')
trendExitDebug = input.bool(false, 'Show Debug Info', group='ðŸ› ï¸ Trend-Exit Filters', inline='te7', tooltip='Display debug information about trend-exit filter status on chart')

biasConfluence = input.string('Any', 'Confluence Mode', options=['Any', 'Majority', 'All'], group='ðŸ› ï¸ Trend-Exit Filters', tooltip='Any: At least one indicator agrees | Majority: Most indicators agree | All: All enabled indicators agree')

// Duplicate signal input section removed - signals already declared above in Multi-Signals section
// All duplicate signal declarations removed
// Remaining duplicate signals 2-10 removed
// All remaining duplicate signal declarations (3-10) and duplicate labeling options removed

// --------------------------------------------------------------------------------------------------
// SECTION: SIGNAL SOURCE VALIDATION
// KEYWORDS: Signal Validation, Safety, Bug Fix, False Signal
// --------------------------------------------------------------------------------------------------
// CRITICAL SAFETY FEATURE: Prevents false signals from being generated by unconnected input sources.
// A signal is only considered valid if its source is NOT the default `close`, `open`, `high`, or `low` price.

// Helper function to validate that a signal source is connected to a real indicator plot.
isValidSignalSource(src) =>
    not na(src) and src != close and src != open and src != high and src != low

// Stricter validation for external indicators to ensure uniform safety across all signals.
isValidExternalSignal(src) =>
    not na(src) and src != close and src != open and src != high and src != low

// --------------------------------------------------------------------------------------------------
// SECTION: SIGNAL USAGE PROCESSING
// KEYWORDS: Signal Usage, Entry Logic, Exit Logic, Flexible Signals
// --------------------------------------------------------------------------------------------------
// This helper function processes raw signals based on the 'Usage' dropdown selected for each signal.
// It allows each indicator to be flexibly assigned to different roles (e.g., long only, exit only).

processSignalWithUsage(bool rawLongSignal, bool rawShortSignal, string usage) =>
    var bool processedLong = false
    var bool processedShort = false
    var bool isEntrySignal = false
    var bool isExitSignal = false
    
    // Determine the signal's role based on the user-selected usage type.
    isEntrySignal := usage == 'All Entries' or usage == 'Entry Long Only' or usage == 'Entry Short Only'
    isExitSignal := usage == 'Exit All' or usage == 'Exit Long Only' or usage == 'Exit Short Only'
    
    // Apply the usage logic to the raw signals.
    if usage == 'All Entries'
        processedLong := rawLongSignal
        processedShort := rawShortSignal
    else if usage == 'Entry Long Only'
        processedLong := rawLongSignal
        processedShort := false  // Block short entries.
    else if usage == 'Entry Short Only'
        processedLong := false   // Block long entries.
        processedShort := rawShortSignal
    else if usage == 'Exit All' or usage == 'Exit Long Only' or usage == 'Exit Short Only'
        // Exit signals are handled by the trend-riding logic, not the primary entry system.
        processedLong := false
        processedShort := false
    else if usage == 'Observe'
        // 'Observe' mode tracks the signal but does not generate trades.
        processedLong := false
        processedShort := false
    else
        // Default to 'All Entries' behavior if the usage type is unrecognized.
        processedLong := rawLongSignal
        processedShort := rawShortSignal
    
    [processedLong, processedShort, isEntrySignal, isExitSignal]

// --------------------------------------------------------------------------------------------------
// SECTION: CORE SIGNAL PROCESSING LOGIC
// KEYWORDS: Signal Detection, Raw Signals, Core Logic
// --------------------------------------------------------------------------------------------------
// This is the primary signal detection block. It checks if each enabled signal is valid (i.e., connected)
// and if its plot value is active (greater than 0 or true).

// --- Raw Signal Detection ---
// This logic forms the foundation of the entry system. DO NOT MODIFY.
rawSig1Long = signal1Enable and isValidSignalSource(signal1LongSrc) ? (signal1LongSrc > 0 or bool(signal1LongSrc) == true) : false
rawSig1Short = signal1Enable and isValidSignalSource(signal1ShortSrc) ? (signal1ShortSrc > 0 or bool(signal1ShortSrc) == true) : false
rawSig2Long = signal2Enable and isValidSignalSource(signal2LongSrc) ? (signal2LongSrc > 0 or bool(signal2LongSrc) == true) : false
rawSig2Short = signal2Enable and isValidSignalSource(signal2ShortSrc) ? (signal2ShortSrc > 0 or bool(signal2ShortSrc) == true) : false
rawSig3Long = signal3Enable and isValidSignalSource(signal3LongSrc) ? (signal3LongSrc > 0 or bool(signal3LongSrc) == true) : false
rawSig3Short = signal3Enable and isValidSignalSource(signal3ShortSrc) ? (signal3ShortSrc > 0 or bool(signal3ShortSrc) == true) : false
rawSig4Long = signal4Enable and isValidSignalSource(signal4LongSrc) ? (signal4LongSrc > 0 or bool(signal4LongSrc) == true) : false
rawSig4Short = signal4Enable and isValidSignalSource(signal4ShortSrc) ? (signal4ShortSrc > 0 or bool(signal4ShortSrc) == true) : false
rawSig5Long = signal5Enable and isValidExternalSignal(signal5LongSrc) ? (signal5LongSrc > 0 or bool(signal5LongSrc) == true) : false
rawSig5Short = signal5Enable and isValidExternalSignal(signal5ShortSrc) ? (signal5ShortSrc > 0 or bool(signal5ShortSrc) == true) : false
rawSig6Long = signal6Enable and isValidSignalSource(signal6LongSrc) ? (signal6LongSrc > 0 or bool(signal6LongSrc) == true) : false
rawSig6Short = signal6Enable and isValidSignalSource(signal6ShortSrc) ? (signal6ShortSrc > 0 or bool(signal6ShortSrc) == true) : false
rawSig7Long = signal7Enable and isValidSignalSource(signal7LongSrc) ? (signal7LongSrc > 0 or bool(signal7LongSrc) == true) : false
rawSig7Short = signal7Enable and isValidSignalSource(signal7ShortSrc) ? (signal7ShortSrc > 0 or bool(signal7ShortSrc) == true) : false
rawSig8Long = signal8Enable and isValidSignalSource(signal8LongSrc) ? (signal8LongSrc > 0 or bool(signal8LongSrc) == true) : false
rawSig8Short = signal8Enable and isValidSignalSource(signal8ShortSrc) ? (signal8ShortSrc > 0 or bool(signal8ShortSrc) == true) : false
rawSig9Long = signal9Enable and isValidSignalSource(signal9LongSrc) ? (signal9LongSrc > 0 or bool(signal9LongSrc) == true) : false
rawSig9Short = signal9Enable and isValidSignalSource(signal9ShortSrc) ? (signal9ShortSrc > 0 or bool(signal9ShortSrc) == true) : false
rawSig10Long = signal10Enable and isValidSignalSource(signal10LongSrc) ? (signal10LongSrc > 0 or bool(signal10LongSrc) == true) : false
rawSig10Short = signal10Enable and isValidSignalSource(signal10ShortSrc) ? (signal10ShortSrc > 0 or bool(signal10ShortSrc) == true) : false

// Process signals with usage settings (NEW FEATURE)
[sig1Long, sig1Short, sig1IsEntry, sig1IsExit] = processSignalWithUsage(rawSig1Long, rawSig1Short, signal1Usage)
[sig2Long, sig2Short, sig2IsEntry, sig2IsExit] = processSignalWithUsage(rawSig2Long, rawSig2Short, signal2Usage)
[sig3Long, sig3Short, sig3IsEntry, sig3IsExit] = processSignalWithUsage(rawSig3Long, rawSig3Short, signal3Usage)
[sig4Long, sig4Short, sig4IsEntry, sig4IsExit] = processSignalWithUsage(rawSig4Long, rawSig4Short, signal4Usage)
[sig5Long, sig5Short, sig5IsEntry, sig5IsExit] = processSignalWithUsage(rawSig5Long, rawSig5Short, signal5Usage)
[sig6Long, sig6Short, sig6IsEntry, sig6IsExit] = processSignalWithUsage(rawSig6Long, rawSig6Short, signal6Usage)
[sig7Long, sig7Short, sig7IsEntry, sig7IsExit] = processSignalWithUsage(rawSig7Long, rawSig7Short, signal7Usage)
[sig8Long, sig8Short, sig8IsEntry, sig8IsExit] = processSignalWithUsage(rawSig8Long, rawSig8Short, signal8Usage)
[sig9Long, sig9Short, sig9IsEntry, sig9IsExit] = processSignalWithUsage(rawSig9Long, rawSig9Short, signal9Usage)
[sig10Long, sig10Short, sig10IsEntry, sig10IsExit] = processSignalWithUsage(rawSig10Long, rawSig10Short, signal10Usage)

// --------------------------------------------------------------------------------------------------
// SECTION: SIGNAL CONFLUENCE & COUNTING
// KEYWORDS: Signal Count, Confluence, Entry Trigger
// --------------------------------------------------------------------------------------------------
// This block counts the total number of active long and short signals that are configured for entry.
// This count is the primary driver for trade execution.

// --- Signal Counting Logic ---
// DO NOT MODIFY. This logic is essential for the strategy's entry decisions.
var int sigCountLong = 0
var int sigCountShort = 0

sigCountLong := (sig1IsEntry and sig1Long ? 1 : 0) + (sig2IsEntry and sig2Long ? 1 : 0) + (sig3IsEntry and sig3Long ? 1 : 0) + (sig4IsEntry and sig4Long ? 1 : 0) + (sig5IsEntry and sig5Long ? 1 : 0) + (sig6IsEntry and sig6Long ? 1 : 0) + (sig7IsEntry and sig7Long ? 1 : 0) + (sig8IsEntry and sig8Long ? 1 : 0) + (sig9IsEntry and sig9Long ? 1 : 0) + (sig10IsEntry and sig10Long ? 1 : 0)
sigCountShort := (sig1IsEntry and sig1Short ? 1 : 0) + (sig2IsEntry and sig2Short ? 1 : 0) + (sig3IsEntry and sig3Short ? 1 : 0) + (sig4IsEntry and sig4Short ? 1 : 0) + (sig5IsEntry and sig5Short ? 1 : 0) + (sig6IsEntry and sig6Short ? 1 : 0) + (sig7IsEntry and sig7Short ? 1 : 0) + (sig8IsEntry and sig8Short ? 1 : 0) + (sig9IsEntry and sig9Short ? 1 : 0) + (sig10IsEntry and sig10Short ? 1 : 0)

// Assign to global signal count variables
longSignalCount := sigCountLong
shortSignalCount := sigCountShort


// --------------------------------------------------------------------------------------------------
// SECTION: DIRECTIONAL & REGIME FILTERS
// KEYWORDS: Trend Filter, Regime Filter, Directional Bias
// --------------------------------------------------------------------------------------------------

// --- Step Channel Calculation ---
var float stepChannelUpper = na
var float stepChannelLower = na
if (stepChannelEnable)
    basis = ta.sma(close, stepChannelLength)
    atrForChannel = ta.atr(stepChannelLength)
    stepChannelUpper := basis + atrForChannel * stepChannelMultiplier
    stepChannelLower := basis - atrForChannel * stepChannelMultiplier

// --- Step Channel Momentum Filter Logic ---
var bool stepChannelLongOK = true
var bool stepChannelShortOK = true
stepChannelLongOK := not stepChannelEnable or (close > stepChannelLower)
stepChannelShortOK := not stepChannelEnable or (close < stepChannelUpper)

// --- Master Directional Permissions ---
allowLongs = stepChannelLongOK
allowShorts = stepChannelShortOK

// --- Entry Permission Logic ---
// Using strategy's default pyramiding setting (system defaults as requested)
entryAllowed := true


// --------------------------------------------------------------------------------------------------
// SECTION: FINAL ENTRY SIGNAL GENERATION & EXECUTION (REFACTORED)
// KEYWORDS: Entry Signal, Final Check, Filter Application, Continuation, Strategy Execution
// --------------------------------------------------------------------------------------------------

// --- Step 1: Define Base Signal with Directional Filters ---
// This is the raw signal after applying the primary directional filters (e.g., Step Channel).
baseLongSignal = sigCountLong > 0 and allowLongs
baseShortSignal = sigCountShort > 0 and allowShorts

// --- Step 2: Determine Final Entry Signal ---
// The final entry signal is determined here. If continuation is enabled, entry requires the price
// to cross the continuation level. Otherwise, entry is triggered directly by the base signal.
longEntrySignal = continuationEnable ? (longContinuationActive and high >= longContinuationLevel) : baseLongSignal
shortEntrySignal = continuationEnable ? (shortContinuationActive and low <= shortContinuationLevel) : baseShortSignal

// --- Step 3: Core Strategy Execution --- 
// This is the single, unified entry point for the strategy. It prevents duplicate entries.
if (longEntrySignal)
    strategy.entry("Long", strategy.long, qty=positionQty)

if (shortEntrySignal)
    strategy.entry("Short", strategy.short, qty=positionQty)

// --- Step 4: Reset Continuation State After Entry ---
// Once a continuation entry is successfully triggered, reset its state to wait for the next signal.
if longEntrySignal and continuationEnable and longContinuationActive
    longContinuationActive := false
    longContinuationLevel := na
    if continuationShowDebug
        debugInfo("âœ… LONG CONTINUATION TRIGGERED: Entry confirmed")

if shortEntrySignal and continuationEnable and shortContinuationActive
    shortContinuationActive := false
    shortContinuationLevel := na
    if continuationShowDebug
        debugInfo("âœ… SHORT CONTINUATION TRIGGERED: Entry confirmed")

// Emergency close functionality removed as requested

// --------------------------------------------------------------------------------------------------
// SECTION: ADVANCED EXIT SYSTEM LOGIC
// KEYWORDS: Exit Calculations, Dynamic Stops, Trailing, Profit Protection
// --------------------------------------------------------------------------------------------------
// This block contains the calculations and execution logic for all advanced exit systems.

// --- Exit System Calculations ---
// Calculate the necessary indicators and values for the exit systems.
// Dynamically calculate the selected Moving Average for the exit system.
maExitVal = switch maExitType
    'SMA' => ta.sma(maExitSrc, maExitLength)
    'EMA' => ta.ema(maExitSrc, maExitLength)
    'WMA' => ta.wma(maExitSrc, maExitLength)
    'HMA' => ta.hma(maExitSrc, maExitLength)
    => na

// --- Position Tracking & Entry Price ---
// We need to know the entry price to calculate fixed SL/TP levels.
var float strategyEntryPrice = na
if (strategy.position_size > 0 and strategy.position_size[1] <= 0)
    strategyEntryPrice := strategy.opentrades.entry_price(strategy.opentrades - 1)
if (strategy.position_size < 0 and strategy.position_size[1] >= 0)
    strategyEntryPrice := strategy.opentrades.entry_price(strategy.opentrades - 1)

// --- MA Exit Logic (extracted for Pine Script v6 consistency) ---
longMAExit = ta.crossunder(close, maExitVal)
shortMAExit = ta.crossover(close, maExitVal)

// --- Fixed SL/TP & MA Exit Logic ---
if (strategy.position_size != 0)
    // Fixed SL/TP
    longStopPrice = strategyEntryPrice - (atrVal * fixedStop)
    longTp1Price = strategyEntryPrice + (atrVal * tp1Profit)
    shortStopPrice = strategyEntryPrice + (atrVal * fixedStop)
    shortTp1Price = strategyEntryPrice - (atrVal * tp1Profit)

    if (fixedEnable)
        strategy.exit('Fixed SL/TP', from_entry='Long', stop=longStopPrice, limit=tp1Enable ? longTp1Price : na, qty_percent=tp1Enable ? tp1Size : 100)
        strategy.exit('Fixed SL/TP', from_entry='Short', stop=shortStopPrice, limit=tp1Enable ? shortTp1Price : na, qty_percent=tp1Enable ? tp1Size : 100)

    // MA Exit
    if (maExitEnable and longMAExit)
        strategy.close('Long', comment='MA Exit')
    if (maExitEnable and shortMAExit)
        strategy.close('Short', comment='MA Exit')

// Incorrect Smart Profit Locker implementation removed - using original version below

// --- Optional: Debug Validation ---
// If debug mode is active, this will warn the user if a signal is enabled but not properly connected,
// preventing silent failures and making setup easier.
if debugEnabled and signal1Enable and not isValidSignalSource(signal1LongSrc)
    debugWarn("Signal 1 Long blocked: Source equals default close price. Connect external indicator.")
if debugEnabled and signal1Enable and not isValidSignalSource(signal1ShortSrc)
    debugWarn("Signal 1 Short blocked: Source equals default close price. Connect external indicator.")

// --------------------------------------------------------------------------------------------------
// SECTION: SIGNAL ARRAY MANAGEMENT
// KEYWORDS: Signal Array, Memory Management, Performance, Pine Script Array
// --------------------------------------------------------------------------------------------------
// To ensure high performance and prevent memory leaks, we use persistent arrays (`var`).
// These arrays are created only once on the first bar and their values are updated on subsequent bars.

// --- Step 2: Initialize Persistent Signal Arrays ---
var allLongSignals = array.new<bool>(10)
var allShortSignals = array.new<bool>(10)

// --- Step 3: Update Array Values ---
// The state of each processed signal (true or false) is efficiently set in the persistent arrays on every bar.
array.set(allLongSignals, 0, sig1Long)
array.set(allLongSignals, 1, sig2Long)
array.set(allLongSignals, 2, sig3Long)
array.set(allLongSignals, 3, sig4Long)
array.set(allLongSignals, 4, sig5Long)
array.set(allLongSignals, 5, sig6Long)
array.set(allLongSignals, 6, sig7Long)
array.set(allLongSignals, 7, sig8Long)
array.set(allLongSignals, 8, sig9Long)
array.set(allLongSignals, 9, sig10Long)

array.set(allShortSignals, 0, sig1Short)
array.set(allShortSignals, 1, sig2Short)
array.set(allShortSignals, 2, sig3Short)
array.set(allShortSignals, 3, sig4Short)
array.set(allShortSignals, 4, sig5Short)
array.set(allShortSignals, 5, sig6Short)
array.set(allShortSignals, 6, sig7Short)
array.set(allShortSignals, 7, sig8Short)
array.set(allShortSignals, 8, sig9Short)
array.set(allShortSignals, 9, sig10Short)

// --------------------------------------------------------------------------------------------------
// SECTION: CONFLUENCE COUNTING
// KEYWORDS: Signal Count, Confluence, Entry Condition
// --------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------
// SECTION: CONTINUATION ENTRY SYSTEM
// KEYWORDS: Continuation Entry, Price Confirmation, Intrabar Execution, Trade Entry Filter
// --------------------------------------------------------------------------------------------------
// This system acts as a filter, requiring price to move a specified distance after a signal appears
// before an entry is triggered. This helps confirm momentum and avoid false signals.

// --- Step 1: Calculate Continuation Distance ---
// Helper function to determine the required price movement based on the selected type.
calculateContinuationDistance() =>
    float distance = 0.0
    if continuationType == 'ATR'
        distance := continuationValue * atrVal // Distance based on Average True Range
    else if continuationType == 'Points'
        distance := continuationValue // Fixed distance in price points
    else if continuationType == 'Ticks'
        distance := continuationValue * syminfo.mintick // Fixed distance in minimum price increments (ticks)
    distance

// Get the currently configured continuation distance.
continuationDistance = continuationEnable ? calculateContinuationDistance() : 0.0

// --- Step 2: Define Raw Signal State ---
// A raw signal is considered active if at least one of the underlying indicators has fired.
// CRITICAL FIX: Use the correct signal count variables (sigCountLong/Short) that respect the 'Usage' settings.
baseLongSignalWithFilters = sigCountLong > 0 and allowLongs
baseShortSignalWithFilters = sigCountShort > 0 and allowShorts

// --- Step 3: Manage Continuation State ---
// This block handles the activation, cancellation, and timeout of continuation entries.
if continuationEnable
    // --- A) Activate Continuation on New Signal ---
    // When a new signal appears (and no trade is open), set the price level that must be crossed.
    if baseLongSignalWithFilters and not baseLongSignalWithFilters[1] and not longContinuationActive and strategy.position_size == 0
        longContinuationLevel := close + continuationDistance // Set the target price for long entry
        longContinuationActive := true
        shortContinuationActive := false // Cancel any opposing continuation
        shortContinuationLevel := na
        continuationStartBar := bar_index
        continuationStartPrice := close
        if continuationShowDebug
            debugInfo("ðŸŽ¯ LONG CONTINUATION SET: Level=" + str.tostring(longContinuationLevel) + " Distance=" + str.tostring(continuationDistance))
    
    else if baseShortSignalWithFilters and not baseShortSignalWithFilters[1] and not shortContinuationActive and strategy.position_size == 0
        shortContinuationLevel := close - continuationDistance // Set the target price for short entry
        shortContinuationActive := true
        longContinuationActive := false // Cancel any opposing continuation
        longContinuationLevel := na
        continuationStartBar := bar_index
        continuationStartPrice := close
        if continuationShowDebug
            debugInfo("ðŸŽ¯ SHORT CONTINUATION SET: Level=" + str.tostring(shortContinuationLevel) + " Distance=" + str.tostring(continuationDistance))
    
    // --- C) Cancel Continuation on Timeout ---
    // If price fails to reach the continuation level within a set number of bars, cancel it.
    if continuationTimeoutBars > 0 and (longContinuationActive or shortContinuationActive) and bar_index > continuationStartBar + continuationTimeoutBars
        if longContinuationActive
            longContinuationActive := false
            longContinuationLevel := na
            if continuationShowDebug
                debugInfo(" LONG CONTINUATION TIMEOUT: Bar limit exceeded")
        if shortContinuationActive
            shortContinuationActive := false
            shortContinuationLevel := na
            if continuationShowDebug
                debugInfo(" SHORT CONTINUATION TIMEOUT: Bar limit exceeded")

// --------------------------------------------------------------------------------------------------
// SECTION: FINAL ENTRY SIGNAL GENERATION
// KEYWORDS: Entry Signal, Trade Trigger, Final Logic
// --------------------------------------------------------------------------------------------------
// --- Step 4: Determine Final Entry Signal ---


// --------------------------------------------------------------------------------------------------
// SECTION: CONTINUATION ENTRY DEBUG VISUALIZATION
// KEYWORDS: Debug Plot, Visualization, Charting, Plotshape, Bgcolor, Label
// --------------------------------------------------------------------------------------------------
// This section provides a rich visual debugging experience for the continuation entry system.

// A master boolean to control the visibility of all debug visuals in this section.
showContinuationDebug = continuationEnable and continuationShowDebug

// --- A) Plot Continuation Price Levels ---
// Draws a horizontal line at the exact price where an entry will be triggered. The plot only appears if debugging is active.
plot(showContinuationDebug and longContinuationActive ? longContinuationLevel : na, "Long Continuation Level", color=color.new(color.green, 50), style=plot.style_linebr, linewidth=2)
plot(showContinuationDebug and shortContinuationActive ? shortContinuationLevel : na, "Short Continuation Level", color=color.new(color.red, 50), style=plot.style_linebr, linewidth=2)

// --- B) Highlight Active Continuation State ---
// Changes the chart's background color to indicate that the system is actively waiting for a price confirmation.
bgColor = showContinuationDebug and longContinuationActive ? color.new(color.green, 95) : showContinuationDebug and shortContinuationActive ? color.new(color.red, 95) : na
bgcolor(bgColor, title="Continuation Active")
    
// --- C) Display Detailed Status Label on the Last Bar ---
// Extract ta.highest for Pine Script v6 consistency
highestHigh20 = ta.highest(high, 20)

// For real-time monitoring, this creates a detailed label on the most recent bar summarizing the active continuation state.
if barstate.islast and (longContinuationActive or shortContinuationActive)
    // Prepare the text content for the label.
    continuationStatus = longContinuationActive ?         "ðŸŽ¯ LONG CONTINUATION\nLevel: " + str.tostring(longContinuationLevel, '#.#####') + "\nDistance: " + str.tostring(continuationDistance) + " (" + continuationType + ")" :        "ðŸŽ¯ SHORT CONTINUATION\nLevel: " + str.tostring(shortContinuationLevel, '#.#####') + "\nDistance: " + str.tostring(continuationDistance) + " (" + continuationType + ")"
    
    // Create the label on the chart.
    label.new(bar_index, highestHigh20, continuationStatus, 
      color=longContinuationActive ? color.new(color.green, 20) : color.new(color.red, 20), 
      textcolor=color.white, style=label.style_label_down, yloc=yloc.price, size=size.normal)

// --------------------------------------------------------------------------------------------------
// SECTION: RBW FILTER DEPENDENCY
// KEYWORDS: Import, Library, Dependency, RBW Filter
// --------------------------------------------------------------------------------------------------
// This line imports an external library named 'enhanced_ta'. This library is required for the 
// 'RBW Filter' (Range & Bar-type Width Filter), which is a directional bias filter used later in the script.
import HeWhoMustNotBeNamed/enhanced_ta/14 as eta

// --------------------------------------------------------------------------------------------------
// SECTION: HELPER FUNCTION - BUILD SIGNAL NAME
// KEYWORDS: Helper Function, Debugging, Signal Name, String Concatenation
// --------------------------------------------------------------------------------------------------
// This utility function constructs a string that lists the names of all active signals for a given
// trade direction (long or short). The resulting string (e.g., "S1+S3+S5") is used for chart labels.
// @param isLong (bool) - If true, builds the name for long signals; otherwise, for short signals.
// @return (string) A '+' separated string of active signal names.
buildSignalName(bool isLong) =>
    string names = "" // Initialize an empty string to store the names.
    
    // Check if we are building for long or short signals.
    if isLong
        // Iterate through all 10 long signals.
        if sig1Long
            names := names + (names == "" ? "" : "+") + signal1Name // Append the name, adding a '+' if it's not the first one.
        if sig2Long
            names := names + (names == "" ? "" : "+") + signal2Name
        if sig3Long
            names := names + (names == "" ? "" : "+") + signal3Name
        if sig4Long
            names := names + (names == "" ? "" : "+") + signal4Name
        if sig5Long
            names := names + (names == "" ? "" : "+") + signal5Name
        if sig6Long
            names := names + (names == "" ? "" : "+") + signal6Name
        if sig7Long
            names := names + (names == "" ? "" : "+") + signal7Name
        if sig8Long
            names := names + (names == "" ? "" : "+") + signal8Name
        if sig9Long
            names := names + (names == "" ? "" : "+") + signal9Name
        if sig10Long
            names := names + (names == "" ? "" : "+") + signal10Name
    else
        // Iterate through all 10 short signals.
        if sig1Short
            names := names + (names == "" ? "" : "+") + signal1Name
        if sig2Short
            names := names + (names == "" ? "" : "+") + signal2Name
        if sig3Short
            names := names + (names == "" ? "" : "+") + signal3Name
        if sig4Short
            names := names + (names == "" ? "" : "+") + signal4Name
        if sig5Short
            names := names + (names == "" ? "" : "+") + signal5Name
        if sig6Short
            names := names + (names == "" ? "" : "+") + signal6Name
        if sig7Short
            names := names + (names == "" ? "" : "+") + signal7Name
        if sig8Short
            names := names + (names == "" ? "" : "+") + signal8Name
        if sig9Short
            names := names + (names == "" ? "" : "+") + signal9Name
        if sig10Short
            names := names + (names == "" ? "" : "+") + signal10Name
    
    // Return the final concatenated string.
    names

// --- Call the helper function to generate the signal name strings for the current bar ---
longSignalName = buildSignalName(true) // Generate the signal name for long signals.
shortSignalName = buildSignalName(false) // Generate the signal name for short signals.

// --------------------------------------------------------------------------------------------------
// SECTION: LEGACY SIGNAL PROCESSING SETUP
// KEYWORDS: Legacy, Backward Compatibility, Signal Aggregation
// --------------------------------------------------------------------------------------------------
// These variables are maintained for backward compatibility with older or simpler parts of the strategy
// that may not use the full multi-signal confluence system. They provide a single boolean value
// indicating if ANY long or short signal is active.
primaryLongSig = sig1Long or sig2Long or sig3Long or sig4Long or sig5Long or sig6Long or sig7Long or sig8Long or sig9Long or sig10Long
primaryShortSig = sig1Short or sig2Short or sig3Short or sig4Short or sig5Short or sig6Short or sig7Short or sig8Short or sig9Short or sig10Short



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1 Â· TRADERSPOST JSON HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€ Pre-built JSON messages (compile-time constants) â”€â”€â”€â”€â”€
// Use TradingView alert placeholders so we avoid any per-bar string operations.
// Placeholders {{close}} and {{timenow}} will be expanded at alert trigger time.
var string _jsonBase = '{"ticker":"' + syminfo.ticker + '","price":{{close}},"time":{{timenow}}'

var string longEntryMsg = _jsonBase + ',"action":"buy","sentiment":"long"}'
var string shortEntryMsg = _jsonBase + ',"action":"sell","sentiment":"short"}'
var string flatExitMsg = _jsonBase + ',"action":"exit","sentiment":"flat"}'
var string longExitMsg = _jsonBase + ',"action":"sell","sentiment":"flat"}' // closes long
var string shortExitMsg = _jsonBase + ',"action":"buy","sentiment":"flat"}' // closes short

// â”€â”€â”€â”€â”€ Volatility Ratio (global) for adaptive stop & debug â”€â”€â”€â”€â”€
// Re-computed every bar (not a "var") so downstream logic can read it.
smaAtr = ta.sma(atrVal, 50)
volatilityRatio = smaAtr > 1e-10 ? atrVal / smaAtr : 1.0




// Initialize debug logging on first bar
if barstate.isfirst
    debugInfo('EZAlgoTrader initialized with debug logging')


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HELPER CALCULATIONS FOR EXITS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Re-create helpers that were removed with the legacy input block.

// --- MA for MA Exit System ---
float priceMA = switch maExitType
    'SMA' => ta.sma(maExitSrc, maExitLength)
    'EMA' => ta.ema(maExitSrc, maExitLength)
    'WMA' => ta.wma(maExitSrc, maExitLength)
    'HMA' => ta.hma(maExitSrc, maExitLength)
    => na

// Update global MA exit line variable
maExitLine := priceMA

// --- Distance Calculator for Fixed SL/TP ---
tpCalc(d) =>
    fixedUnit == 'ATR' ? d * atrVal : fixedUnit == 'Ticks' ? d * syminfo.mintick : d


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• REAL STRATEGY EXIT LOGIC (CRITICAL FIX) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Track entry price for distance-based exits

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• EXIT CONTROL FLAGS (INTRABAR SYSTEM) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Per-method flags to prevent duplicate alerts and enable prioritization
var bool maExitSent = false
var bool fixedExitSent = false
var bool fibExitSent = false
var bool trailExitSent = false
var bool customExitSent = false
var bool inPosition = false
var bool exitInProgress = false

// Position tracking and flag reset logic
if strategy.position_size == 0
    strategyEntryPrice := na
else if strategy.position_size != 0 and na(strategyEntryPrice)
    strategyEntryPrice := strategy.position_avg_price

// Reset all exit flags on new position entry
currentPosition = strategy.position_size != 0
if currentPosition and not inPosition
    // New trade detected - reset all flags
    maExitSent := false
    fixedExitSent := false
    fibExitSent := false
    trailExitSent := false
    customExitSent := false
    exitInProgress := false
    inPosition := true
else if not currentPosition and inPosition
    // Trade closed - update state
    inPosition := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ROBUST INTRABAR EXIT SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Exit logic that works properly while preventing alert spam
// Key insight: strategy.exit() calls must run every bar, only alerts should be limited

// â”€â”€â”€â”€â”€â”€â”€â”€ 1. MA EXIT (Intrabar with Anti-Spam) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if maExitEnable and strategy.position_size != 0
    longMaExit = strategy.position_size > 0 and close < priceMA
    shortMaExit = strategy.position_size < 0 and close > priceMA
    
    if longMaExit and not maExitSent
        strategy.close('Long', comment='MA Exit ', alert_message=longExitMsg)
        maExitSent := true
    else if shortMaExit and not maExitSent
        strategy.close('Short', comment='MA Exit ', alert_message=shortExitMsg)
        maExitSent := true

// â”€â”€â”€â”€â”€â”€â”€â”€ 2. FIXED SL/TP (Always Active) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if fixedEnable and strategy.position_size != 0 and not fixedExitSent
    // KEYWORDS: Exit System, Stop Loss, Take Profit, Fixed Exit, `strategy.exit`
    // This block places a standard, non-trailing stop-loss and an optional take-profit order
    // immediately after a trade is entered. It's a fundamental risk management feature.

    // --- Step 1: Calculate Stop and Profit Distances ---
    // The `tpCalc` helper function converts the user's input (ATR, Ticks, %) into a price distance.
    stopDistance = tpCalc(fixedStop)
    profitDistance = tp1Enable ? tpCalc(tp1Size) : na // TP is optional.
    
    // Fallback to ensure the stop distance is always a valid, positive number.
    if na(stopDistance) or stopDistance <= 0
        stopDistance := 0.01
    
    // --- Step 2: Place Exit Orders based on Position ---
    if strategy.position_size > 0  // In a long position
        // Calculate the absolute price levels for the stop and limit orders.
        stopLevel = math.max(strategyEntryPrice - stopDistance, close * 0.99) // Safety net to prevent extreme stop levels.
        profitLevel = not na(profitDistance) ? strategyEntryPrice + profitDistance : na
        
        // Place the exit order with both a stop and a limit component.
        strategy.exit('Fixed-Long', from_entry='Long', stop=stopLevel, limit=profitLevel, comment='Fixed SL/TP')
        
        // Set the anti-spam flag to prevent this order from being placed again on subsequent bars.
        if not fixedExitSent
            fixedExitSent := true
    
    else if strategy.position_size < 0  // In a short position
        // Calculate the stop and limit levels for the short trade.
        stopLevel = math.min(strategyEntryPrice + stopDistance, close * 1.01)
        profitLevel = not na(profitDistance) ? strategyEntryPrice - profitDistance : na
        
        // Place the corresponding exit order for the short position.
        strategy.exit('Fixed-Short', from_entry='Short', stop=stopLevel, limit=profitLevel, comment='Fixed SL/TP')
        
        // Set the anti-spam flag.
        if not fixedExitSent
            fixedExitSent := true



// â”€â”€â”€â”€â”€â”€â”€â”€ 4. SMART PROFIT LOCKER (Aggressive Profit Protection) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW TREND-EXIT/HOLD FILTER INTEGRATION: Block Smart Profit Locker when trend-hold filters are active
// Only run Smart Profit Locker when trend-exit is allowed by the new filter system
if smartProfitEnable and strategy.position_size != 0 and allowTrendExit
    smartDistance = smartProfitType == 'ATR' ? smartProfitVal * atrVal : smartProfitType == 'Points' ? smartProfitVal : strategyEntryPrice * smartProfitVal / 100.0
    
    // Ensure smartDistance is valid and has minimum value
    if na(smartDistance) or smartDistance <= 0
        smartDistance := 50.0  // Safe default value in points
    
    // NORMAL MODE: Use regular Smart Profit Locker settings
    smartOffset := smartDistance * math.max(smartProfitOffset, 0.01)
    exitComment := 'Smart Profit Locker'
    
    if strategy.position_size > 0  // Long position
        strategy.exit('Smart-Long', from_entry='Long', trail_points=math.max(smartDistance, 0.01), trail_offset=math.max(smartOffset, 0.01), comment=exitComment)
        if not trailExitSent
            trailExitSent := true
    else if strategy.position_size < 0  // Short position
        strategy.exit('Smart-Short', from_entry='Short', trail_points=math.max(smartDistance, 0.01), trail_offset=math.max(smartOffset, 0.01), comment=exitComment)
        if not trailExitSent
            trailExitSent := true





// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND INDICATOR SECTION (DATA INPUT HUB) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Data Input, External Indicators, Plot Connection, Modularity
// This section is the primary data-inlet for the strategy. Instead of performing heavy calculations
// internally, it is designed to connect to the plot outputs of external, standalone indicators.
// This modular design makes the strategy highly flexible and adaptable, allowing users to easily
// swap different trend-following algorithms without altering the core trading logic.
// NOTE: A few specific indicators, like the MA Crossover for exits, remain internally calculated for
// specific functional requirements or legacy compatibility.

// â”€â”€â”€â”€â”€â”€â”€â”€ TREND STRENGTH (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Trend Strength" indicator.
// This indicator typically identifies strong directional moves, and its signals are used as a potential
// entry trigger or as a vote in the directional bias system.
trendStrengthEnable = input.bool(false, 'ðŸ’ª Trend Strength', group='ðŸ“ˆ Trend Indicators', inline='ts1')
trendStrengthLongSrc = input.source(close, 'Long', group='ðŸ“ˆ Trend Indicators', inline='ts1', tooltip='Connect to Trend Strength Long signal plot')
trendStrengthShortSrc = input.source(close, 'Short', group='ðŸ“ˆ Trend Indicators', inline='ts1', tooltip='Connect to Trend Strength Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ HULL SUITE (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Hull Suite" moving average indicator.
// The Hull Moving Average is known for its smoothness and reduced lag. Its bullish/bearish state
// is a primary component of the directional bias system.
hullEnable = input.bool(true, 'ðŸŒŠ Hull Suite', group='ðŸ“ˆ Trend Indicators', inline='hull1')
// hullTrendExit already defined in Directional & Regime Filters section
hullLongSrc = input.source(close, 'Long', group='ðŸ“ˆ Trend Indicators', inline='hull1', tooltip='Connect to Hull Suite Long signal plot')
hullShortSrc = input.source(close, 'Short', group='ðŸ“ˆ Trend Indicators', inline='hull1', tooltip='Connect to Hull Suite Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ SUPERTREND REMOVED â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SuperTrend has been replaced by Adaptive SuperTrend system

// â”€â”€â”€â”€â”€â”€â”€â”€ QUADRANT NW (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Quadrant NW" indicator, which often analyzes price action
// relative to key levels or zones. Its state contributes to the overall directional bias.
quadrantEnable = input.bool(false, 'ðŸ“Š Quadrant NW', group='ðŸ“ˆ Trend Indicators', inline='quad1')
quadrantLongSrc = input.source(close, 'Long', group='ðŸ“ˆ Trend Indicators', inline='quad1', tooltip='Connect to Quadrant NW Long signal plot')
quadrantShortSrc = input.source(close, 'Short', group='ðŸ“ˆ Trend Indicators', inline='quad1', tooltip='Connect to Quadrant NW Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ ADAPTIVE SUPERTREND (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Adaptive SuperTrend" indicator.
// This is a key trend-following component, providing signals for both entries and contributing
// its trend direction to the bias system.
adaptiveSTEnable = input.bool(true, 'ðŸ¤– Adaptive ST', group='ðŸ“ˆ Trend Indicators', inline='ast1')
adaptiveLongSrc = input.source(close, 'Long', group='ðŸ“ˆ Trend Indicators', inline='ast1', tooltip='Connect to Adaptive SuperTrend Long signal plot')
adaptiveShortSrc = input.source(close, 'Short', group='ðŸ“ˆ Trend Indicators', inline='ast1', tooltip='Connect to Adaptive SuperTrend Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ VOLUMATIC VIDYA (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Volumatic VIDYA" (Variable Index Dynamic Average) indicator.
// This is a volume-weighted moving average, providing a trend direction that is sensitive to market participation.
volumaticEnable = input.bool(false, 'ðŸ“Š Volumatic', group='ðŸ“ˆ Trend Indicators', inline='vol1')
volumaticLongSrc = input.source(close, 'Long', group='ðŸ“ˆ Trend Indicators', inline='vol1', tooltip='Connect to Volumatic VIDYA Long signal plot')
volumaticShortSrc = input.source(close, 'Short', group='ðŸ“ˆ Trend Indicators', inline='vol1', tooltip='Connect to Volumatic VIDYA Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ SMOOTH HEIKEN ASHI (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Smooth Heiken Ashi" indicator.
// Heiken Ashi candles are excellent for visualizing trend direction, and their state is used here
// as another vote for the overall directional bias.
smoothHAEnable = input.bool(false, 'ðŸ•¯ï¸ Smooth HA', group='ðŸ“ˆ Trend Indicators', inline='sha1')
smoothHALongSrc = input.source(close, 'Long', group='ðŸ“ˆ Trend Indicators', inline='sha1', tooltip='Connect to Smooth Heiken Ashi Long signal plot')
smoothHAShortSrc = input.source(close, 'Short', group='ðŸ“ˆ Trend Indicators', inline='sha1', tooltip='Connect to Smooth Heiken Ashi Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ STEP CHANNEL (INTERNAL CALCULATION - PROTECTED) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CRITICAL: This calculation must remain internal and unchanged
// Note: Step Channel enable toggle and controls are in Step Channel Scalp Zone section



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DUAL-LAYER MODE SELECTION SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Mode Selection, Regime Filter, Scalp Mode, Trend Mode, Step Channel, CVD
// This is one of the most advanced features of the strategy. It intelligently analyzes market
// structure and institutional flow to automatically switch between a fast, aggressive 'Scalp Mode'
// and a patient, profit-maximizing 'Trend Mode'.
//
// It operates on two layers:
// 1. Step Channel Momentum: A structural filter that identifies the underlying market regime (trending or ranging).
// 2. CVD Channel Breakout: An institutional confirmation filter that looks for significant volume delta
//    to validate the trend, preventing false breakouts.

// â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 1: STEP CHANNEL MOMENTUM SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// These inputs control the sensitivity and visual appearance of the Step Channel, which is the
// primary filter for identifying the market's structural regime (trending vs. ranging).
// Note: stepChannelLength and stepChannelMultiplier already defined in Directional & Regime Filters section

// Duplicate Step Channel inputs removed - already declared above in Dual-Layer Mode Selection section

// â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 2: CUMULATIVE VOLUME DELTA (CVD) FILTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// These inputs configure the institutional confirmation layer. The CVD filter analyzes volume flow
// on a higher timeframe to confirm whether a trend identified by the Step Channel has genuine
// institutional backing.
cvdEnable = input.bool(true, 'ðŸ“ˆ CVD Filter', group='ðŸ“Š Cumulative Volume Delta Filter', tooltip='Enable CVD institutional flow confirmation')
cvdAnchor = input.timeframe('120', 'CVD Anchor', group='ðŸ“Š Cumulative Volume Delta Filter', inline='cvd1', tooltip='120=2h, 240=4h, 1D=1day')
cvdThreshold = input.int(1000, 'CVD Threshold', minval=100, maxval=10000, group='ðŸ“Š Cumulative Volume Delta Filter', inline='cvd1', tooltip='CVD must be outside Â±threshold for trend mode')
cvdUseCustomTimeframe = input.bool(false, 'Custom CVD TF', group='ðŸ“Š Cumulative Volume Delta Filter', inline='cvd2', tooltip='Override automatic timeframe selection')
cvdCustomTimeframe = input.timeframe('1', 'CVD Custom TF', group='ðŸ“Š Cumulative Volume Delta Filter', inline='cvd2', tooltip='Custom timeframe for CVD calculation')

// â”€â”€â”€â”€â”€â”€â”€â”€ MODE SELECTION DEBUG & OVERRIDE SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// These settings provide manual control for testing and debugging the mode-switching logic.
scalpOnlyOverride = input.bool(false, 'Force Scalp Mode', group='ðŸ“Š Cumulative Volume Delta Filter', tooltip='Override all filters and force scalp-only mode for testing')
trendModeDebug = input.bool(false, 'Show Debug Info', group='ðŸ“Š Cumulative Volume Delta Filter', tooltip='Display mode selection debug information')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DUAL-LAYER MODE SELECTION CALCULATIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Calculation, Regime Detection, Step Channel Logic, CVD Logic
// This section contains the core calculation engine for the mode-switching system. It takes the user's
// configuration settings from the previous section and applies them to determine, on a bar-by-bar
// basis, whether the strategy should be in 'Scalp Mode' or 'Trend Mode'.

// â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 1: STEP CHANNEL MOMENTUM CALCULATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This block is a full, self-contained implementation of the ChartPrime Step Channel Momentum indicator.
// It analyzes price action to determine if the market is in an uptrend, downtrend, or range.

// --- State Management Variables ---
// `var` is used to ensure these variables maintain their values across bar calculations.
var string stepChannelState = "Range"       // Holds the current market state text (e.g., "Momentum Up").
var bool stepChannelTrendMode = false   // The final output: `true` if an uptrend is detected.
var float stepChannelPivotHigh = na      // Stores the most recent significant high pivot.
var float stepChannelPivotLow = na       // Stores the most recent significant low pivot.
var color stepChannelCurrentColor = color.orange // Stores the color for the visual elements.

// --- Channel Calculation Variables ---
var float stepChannelAvg = na            // The midpoint of the channel.
// stepChannelUpper and stepChannelLower already declared in Directional & Regime Filters section
var float stepChannelATR = na            // The calculated ATR value used for channel width.

if stepChannelEnable
    // --- Step 1: Identify Significant Pivots ---
    // `ta.pivothigh` and `ta.pivotlow` are used to find recent swing points in the price.
    ph = ta.pivothigh(stepChannelLength, stepChannelLength)
    pl = ta.pivotlow(stepChannelLength, stepChannelLength)
    
    // When a new pivot is found, its value is stored in the corresponding `var` variable.
    if not na(ph)
        stepChannelPivotHigh := ph
        if stepChannelShowPivots and stepChannelShowVisuals
            label.new(bar_index-stepChannelLength, ph, "â¬¥", style=label.style_label_center, textcolor=chart.fg_color, size=size.normal, color=color(na))
    if not na(pl)
        stepChannelPivotLow := pl
        if stepChannelShowPivots and stepChannelShowVisuals
            label.new(bar_index-stepChannelLength, pl, "â¬¥", style=label.style_label_center, textcolor=chart.fg_color, size=size.normal, color=color(na))
    
    // --- Step 2: Calculate Channel Boundaries ---
    // The channel width is based on a 200-period ATR, adjusted by a user-defined multiplier.
    stepChannelATR := ta.atr(200) * stepChannelMultiplier
    
    // This handles the script's initialization phase. Before both a high and low pivot are found,
    // it uses a temporary channel centered on the current price.
    if na(stepChannelPivotHigh) or na(stepChannelPivotLow)
        stepChannelAvg := hl2
        stepChannelUpper := stepChannelAvg + stepChannelATR
        stepChannelLower := stepChannelAvg - stepChannelATR
    else
        // Once pivots are established, the channel is centered between them.
        stepChannelAvg := math.avg(stepChannelPivotHigh, stepChannelPivotLow)
        stepChannelUpper := stepChannelAvg + stepChannelATR
        stepChannelLower := stepChannelAvg - stepChannelATR
    
    // --- Step 3: Determine Final Market State ---
    // The current price (`hl2`) is compared to the channel boundaries to set the final state.
    if hl2 > stepChannelUpper
        stepChannelCurrentColor := stepChannelColorUp
        stepChannelTrendMode := true // An uptrend is detected; allow trend-following.
        stepChannelState := "Momentum Up"
    else if hl2 < stepChannelLower
        stepChannelCurrentColor := stepChannelColorDown
        stepChannelTrendMode := false // A downtrend is detected; this system considers it non-trending for longs.
        stepChannelState := "Momentum Down"
    else // Price is inside the channel.
        stepChannelCurrentColor := stepChannelColorRange
        stepChannelTrendMode := false // The market is ranging; do not allow trend-following.
        stepChannelState := "Range"
    
    // Note: The actual plotting of visual elements is handled in the global scope to prevent script errors.
else
    // If the Step Channel filter is disabled, it defaults to a non-blocking state.
    stepChannelState := "Disabled"
    stepChannelTrendMode := true  // This effectively bypasses the filter, allowing Trend Mode.

// â”€â”€â”€â”€â”€â”€â”€â”€ LAYER 2: CVD CHANNEL BREAKOUT CALCULATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This block calculates the Cumulative Volume Delta (CVD) on a higher timeframe to act as an
// institutional confirmation filter for trend mode.

// --- State Management Variables ---
var bool cvdTrendMode = false   // The final output: `true` if institutional flow confirms a trend.
var float cvdValue = na         // Stores the calculated CVD value for potential display or debugging.

if cvdEnable
    // --- Step 1: Select CVD Timeframe ---
    // This logic selects a suitable timeframe for the CVD calculation if the user hasn't specified a custom one.
    cvdTimeframe = cvdUseCustomTimeframe ? cvdCustomTimeframe : 
                   timeframe.isseconds ? "1S" :
                   timeframe.isintraday ? "1" :
                   timeframe.isdaily ? "5" : "60"
    
    // --- Step 2: Calculate Non-Repainting CVD ---
    // This is a carefully constructed, non-repainting data request.
    // `ta.cum(...)` calculates the cumulative sum of volume, signed by the candle's direction (buy or sell volume).
    // `[1]` ensures we use the value from the *previous completed* bar, preventing look-ahead bias.
    // `request.security(...)` fetches this cumulative value from the higher `cvdAnchor` timeframe.
    // `lookahead=barmerge.lookahead_on` correctly aligns historical data without repainting.
    cvdExpression = ta.cum(volume * (close > open ? 1 : close < open ? -1 : 0))[1]
    cvdData = request.security(syminfo.tickerid, cvdAnchor, cvdExpression, lookahead=barmerge.lookahead_on)
    cvdValue := cvdData
    
    // --- Step 3: Determine Trend Confirmation ---
    // If the absolute CVD value exceeds the user-defined threshold, it signifies strong institutional
    // participation, and trend mode is confirmed.
    cvdTrendMode := math.abs(cvdValue) > cvdThreshold
else
    // If the CVD filter is disabled, it defaults to a non-blocking state.
    cvdTrendMode := true  // This effectively bypasses the filter, allowing Trend Mode.
    cvdValue := 0

// â”€â”€â”€â”€â”€â”€â”€â”€ DUAL-LAYER MODE SELECTION LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This is the final decision-making block. It combines the results from the Step Channel (Layer 1)
// and the CVD filter (Layer 2) to set the strategy's operational mode.

// --- State Management Variables ---
var bool scalpOnlyMode = true             // `true` if the strategy should use fast, scalping exits.
var bool trendFollowingMode = false       // `true` if the strategy should use trend-following logic.
var string currentTradingMode = "SCALP"   // A text label for the current mode, used in visuals and debug logs.

// --- Manual Override for Testing ---
// Allows the user to force the strategy into Scalp Mode, bypassing the filter logic.
if scalpOnlyOverride
    scalpOnlyMode := true
    trendFollowingMode := false
    currentTradingMode := "SCALP (FORCED)"
else
    // --- Confluence Logic for Trend Mode ---
    // Trend Mode is only activated if ALL enabled filters agree.
    // If a filter is disabled, it defaults to `true`, effectively giving its permission for Trend Mode.
    stepChannelAllows = stepChannelEnable ? stepChannelTrendMode : true
    cvdAllows = cvdEnable ? cvdTrendMode : true
    
    // Both must be `true` for trend following to be active.
    trendFollowingMode := stepChannelAllows and cvdAllows
    
    // --- Set Final Mode ---
    // Scalp mode is simply the inverse of trend mode.
    scalpOnlyMode := not trendFollowingMode
    currentTradingMode := trendFollowingMode ? "TREND" : "SCALP"

// --- Update Global Scalp Mode Variable ---
scalpModeActive := scalpOnlyMode

// â”€â”€â”€â”€â”€â”€â”€â”€ MODE SELECTION DEBUG AND VISUALIZATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This section handles the optional visual elements for the mode selection system, providing real-time
// feedback directly on the chart.

// --- On-Chart Debug Table ---
// If enabled, this table provides a detailed, real-time breakdown of the mode selection logic.
// `barstate.islast` ensures the table is only drawn and updated on the most recent bar to save resources.
if trendModeDebug and barstate.islast
    // `var` ensures the table is created only once and then updated, preventing re-drawing on every tick.
    var table debugTable = table.new(position.top_left, 3, 6, bgcolor=color.new(color.white, 80), border_width=1)
    
    // Header Row
    table.cell(debugTable, 0, 0, "Mode Selection Debug", text_color=color.black, text_size=size.normal, bgcolor=color.new(color.blue, 70))
    table.cell(debugTable, 1, 0, "", bgcolor=color.new(color.blue, 70))
    table.cell(debugTable, 2, 0, "", bgcolor=color.new(color.blue, 70))
    
    // Step Channel Status
    table.cell(debugTable, 0, 1, "Step Channel:", text_color=color.black, text_size=size.small)
    table.cell(debugTable, 1, 1, stepChannelState, text_color=color.black, text_size=size.small)
    table.cell(debugTable, 2, 1, stepChannelTrendMode ? "âœ“" : "âœ—", text_color=stepChannelTrendMode ? color.green : color.red, text_size=size.small)
    
    // CVD Status
    table.cell(debugTable, 0, 2, "CVD Value:", text_color=color.black, text_size=size.small)
    table.cell(debugTable, 1, 2, str.tostring(math.round(cvdValue)), text_color=color.black, text_size=size.small)
    table.cell(debugTable, 2, 2, cvdTrendMode ? "âœ“" : "âœ—", text_color=cvdTrendMode ? color.green : color.red, text_size=size.small)
    
    // CVD Threshold Info
    table.cell(debugTable, 0, 3, "CVD Threshold:", text_color=color.black, text_size=size.small)
    table.cell(debugTable, 1, 3, "Â±" + str.tostring(cvdThreshold), text_color=color.black, text_size=size.small)
    table.cell(debugTable, 2, 3, "", text_color=color.black, text_size=size.small)
    
    // Filter Combination Logic
    table.cell(debugTable, 0, 4, "Filter Logic:", text_color=color.black, text_size=size.small)
    filterLogicText = "Independent (" + (stepChannelEnable ? "SC" : "") + (stepChannelEnable and cvdEnable ? "+" : "") + (cvdEnable ? "CVD" : "") + ")"
    table.cell(debugTable, 1, 4, filterLogicText, text_color=color.black, text_size=size.small)
    table.cell(debugTable, 2, 4, "", text_color=color.black, text_size=size.small)
    
    // Final Trading Mode Result
    table.cell(debugTable, 0, 5, "Trading Mode:", text_color=color.black, text_size=size.small)
    modeColor = trendFollowingMode ? color.new(color.orange, 50) : color.new(color.blue, 50)
    table.cell(debugTable, 1, 5, currentTradingMode, text_color=color.white, text_size=size.small, bgcolor=modeColor)
    table.cell(debugTable, 2, 5, "", text_color=color.black, text_size=size.small)

// --- On-Chart Mode Label ---
// Displays a simple label on the chart showing the current trading mode.
if stepChannelShowLabel and barstate.islast
    label.new(bar_index, high, currentTradingMode, 
              color=trendFollowingMode ? color.new(color.orange, 0) : color.new(color.blue, 0), 
              textcolor=color.white, 
              style=label.style_label_down, 
              size=size.normal,
              tooltip="Current Trading Mode\nStep Channel: " + stepChannelState + "\nCVD: " + str.tostring(math.round(cvdValue)))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HULL SUITE (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Hull Suite trend detection via external plot points - internal calculation removed

var bool hullBullish = false

if hullEnable
    // Use external plot point signals instead of internal calculation
    hullLongSignal = hullLongSrc != hullLongSrc[1] and hullLongSrc > 0
    hullShortSignal = hullShortSrc != hullShortSrc[1] and hullShortSrc > 0
    
    // Determine trend direction from external signals
    if hullLongSignal
        hullBullish := true
    else if hullShortSignal
        hullBullish := false
    // Otherwise maintain previous state
else
    // When disabled, set neutral (allow all trades)
    hullBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SUPERTREND REMOVED â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SuperTrend has been completely replaced by Adaptive SuperTrend system

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• QUADRANT NW (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Quadrant NW trend detection via external plot points - internal calculation removed

// quadrantBullish already declared earlier

if quadrantEnable
    // Use external plot point signals instead of internal calculation
    quadrantLongSignal = quadrantLongSrc != quadrantLongSrc[1] and quadrantLongSrc > 0
    quadrantShortSignal = quadrantShortSrc != quadrantShortSrc[1] and quadrantShortSrc > 0
    
    // Determine trend direction from external signals
    if quadrantLongSignal
        quadrantBullish := true
    else if quadrantShortSignal
        quadrantBullish := false
    // Otherwise maintain previous state
else
    // When disabled, set neutral (allow all trades)
    quadrantBullish := false



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADAPTIVE SUPERTREND (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Adaptive SuperTrend trend detection via external plot points - internal calculation removed

// Preserve existing interface variables for backward compatibility
var bool adaptiveSTBullish = false
var int adaptiveCluster = na
var int adaptiveNumber = na

if adaptiveSTEnable
    // Use external plot point signals for trend direction
    adaptiveLongSignal = adaptiveLongSrc != adaptiveLongSrc[1] and adaptiveLongSrc > 0
    adaptiveShortSignal = adaptiveShortSrc != adaptiveShortSrc[1] and adaptiveShortSrc > 0
    
    // Get volatility regime number from external plot (for exit filter compatibility)
    adaptiveNumber := math.round(adaptiveRegimeInput)  // Get regime number (1, 2, or 3)
    // Validate the regime number is within expected range
    if not na(adaptiveNumber) and adaptiveNumber >= 1 and adaptiveNumber <= 3
        adaptiveCluster := adaptiveNumber == 3 ? 0 : (adaptiveNumber == 2 ? 1 : 2)  // Convert to cluster index
    else
        // Fallback to medium volatility if invalid input
        adaptiveNumber := 2
        adaptiveCluster := 1
    
    // Determine trend direction from external signals
    if adaptiveLongSignal
        adaptiveSTBullish := true
    else if adaptiveShortSignal
        adaptiveSTBullish := false
    // Otherwise maintain previous state

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADAPTIVE SUPERTREND EXIT FILTER SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Revolutionary exit filter using volatility classification numbers (1/2/3)
// Blocks scalp exits during specific volatility regimes for better trend riding

if adaptiveExitFilterEnable and adaptiveSTEnable
    // Determine if current volatility number should block exits
    currentlyBlocked = (adaptiveNumber == 3 and adaptiveHoldOn3) or 
                      (adaptiveNumber == 2 and adaptiveHoldOn2) or 
                      (adaptiveNumber == 1 and adaptiveHoldOn1)
    
    // Update exit blocking status
    adaptiveExitBlocked := currentlyBlocked
    
    // Handle pending exit logic
    if adaptiveExitBlocked and not adaptiveExitBlocked[1]
        // Just entered blocked state - no action needed, just block new exits
        adaptivePendingExit := false
        adaptiveExitReason := na
    
    if not adaptiveExitBlocked and adaptiveExitBlocked[1]
        // Just exited blocked state - trigger any pending exits immediately
        if adaptivePendingExit
            // Exit will be triggered by normal exit logic since block is now lifted
            adaptivePendingExit := false
else
    // When filter is disabled, never block exits
    adaptiveExitBlocked := false
    adaptivePendingExit := false
    adaptiveExitReason := na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• VOLUMATIC VIDYA (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Volumatic VIDYA trend detection via external plot points - internal calculation removed

var bool volumaticBullish = false

if volumaticEnable
    // Use external plot point signals instead of internal calculation
    volumaticLongSignal = volumaticLongSrc != volumaticLongSrc[1] and volumaticLongSrc > 0
    volumaticShortSignal = volumaticShortSrc != volumaticShortSrc[1] and volumaticShortSrc > 0
    
    // Determine trend direction from external signals
    if volumaticLongSignal
        volumaticBullish := true
    else if volumaticShortSignal
        volumaticBullish := false
    // Otherwise maintain previous state
else
    volumaticBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SMOOTHED HEIKEN ASHI (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Smoothed Heiken Ashi trend detection via external plot points - internal calculation removed

var bool smoothHABullish = false

if smoothHAEnable
    // Use external plot point signals instead of internal calculation
    smoothHALongSignal = smoothHALongSrc != smoothHALongSrc[1] and smoothHALongSrc > 0
    smoothHAShortSignal = smoothHAShortSrc != smoothHAShortSrc[1] and smoothHAShortSrc > 0
    
    // Determine trend direction from external signals
    if smoothHALongSignal
        smoothHABullish := true
    else if smoothHAShortSignal
        smoothHABullish := false
    // Otherwise maintain previous state
else
    smoothHABullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DIRECTIONAL BIAS INTEGRATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Directional Bias, Trend Filter, Confluence, Signal Filtering
// This section translates the boolean state of each individual trend filter (e.g., `hullBullish`)
// into a standardized bias vote. If a filter is disabled, it defaults to `true`, effectively
// creating a bypass so it doesn't block trades. This prepares the votes for the final confluence logic.

// --- Individual Filter Bias Logic --- 
// Each filter's contribution to the overall directional bias is determined here.

// RBW filter was removed from the system; its bias is hardcoded to 'true' to have no effect.
rbwLongBias = true
rbwShortBias = true

// Hull Suite: If enabled, bias is determined by the `hullBullish` state. If disabled, it defaults to `true` (pass-through).
hullLongBias = hullEnable ? hullBullish : true
hullShortBias = hullEnable ? (not hullBullish) : true

// Quadrant NW: If enabled, bias is determined by the `quadrantBullish` state. If disabled, it defaults to `true`.
quadrantLongBias = quadrantEnable ? quadrantBullish : true
quadrantShortBias = quadrantEnable ? (not quadrantBullish) : true

// Adaptive SuperTrend: If enabled, bias is determined by the `adaptiveSTBullish` state. If disabled, it defaults to `true`.
adaptiveSTLongBias = adaptiveSTEnable ? adaptiveSTBullish : true
adaptiveSTShortBias = adaptiveSTEnable ? (not adaptiveSTBullish) : true

// Volumatic VIDYA: If enabled, bias is determined by the `volumaticBullish` state. If disabled, it defaults to `true`.
volumaticLongBias = volumaticEnable ? volumaticBullish : true
volumaticShortBias = volumaticEnable ? (not volumaticBullish) : true

// Smooth Heiken Ashi: If enabled, bias is determined by the `smoothHABullish` state. If disabled, it defaults to `true`.
smoothHALongBias = smoothHAEnable ? smoothHABullish : true
smoothHAShortBias = smoothHAEnable ? (not smoothHABullish) : true

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND-EXIT/HOLD FILTER CALCULATIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Visually clear, mechanically simple filters to hold trades longer during obvious trends

// 1. ADAPTIVE SUPERTREND VOLATILITY FILTER
// KEYWORDS: Exit Filter, Trend Hold, Volatility, Adaptive SuperTrend
// This filter uses the volatility classification (1-Low, 2-Medium, 3-High) from the advanced
// Adaptive SuperTrend indicator to decide whether to hold a trade through minor pullbacks.
// By holding during specific volatility conditions, it aims to capture more of the primary trend.

// --- Step 1: Extract Volatility Number ---
// The raw volatility cluster (0, 1, or 2) from the external indicator is converted into a more intuitive number (3, 2, or 1).
var int adaptiveSTNumber = na
if adaptiveSTEnable
    // The formula `4 - (adaptiveCluster + 1)` maps the internal cluster index (0, 1, 2) to the user-facing volatility number (3, 2, 1).
    adaptiveSTNumber := not na(adaptiveCluster) ? (4 - (adaptiveCluster + 1)) : na
else
    // If the main indicator is disabled, the volatility number is not applicable.
    adaptiveSTNumber := na

// --- Step 2: Generate Hold Signal ---
// A 'hold' signal is generated if the user has opted to hold trades during the current volatility regime.
var bool adaptiveSTHoldSignal = false
if adaptiveExitFilterEnable and not na(adaptiveSTNumber)
    // The hold signal becomes active if the corresponding toggle (e.g., `adaptiveHoldOn3`) is enabled for the current volatility number.
    adaptiveSTHoldSignal := (adaptiveHoldOn3 and adaptiveSTNumber == 3) or 
                           (adaptiveHoldOn2 and adaptiveSTNumber == 2) or 
                           (adaptiveHoldOn1 and adaptiveSTNumber == 1)
else
    // If the exit filter is disabled or the volatility number is invalid, no hold signal is generated.
    adaptiveSTHoldSignal := false

// 2. MOVING AVERAGE CROSSOVER FILTER
// KEYWORDS: Exit Filter, Trend Hold, MA Cross, SMA, EMA, WMA
// This filter uses a classic moving average crossover strategy to identify the prevailing trend direction.
// When in a trade, it generates a 'hold' signal if the MAs indicate the trend is still intact,
// preventing premature exits and allowing the trade to ride the trend for longer.

// --- Step 1: Calculate Moving Averages ---
// Extract all ta.* functions for Pine Script v6 consistency
fastSMA = ta.sma(close, maCrossoverFastLength)
fastEMA = ta.ema(close, maCrossoverFastLength)
fastWMA = ta.wma(close, maCrossoverFastLength)
slowSMA = ta.sma(close, maCrossoverSlowLength)
slowEMA = ta.ema(close, maCrossoverSlowLength)
slowWMA = ta.wma(close, maCrossoverSlowLength)

// These variables store the calculated MA values and the final hold signal.
var float maCrossoverFast = na
var float maCrossoverSlow = na
var bool maCrossoverHoldSignal = false

if maCrossoverFilterEnable
    // This block calculates the fast and slow MAs based on the user-selected type (SMA, EMA, or WMA) and length.
    maCrossoverFast := maCrossoverType == 'SMA' ? fastSMA :
                       maCrossoverType == 'EMA' ? fastEMA :
                       fastWMA
    
    // Calculate the slow MA using the same type and length as the fast MA.
    maCrossoverSlow := maCrossoverType == 'SMA' ? slowSMA :
                       maCrossoverType == 'EMA' ? slowEMA :
                       slowWMA
    
    // --- Step 2: Generate Hold Signal based on Position ---
    // The hold logic is context-aware, generating a signal only if the MAs confirm the direction of the current trade.
    if strategy.position_size > 0  // In a long position
        // For a long trade, a hold signal is generated if the fast MA is above the slow MA (a "golden cross" condition).
        maCrossoverHoldSignal := maCrossoverFast > maCrossoverSlow
    else if strategy.position_size < 0  // In a short position
        // For a short trade, a hold signal is generated if the fast MA is below the slow MA (a "death cross" condition), confirming bearish momentum.
        maCrossoverHoldSignal := maCrossoverFast < maCrossoverSlow
    else
        // If there is no open position, a hold signal is irrelevant and is set to false.
        maCrossoverHoldSignal := false
else
    // If the filter is disabled entirely, it can never generate a hold signal.
    maCrossoverHoldSignal := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 3. INDIVIDUAL INDICATOR EXIT SIGNAL GENERATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Trend Exit, Indicator Flip, Reversal Signal, Dynamic Exit
//
// PURPOSE:
// This system serves as a core component of the dynamic, trend-following exit architecture.
// Its primary function is to generate an explicit exit signal as soon as any of the selected
// primary trend-following indicators (e.g., Hull Suite, Adaptive SuperTrend, Quadrant NW) signal a
// reversal against the current trade's direction.
//
// MECHANISM:
// The system independently evaluates each enabled trend indicator on every bar. For each one, it
// checks if its directional state (e.g., 'bullish' or 'bearish') is in conflict with the
// strategy's current open position (long or short).
//
// LOGIC:
// - If in a LONG position, an exit signal is generated if the indicator's state is BEARISH.
// - If in a SHORT position, an exit signal is generated if the indicator's state is BULLISH.
//
// INTEGRATION:
// The boolean exit signals generated here (`hullExitSignal`, `adaptiveExitSignal`, etc.) are not
// acted upon directly. Instead, they are collected and passed to the 'COMBINE ALL TREND-EXIT/HOLD FILTERS'
// section, where a final confluence logic decides whether to trigger a strategy exit based on
// user-defined rules (e.g., 'Any Filter Triggers' vs. 'All Filters Must Agree'). This layered
// approach provides a robust and highly configurable trend-based exit.

// Initialize boolean flags for each potential exit signal.
var bool hullExitSignal = false
var bool quadrantExitSignal = false
var bool adaptiveExitSignal = false
var bool volumaticExitSignal = false
var bool smoothHAExitSignal = false

// For each indicator, the logic is the same:
// If in a LONG position, trigger an exit if the indicator turns BEARISH.
// If in a SHORT position, trigger an exit if the indicator turns BULLISH.

// --- Hull Suite Exit Signal ---
// This logic checks if the Hull Suite indicator has flipped against the current trade direction.
if hullTrendExit and hullEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Hull trend is no longer bullish, set the exit signal to true.
        hullExitSignal := not hullBullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Hull trend has turned bullish, set the exit signal to true.
        hullExitSignal := hullBullish
    else
        // No position, so no exit signal.
        hullExitSignal := false
else
    // If the Hull exit is disabled, the signal is always false.
    hullExitSignal := false

// --- Quadrant NW Exit Signal ---
// This logic checks if the Quadrant NW indicator has flipped against the current trade direction.
if quadrantTrendExit and quadrantEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Quadrant trend is no longer bullish, set the exit signal to true.
        quadrantExitSignal := not quadrantBullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Quadrant trend has turned bullish, set the exit signal to true.
        quadrantExitSignal := quadrantBullish
    else
        // No position, so no exit signal.
        quadrantExitSignal := false
else
    // If the Quadrant exit is disabled, the signal is always false.
    quadrantExitSignal := false

// --- Adaptive SuperTrend Exit Signal ---
// This logic checks if the Adaptive SuperTrend indicator has flipped against the current trade direction.
if adaptiveTrendExit and adaptiveSTEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Adaptive SuperTrend is no longer bullish, set the exit signal to true.
        adaptiveExitSignal := not adaptiveSTBullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Adaptive SuperTrend has turned bullish, set the exit signal to true.
        adaptiveExitSignal := adaptiveSTBullish
    else
        // No position, so no exit signal.
        adaptiveExitSignal := false
else
    // If the Adaptive SuperTrend exit is disabled, the signal is always false.
    adaptiveExitSignal := false

// --- Volumatic VIDYA Exit Signal ---
// This logic checks if the Volumatic VIDYA indicator has flipped against the current trade direction.
if volumaticTrendExit and volumaticEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Volumatic trend is no longer bullish, set the exit signal to true.
        volumaticExitSignal := not volumaticBullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Volumatic trend has turned bullish, set the exit signal to true.
        volumaticExitSignal := volumaticBullish
    else
        // No position, so no exit signal.
        volumaticExitSignal := false
else
    // If the Volumatic exit is disabled, the signal is always false.
    volumaticExitSignal := false

// --- Smooth Heiken Ashi Exit Signal ---
// This logic checks if the Smoothed Heiken Ashi indicator has flipped against the current trade direction.
if smoothHATrendExit and smoothHAEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Heiken Ashi trend is no longer bullish, set the exit signal to true.
        smoothHAExitSignal := not smoothHABullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Heiken Ashi trend has turned bullish, set the exit signal to true.
        smoothHAExitSignal := smoothHABullish
    else
        // No position, so no exit signal.
        smoothHAExitSignal := false
else
    // If the Heiken Ashi exit is disabled, the signal is always false.
    smoothHAExitSignal := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 4. EXTERNAL TREND EXIT SIGNAL (GENERIC) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Custom Exit, External Signal, Universal Trigger, Plot-Based Exit
//
// PURPOSE:
// This sub-system provides a powerful and generic exit mechanism that can be connected to virtually
// any external indicator. It is designed to capture discrete, event-based signals, such as when
// an indicator plots an exit arrow, a dot, or any other shape on the chart.
//
// MECHANISM:
// The logic does not care about the specific value of the connected source (`trendExitSignalSrc`).
// Instead, it triggers an exit signal (`externalTrendExitSignal`) only when the value of the source
// changes from one bar to the next (`source != source[1]`). This is a highly effective way to
// detect a one-time event without needing to know the plot's specific value.
//
// USE CASE:
// Connect this to an indicator that plots a shape or value (e.g., `plotshape`) to signal an exit.
// When the shape appears, the underlying plot value changes, which this system detects and converts
// into a valid exit signal for the strategy.
//
// INTEGRATION:
// Just like the other individual indicator exits, this signal is passed to the final confluence
// logic block to be evaluated according to the user's selected trend exit rules.
var bool externalTrendExitSignal = false
if trendExitSignalEnable
    // The exit signal is triggered if the current value of the source is different from its previous value.
    // This is a robust way to capture a discrete event on the chart.
    externalTrendExitSignal := trendExitSignalSrc != trendExitSignalSrc[1]
else
    // If the external exit signal is disabled, it is always false.
    externalTrendExitSignal := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 5. COMBINE ALL TREND-EXIT/HOLD FILTERS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Confluence Logic, Final Exit Decision, Trend Hold, Master Gate
//
// PURPOSE:
// This is the final and most critical stage of the trend-following exit system. It acts as the
// central decision-making hub, synthesizing all the individual 'hold' and 'exit' signals from the
// previous sections into a single, actionable outcome.
//
// MECHANISM:
// The logic follows a clear, three-step process:
// 1. Combine all 'hold' signals into one master `trendHoldActive` flag.
// 2. Tally all individual 'exit' signals and apply the user's confluence rule to produce a final `trendExitTriggered` flag.
// 3. Integrate the `scalpOnlyMode` and the final hold/exit flags to produce the master `allowTrendExit` boolean.
//
// OUTPUT & INTEGRATION:
// The final output, `allowTrendExit`, is a master gate that controls other, non-trend-based exit systems
// (like the Smart Profit Locker and Fixed SL/TP). 
// - If `allowTrendExit` is TRUE: Standard profit-taking and stop-loss exits are permitted.
// - If `allowTrendExit` is FALSE: A 'hold' condition is active. Standard exits are BLOCKED, forcing the
//   strategy to hold the position to ride the underlying trend for maximum profit potential. This is the
//   core of the trend-riding functionality.

// Initialize variables for the combined hold and exit signals.
var bool trendHoldActive = false
var bool trendExitTriggered = false

// --- Step 1: Combine All 'Hold' Signals ---
// The master 'hold' signal becomes active if ANY of the enabled hold-focused filters (Adaptive ST or MA Cross) are currently signaling a hold.
// The purpose of this signal is to temporarily block standard profit-taking exits, allowing the trade to ride the underlying trend.
trendHoldActive := adaptiveSTHoldSignal or maCrossoverHoldSignal

// --- Step 2: Tally and Evaluate All 'Exit' Signals ---
// All individual trend reversal signals are summed up to get a total count of indicators suggesting an exit.
individualExitCount = (hullExitSignal ? 1 : 0) + (quadrantExitSignal ? 1 : 0) + (adaptiveExitSignal ? 1 : 0) + (volumaticExitSignal ? 1 : 0) + (smoothHAExitSignal ? 1 : 0) + (externalTrendExitSignal ? 1 : 0)

// The final exit trigger is determined by the user-selected confluence logic.
if trendExitLogic == 'Any Filter Triggers Exit'
    // In 'Any' mode, an exit is triggered if at least one of the enabled indicators signals a trend reversal.
    trendExitTriggered := individualExitCount > 0
else  // 'All Filters Must Agree' mode
    // In 'All' mode, we first count how many exit indicator systems are currently enabled by the user.
    enabledExitFilters = (hullTrendExit ? 1 : 0) + (quadrantTrendExit ? 1 : 0) + (adaptiveTrendExit ? 1 : 0) + (volumaticTrendExit ? 1 : 0) + (smoothHATrendExit ? 1 : 0) + (trendExitSignalEnable ? 1 : 0)
    // An exit is triggered only if the number of indicators signaling an exit is equal to the total number of enabled exit indicators (and at least one is enabled).
    trendExitTriggered := enabledExitFilters > 0 and individualExitCount >= enabledExitFilters

// --- Step 3: Final Decision with Mode Integration ---
// This is the master switch for the entire Trend-Exit/Hold system, integrating the `scalpOnlyMode`.

if scalpOnlyMode
    // --- SCALP MODE OVERRIDE ---
    // In Scalp Only mode, all trend-hold logic is bypassed by forcing `allowTrendExit` to true.
    // This ensures that standard profit-taking and stop-loss exits are never blocked by this system.
    allowTrendExit := true
else
    // --- TREND MODE LOGIC ---
    // In Trend Mode, the system's full logic is applied.
    // An exit is permitted if EITHER of these conditions is met:
    // 1. No hold/exit filters are enabled at all (system is effectively off).
    // 2. A trend exit has been triggered (`trendExitTriggered`) AND is NOT being actively blocked by a hold signal (`trendHoldActive`).
    anyFiltersEnabled = adaptiveExitFilterEnable or maCrossoverFilterEnable or hullTrendExit or quadrantTrendExit or adaptiveTrendExit or volumaticTrendExit or smoothHATrendExit or trendExitSignalEnable
    allowTrendExit := not trendHoldActive and (not anyFiltersEnabled or trendExitTriggered)

// Confluence Logic Implementation - FIXED WEIGHTED VOTING BUG
// CRITICAL FIX: Use consistent decimal weighting instead of math.round() to prevent unbalanced voting
// This fixes the bug where math.round() created inconsistent filter weights

// NOTE: enabledFilters, bullishVotes, and bearishVotes are already calculated above (lines 1542-1548)
// Removing duplicate definitions to fix compilation error

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DIRECTIONAL BIAS CALCULATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Directional Bias, Confluence, Voting System, Trade Filter
// This is the core logic where all individual trend filter votes are combined to produce a
// final directional bias. This bias acts as the master gatekeeper, determining whether long or
// short trades are permitted based on the user-defined confluence rules.

// --- Step 1: Initialize Bias & Tally Votes ---
// The bias is assumed true (trades allowed) until proven otherwise. The system then counts how many filters are
// enabled and tallies the number of bullish vs. bearish votes from those active filters.
var bool longDirectionalBias = true
var bool shortDirectionalBias = true

// This calculation sums up all filters that are switched on, providing the denominator for 'All' or 'Majority' confluence logic.
enabledFilters = (hullEnable ? 1.0 : 0.0) + (quadrantEnable ? 1.0 : 0.0) + (adaptiveSTEnable ? 1.0 : 0.0) + (volumaticEnable ? 1.0 : 0.0) + (smoothHAEnable ? 1.0 : 0.0)

// This sums up the votes for a long trade. A vote is only counted if the filter is both enabled AND its state is currently bullish.
bullishVotes = (hullEnable and hullBullish ? 1.0 : 0.0) + (quadrantEnable and quadrantBullish ? 1.0 : 0.0) + (adaptiveSTEnable and adaptiveSTBullish ? 1.0 : 0.0) + (volumaticEnable and volumaticBullish ? 1.0 : 0.0) + (smoothHAEnable and smoothHABullish ? 1.0 : 0.0)

// This sums up the votes for a short trade. A vote is counted if the filter is enabled AND its state is currently bearish (i.e., not bullish).
bearishVotes = (hullEnable and not hullBullish ? 1.0 : 0.0) + (quadrantEnable and not quadrantBullish ? 1.0 : 0.0) + (adaptiveSTEnable and not adaptiveSTBullish ? 1.0 : 0.0) + (volumaticEnable and not volumaticBullish ? 1.0 : 0.0) + (smoothHAEnable and not smoothHABullish ? 1.0 : 0.0)

// --- Step 2: Apply Confluence Logic ---
// This block translates the raw vote counts into the final boolean bias signals based on the user's selected confluence rule.
// If no filters are enabled, the bias is permissive (true) by default.
longDirectionalBias := enabledFilters == 0 ? true : 
     (biasConfluence == 'Any' and bullishVotes > 0) or                      // 'Any': At least one bullish vote is required.
     (biasConfluence == 'Majority' and bullishVotes > bearishVotes) or          // 'Majority': Bullish votes must outnumber bearish votes.
     (biasConfluence == 'All' and bearishVotes == 0)                          // 'All': No bearish votes are allowed among enabled filters.

shortDirectionalBias := enabledFilters == 0 ? true : 
     (biasConfluence == 'Any' and bearishVotes > 0) or                      // 'Any': At least one bearish vote is required.
     (biasConfluence == 'Majority' and bearishVotes > bullishVotes) or          // 'Majority': Bearish votes must outnumber bullish votes.
     (biasConfluence == 'All' and bullishVotes == 0)                          // 'All': No bullish votes are allowed among enabled filters.



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND-EXIT/HOLD FILTER CALCULATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOTE: allowTrendExit calculation is now handled by the dual-layer mode selection system
// This duplicate calculation block has been removed to fix compilation errors

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LEGACY TREND-RIDING SYSTEM REMOVED â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// All legacy trend-riding activation/deactivation logic has been completely removed

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENTRY SIGNAL FINALIZATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// KEYWORDS: Final Signal, Entry Trigger, Gatekeeper
// This is the final gatekeeper for all trade entries. The aggregated signal (`primaryLongSig`)
// is combined with the final directional bias. A long trade is only initiated if a primary signal exists
// AND the directional bias filter allows long entries.
longEntrySignal := primaryLongSig and longDirectionalBias 

// Similarly, a short trade is only initiated if a primary short signal exists AND the directional bias
// filter currently permits short entries.
shortEntrySignal := primaryShortSig and shortDirectionalBias

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ACTUAL STRATEGY ENTRY EXECUTION (CRITICAL FIX) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Strategy Entry, Execute Trade, `strategy.entry`, Dynamic Labels
// This section contains the commands that execute trades. After all signals are processed and filters
// are passed, the `strategy.entry()` function is called here to place a long or short order.

// --- Long Entry Execution ---
// This block executes a long trade if the final `longEntrySignal` is true.
if longEntrySignal
    // If enabled, this builds and displays a dynamic label on the chart indicating which entry signal(s) fired.
    if displayEntryLabels
        string longLabelText = buildSignalName(true)
        if longLabelText != ""
            label lbl = getPooledLabel(true) // Uses a label pooling system for better performance.
            updateLabel(lbl, bar_index, low - atrVal * 0.2, longLabelText, labelColorLong)
    
    // A dynamic comment is created for the trade log, indicating a confluence 'C' count if multiple signals fired.
    entryComment = 'Long' + (longSignalCount > 1 ? ' C:' + str.tostring(longSignalCount) : '')
    
    // The core `strategy.entry` call. This places a long order with the ID "Long".
    // If a short position is currently open, this command will close it and open a long position.
    strategy.entry('Long', strategy.long, qty = positionQty, comment = entryComment, alert_message = longEntryMsg)
    
    // If debug mode is on, log the details of the entry event.
    if debugEnabled
        debugInfo('Long entry triggered: ' + entryComment + ' at price: ' + str.tostring(close))

// --- Short Entry Execution ---
// This block executes a short trade if the final `shortEntrySignal` is true.
if shortEntrySignal
    // If enabled, this builds and displays a dynamic label for the short trade.
    if displayEntryLabels
        string shortLabelText = buildSignalName(false)
        if shortLabelText != ""
            label lbl = getPooledLabel(false) // Uses a label pooling system for better performance.
            updateLabel(lbl, bar_index, high + atrVal * 0.2, shortLabelText, labelColorShort)
    
    // A dynamic comment is created for the trade log, indicating confluence if multiple signals fired.
    entryComment = 'Short' + (shortSignalCount > 1 ? ' C:' + str.tostring(shortSignalCount) : '')
    
    // The core `strategy.entry` call. This places a short order with the ID "Short".
    // If a long position is currently open, this command will close it and open a short position.
    strategy.entry('Short', strategy.short, qty = positionQty, comment = entryComment, alert_message = shortEntryMsg)
    
    // If debug mode is on, log the details of the entry event.
    if debugEnabled
        debugInfo('Short entry triggered: ' + entryComment + ' at price: ' + str.tostring(close))

// NOTE: Individual signal backtest processing is handled later in the script

// Enhanced debug logging for all directional bias filters and systems
// KEYWORDS: Debug, Logging, Filter Status, Confluence
// This section provides a detailed, real-time text output of the strategy's internal state,
// which is invaluable for debugging and understanding its decision-making process.
if debugEnabled
    // --- Filter Status Summary ---
    // This builds a string that summarizes the real-time status of each primary trend filter.
    filterStatusMsg = 'FILTER STATUS:'
    // For each filter, it checks if it's enabled. If so, it reports its bullish/bearish state; otherwise, it reports 'OFF'.
    filterStatusMsg += ' Hull=' + (hullEnable ? (hullBullish ? 'BULL' : 'BEAR') : 'OFF')
    // SuperTrend removed - replaced by Adaptive SuperTrend
    filterStatusMsg += ' Quad=' + (quadrantEnable ? (quadrantBullish ? 'BULL' : 'BEAR') : 'OFF')
    // The final status string is then passed to the debug logger.
    debugInfo(filterStatusMsg)
    
    // --- Confluence Calculation Details ---
    // This provides a comprehensive overview of the entire directional bias confluence system.
    // It reports the active confluence mode, the number of enabled filters, and the raw bullish/bearish vote counts.
    confluenceMsg = 'CONFLUENCE: Mode=' + biasConfluence + ' | Enabled=' + str.tostring(enabledFilters) + ' | BullVotes=' + str.tostring(bullishVotes) + ' | BearVotes=' + str.tostring(bearishVotes)
    // It also shows the final outcome: whether long and short trades are currently being allowed or blocked by the system.
    confluenceMsg += ' | LongBias=' + (longDirectionalBias ? 'ALLOW' : 'BLOCK') + ' | ShortBias=' + (shortDirectionalBias ? 'ALLOW' : 'BLOCK')
    // The final confluence summary is passed to the debug logger.
    debugInfo(confluenceMsg)
    
    // --- Individual Filter Votes ---
    // This provides a granular look at the specific vote cast by each filter that is currently active.
    if enabledFilters > 0
        voteDetailMsg = 'FILTER VOTES:'
        // For each enabled filter, its specific 'BULL' or 'BEAR' vote is appended to the message.
        if hullEnable
            voteDetailMsg += ' Hull=' + (hullBullish ? 'BULL' : 'BEAR')
        // SuperTrend removed - replaced by Adaptive SuperTrend
        if quadrantEnable
            voteDetailMsg += ' Quad=' + (quadrantBullish ? 'BULL' : 'BEAR')
        // The detailed vote string is then passed to the debug logger.
        debugInfo(voteDetailMsg)



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIGNAL-DRIVEN TREND RIDER: EXIT INTERCEPTION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REVOLUTIONARY FEATURE: Intercept and ignore standard exits during trend-riding mode
// This is the core of the Signal-Driven Trend Rider system

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LEGACY EXIT BLOCKING LOGIC REMOVED â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// All legacy trend-riding exit blocking logic has been removed.
// Exit control is now handled by the new allowTrendExit variable from the Trend-Exit/Hold Filter System.

// â”€â”€â”€â”€â”€â”€â”€â”€ CORE EXIT SYSTEMS (PRESERVED) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Duplicate Smart Profit Locker implementation removed - using original version above

// Fixed SL/TP System - A traditional percentage-based Stop Loss and Take Profit.
// ENHANCED: This exit is also controlled by the `allowTrendExit` flag, respecting trend-hold signals.
if strategy.position_size != 0 and fixedSlTpEnable and allowTrendExit
    // For an open long position:
    if strategy.position_size > 0
        // The Stop Loss is calculated as a percentage below the entry price.
        slLevel = strategy.position_avg_price * (1 - fixedStopLoss / 100)
        // The Take Profit is calculated as a percentage above the entry price.
        tpLevel = strategy.position_avg_price * (1 + fixedTakeProfit / 100)
        // A bracket order is placed: the first level (SL or TP) to be hit will cancel the other.
        strategy.exit('Fixed-Long', from_entry='Long', stop=slLevel, limit=tpLevel, comment='Fixed SL/TP')
    
    // For an open short position:
    else if strategy.position_size < 0
        // The Stop Loss is calculated as a percentage above the entry price.
        slLevel = strategy.position_avg_price * (1 + fixedStopLoss / 100)
        // The Take Profit is calculated as a percentage below the entry price.
        tpLevel = strategy.position_avg_price * (1 - fixedTakeProfit / 100)
        // The bracket order is placed for the short trade.
        strategy.exit('Fixed-Short', from_entry='Short', stop=slLevel, limit=tpLevel, comment='Fixed SL/TP')

// MA Exit System - Exits a position if the price crosses a specified moving average.
// ENHANCED: This exit is also controlled by the `allowTrendExit` flag from the trend-hold system.

// Extract crossover/crossunder calls for consistency (Pine Script v6 requirement)
maCrossUnder = ta.crossunder(close, maExitLine)
maCrossOver = ta.crossover(close, maExitLine)

if strategy.position_size != 0 and maExitEnable and allowTrendExit
    // For a long position, an exit is triggered if the price closes below the MA line.
    if strategy.position_size > 0 and maCrossUnder
        strategy.close('Long', comment='MA Exit', alert_message=longExitMsg)
        debugInfo("ðŸ“ˆ MA Exit: Long position closed below MA")
    
    // For a short position, an exit is triggered if the price closes above the MA line.
    else if strategy.position_size < 0 and maCrossOver
        strategy.close('Short', comment='MA Exit', alert_message=shortExitMsg)
        debugInfo("ðŸ“‰ MA Exit: Short position closed above MA")

// Signal-Based Trend Rider Exits - A specialized exit for the Trend Rider mode.
// ENHANCED: This exit is also controlled by the `allowTrendExit` flag.
if inTrendRidingMode and strategy.position_size != 0 and allowTrendExit
    // This exit triggers if the underlying directional bias (from the confluence filters) flips against the current trade.
    if trendRiderSignalExit and ((strategy.position_size > 0 and not longDirectionalBias) or (strategy.position_size < 0 and not shortDirectionalBias))
        // If in a long position and the long bias is lost, close the trade.
        if strategy.position_size > 0
            strategy.close('Long', comment='Trend Rider Signal Exit', alert_message=longExitMsg)
            debugInfo("ðŸ„ Trend Rider: Long exit on signal reversal")
        // If in a short position and the short bias is lost, close the trade.
        else
            strategy.close('Short', comment='Trend Rider Signal Exit', alert_message=shortExitMsg)
            debugInfo("ðŸ„ Trend Rider: Short exit on signal reversal")
        
        // CRITICAL: After exiting, the trend-riding mode is immediately reset to prevent unwanted re-entries.
        inTrendRidingMode := false
        trendRidingStartBar := na



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LEGACY ADAPTIVE SUPERTREND VISUALIZATION (REMOVED) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Old visualization code completely removed to prevent duplicate variable declarations
// All adaptive exit filter visualization is now handled by the new trend-exit filter system below

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND-EXIT/HOLD FILTER DEBUG VISUALIZATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Professional badge-style debug display for trend-exit/hold filter system

// This block activates only when debug mode is enabled and a trade is active.
if trendExitDebug and strategy.position_size != 0
    // A persistent string variable is used to build the multi-line text for our debug badge.
    var string trendFilterStatus = ''
    // The string is reset on each bar and initialized with a title.
    trendFilterStatus := 'TREND EXIT FILTERS\n'
    
    // --- Append Status for Each Enabled Filter ---
    // If the Adaptive SuperTrend hold filter is on, its status (HOLD/ALLOW) and volatility number are added.
    if adaptiveExitFilterEnable
        adaptiveStatus = adaptiveSTHoldSignal ? 'HOLD' : 'ALLOW'
        trendFilterStatus += 'Adaptive ST: Vol' + str.tostring(adaptiveSTNumber) + ' [' + adaptiveStatus + ']\n'
    
    // If the MA Crossover hold filter is on, its status (HOLD/ALLOW) and settings are added.
    if maCrossoverFilterEnable
        maStatus = maCrossoverHoldSignal ? 'HOLD' : 'ALLOW'
        trendFilterStatus += 'MA Cross: ' + str.tostring(maCrossoverFastLength) + '/' + str.tostring(maCrossoverSlowLength) + ' [' + maStatus + ']\n'
    
    // If any individual trend indicator is configured to send an exit signal, the count of triggered exits is shown.
    if hullTrendExit or quadrantTrendExit or adaptiveTrendExit or volumaticTrendExit or smoothHATrendExit or trendExitSignalEnable
        trendFilterStatus += 'Individual Exits: ' + str.tostring(individualExitCount) + ' triggered\n'
        // If the external signal is used, its specific TRIGGERED/WAITING status is also shown.
        if trendExitSignalEnable
            externalStatus = externalTrendExitSignal ? 'TRIGGERED' : 'WAITING'
            trendFilterStatus += 'External Exit: [' + externalStatus + ']\n'
    
    // --- Final Status Summary ---
    // The final, most important decision of the entire system is appended.
    overallStatus = allowTrendExit ? 'EXIT ALLOWED' : 'EXIT BLOCKED'
    trendFilterStatus += '\nSTATUS: ' + overallStatus
    
    // --- Display the Badge ---
    // CRITICAL OPTIMIZATION: The label is only drawn on the very last bar to prevent script lag from drawing thousands of historical labels.
    if barstate.islast
        // The badge color is green if exits are allowed, and red if they are blocked.
        badgeColor = allowTrendExit ? color.new(color.green, 85) : color.new(color.red, 85)
        // A new label is created on the chart to display the complete status string.
        debugLabel = label.new(bar_index, high + atrVal * 0.3, trendFilterStatus, 
                              color=badgeColor, 
                              textcolor=color.white, 
                              style=label.style_label_down, 
                              size=size.small)



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STEP CHANNEL MOMENTUM VISUALS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Complete ChartPrime Step Channel Momentum visualization (moved to global scope)

// Step Channel visual variables (calculated above in dual-layer mode selection)
stepChannelShowVisualsActive = stepChannelEnable and stepChannelShowVisuals
stepChannelMidLineColor = stepChannelShowVisualsActive and stepChannelShowLines ? stepChannelCurrentColor : na
stepChannelUpperColor = stepChannelShowVisualsActive and stepChannelShowLines ? chart.fg_color : na
stepChannelLowerColor = stepChannelShowVisualsActive and stepChannelShowLines ? chart.fg_color : na
stepChannelCandleColor = stepChannelShowVisualsActive and stepChannelShowCandles ? stepChannelCurrentColor : na

// --- Step Channel Line Plotting ---
// A boolean flag to control the visibility of all channel lines.
stepChannelLinesActive = stepChannelEnable and stepChannelShowLines

// Plots the momentum-colored midline of the channel. Its visibility is controlled by the master flag.
plot(stepChannelLinesActive ? stepChannelAvg : na, 
     "Step Channel MidLine", 
     color=stepChannelLinesActive ? stepChannelCurrentColor : na, 
     linewidth=3)
// Plots the upper boundary of the channel.
plot(stepChannelLinesActive ? stepChannelUpper : na, 
     "Step Channel Upper", 
     color=stepChannelLinesActive ? chart.fg_color : na, 
     style=plot.style_linebr)
// Plots the lower boundary of the channel.
plot(stepChannelLinesActive ? stepChannelLower : na, 
     "Step Channel Lower", 
     color=stepChannelLinesActive ? chart.fg_color : na, 
     style=plot.style_linebr)

// --- Step Channel Momentum Candles ---
// This function overlays colored candles based on the Step Channel's momentum state (Bullish/Bearish/Range).
plotcandle(stepChannelEnable and stepChannelShowCandles ? open : na, 
           stepChannelEnable and stepChannelShowCandles ? high : na, 
           stepChannelEnable and stepChannelShowCandles ? low : na, 
           stepChannelEnable and stepChannelShowCandles ? close : na, 
           title='Momentum Candles', 
           color=stepChannelEnable and stepChannelShowCandles ? stepChannelCurrentColor : na, 
           wickcolor=stepChannelEnable and stepChannelShowCandles ? stepChannelCurrentColor : na, 
           bordercolor=stepChannelEnable and stepChannelShowCandles ? stepChannelCurrentColor : na)

// --- Step Channel Market State Label ---
// Displays the current market state (e.g., "Bull Trend") as a label on the last bar for real-time analysis.
if stepChannelShowVisualsActive and stepChannelShowLabel and barstate.islast
    label.delete(label.new(bar_index, close, stepChannelState, color=color(na), textcolor=stepChannelCurrentColor, style=label.style_label_left, size=size.large)[1])

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADAPTIVE SUPERTREND VOLATILITY VISUALIZATION (EXTERNALIZED) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// The visualization logic for displaying the Adaptive SuperTrend's volatility numbers (1, 2, or 3)
// has been moved to the external 'Adaptive.pine' indicator.
// To see these numbers on the chart, you must add the 'Adaptive.pine' indicator to your chart
// and enable the 'Show Volatility Numbers' option within its settings.
// This section is intentionally left blank to prevent code duplication and conflicts.

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LEGACY STRATEGY EXECUTION LOGIC (DEACTIVATED) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This section is intentionally left blank. The primary strategy execution logic is handled elsewhere.

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONTINUATION & MOMENTUM SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Continuation, Re-entry, Trend Riding, Momentum
// This system allows the strategy to re-enter trades in the direction of an established trend.
// After an initial trade is taken and closed, this logic checks if the underlying momentum
// is still strong, providing opportunities to capitalize further on the same directional move.
// It is a key component of the strategy's ability to maximize profit from strong trends.
// Supports both immediate entries (continuation disabled) and continuation entries (intrabar)

// Determine entry execution timing based on continuation mode
continuationLongEntry = continuationEnable ?     (longContinuationActive and not na(longContinuationLevel) and close >= longContinuationLevel and sigCountLong > 0) :     false

continuationShortEntry = continuationEnable ?     (shortContinuationActive and not na(shortContinuationLevel) and close <= shortContinuationLevel and sigCountShort > 0) :     false

// Regular entry signals (when continuation is disabled)
regularLongEntry = not continuationEnable and longEntrySignal
regularShortEntry = not continuationEnable and shortEntrySignal

// Final entry conditions
finalLongEntry = (continuationLongEntry or regularLongEntry) and strategy.position_size == 0
finalShortEntry = (continuationShortEntry or regularShortEntry) and strategy.position_size == 0

// INTRABAR ENTRY EXECUTION (Critical for continuation entries)
// Note: Continuation entries MUST execute intrabar for optimal timing
if finalLongEntry
    entryComment = continuationEnable ?         buildSignalName(true) + " [CONT:" + str.tostring(continuationDistance, "#.##") + continuationType + "]" :         buildSignalName(true)
    
    // Enhanced webhook message with continuation info
    continuationInfo = continuationEnable ?         ", \"continuation\": {\"enabled\": true, \"distance\": " + str.tostring(continuationDistance, "#.##") + ", \"type\": \"" + continuationType + "\", \"level\": " + str.tostring(longContinuationLevel, "#.####") + "}" :         ", \"continuation\": {\"enabled\": false}"
    
    enhancedLongEntryMsg = '{"ticker": "{{ticker}}", "action": "buy", "quantity": "' + str.tostring(positionQty) + '", "price": "{{close}}", "strategy": "EZ Algo Trader", "signals": "' + buildSignalName(true) + '"' + continuationInfo + '}'
    
    strategy.entry('Long', strategy.long, qty=positionQty, comment=entryComment, alert_message=enhancedLongEntryMsg)
    strategyEntryPrice := close
    
    // Enhanced debug logging
    entryType = continuationEnable ? "CONTINUATION" : "IMMEDIATE"
    debugInfo("ðŸš€ LONG " + entryType + " ENTRY: " + buildSignalName(true) + " at " + str.tostring(close))
    if continuationEnable
        debugInfo("ðŸŽ¯ Continuation Details: Level=" + str.tostring(longContinuationLevel) + ", Distance=" + str.tostring(continuationDistance) + " " + continuationType)
    
    // Reset exit flags for new position
    maExitSent := false
    fixedExitSent := false
    trailExitSent := false
    
    // Reset continuation state after successful entry
    if continuationEnable
        longContinuationActive := false
        longContinuationLevel := na

if finalShortEntry
    entryComment = continuationEnable ?         buildSignalName(false) + " [CONT:" + str.tostring(continuationDistance, "#.##") + continuationType + "]" :         buildSignalName(false)
    
    // Enhanced webhook message with continuation info
    continuationInfo = continuationEnable ?         ", \"continuation\": {\"enabled\": true, \"distance\": " + str.tostring(continuationDistance, "#.##") + ", \"type\": \"" + continuationType + "\", \"level\": " + str.tostring(shortContinuationLevel, "#.####") + "}" :         ", \"continuation\": {\"enabled\": false}"
    
    enhancedShortEntryMsg = '{"ticker": "{{ticker}}", "action": "sell", "quantity": "' + str.tostring(positionQty) + '", "price": "{{close}}", "strategy": "EZ Algo Trader", "signals": "' + buildSignalName(false) + '"' + continuationInfo + '}'
    
    strategy.entry('Short', strategy.short, qty=positionQty, comment=entryComment, alert_message=enhancedShortEntryMsg)
    strategyEntryPrice := close
    
    // Enhanced debug logging
    entryType = continuationEnable ? "CONTINUATION" : "IMMEDIATE"
    debugInfo("ðŸš€ SHORT " + entryType + " ENTRY: " + buildSignalName(false) + " at " + str.tostring(close))
    if continuationEnable
        debugInfo("ðŸŽ¯ Continuation Details: Level=" + str.tostring(shortContinuationLevel) + ", Distance=" + str.tostring(continuationDistance) + " " + continuationType)
    
    // Reset exit flags for new position
    maExitSent := false
    fixedExitSent := false
    trailExitSent := false
    
    // Reset continuation state after successful entry
    if continuationEnable
        shortContinuationActive := false
        shortContinuationLevel := na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INTELLIGENT BLOCKING STATUS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Professional status display for blocked entries

// Global blocking label variable  
var label blockingLabel = na

// Check for blocking conditions and display informative labels
if barstate.islast
    // Delete previous label
    if not na(blockingLabel)
        label.delete(blockingLabel)
        blockingLabel := na
    
    // Determine what message to show
    labelText = ""
    if sigCountLong > 0 and not longEntrySignal
        if not entryAllowed
            labelText := 'ðŸš« LONG BLOCKED: PYRAMID LIMIT'
        else if not longDirectionalBias
            labelText := 'ðŸš« LONG BLOCKED: DIRECTIONAL BIAS'
        else if stepChannelEnable and stepChannelState == "Range" and not scalpModeActive
            labelText := 'ðŸš« LONG BLOCKED: STEP CHANNEL RANGE'
        else if cvdEnable and math.abs(cvdValue) <= cvdThreshold
            labelText := 'ðŸš« LONG BLOCKED: CVD THRESHOLD'
    
    else if sigCountShort > 0 and not shortEntrySignal
        if not entryAllowed
            labelText := 'ðŸš« SHORT BLOCKED: PYRAMID LIMIT'
        else if not shortDirectionalBias
            labelText := 'ðŸš« SHORT BLOCKED: DIRECTIONAL BIAS'
        else if stepChannelEnable and stepChannelState == "Range" and not scalpModeActive
            labelText := 'ðŸš« SHORT BLOCKED: STEP CHANNEL RANGE'
        else if cvdEnable and math.abs(cvdValue) <= cvdThreshold
            labelText := 'ðŸš« SHORT BLOCKED: CVD THRESHOLD'
    
    else if strategy.position_size != 0
        positionType = strategy.position_size > 0 ? "LONG" : "SHORT"
        signalCount = strategy.position_size > 0 ? sigCountLong : sigCountShort
        labelText := 'âœ… IN ' + positionType + ' TRADE: ' + str.tostring(signalCount) + ' SIGNALS'
    
    else if sigCountLong == 0 and sigCountShort == 0
        labelText := 'â³ WAITING FOR SIGNALS'
    
    // Create new label if we have text to show
    if labelText != ""
        blockingLabel := label.new(bar_index, high + atrVal * 0.5, labelText, 
                                  color=color.new(color.red, 80), 
                                  textcolor=color.white, 
                                  style=label.style_label_down, 
                                  size=size.normal)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PRODUCTION SAFETY CHECKS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Critical safety validations for production deployment

// Validate position sizing
if positionQty <= 0
    runtime.error("PRODUCTION ERROR: Position quantity must be greater than 0")

// Pyramid limit check removed - using strategy defaults

// Validate exit system configuration
if not smartProfitEnable and not fixedEnable and not maExitEnable
    runtime.error("PRODUCTION WARNING: At least one exit system should be enabled")

// Validate signal configuration
signalCount = (signal1Enable ? 1 : 0) + (signal2Enable ? 1 : 0) + (signal3Enable ? 1 : 0) + 
              (signal4Enable ? 1 : 0) + (signal5Enable ? 1 : 0) + (signal6Enable ? 1 : 0) + 
              (signal7Enable ? 1 : 0) + (signal8Enable ? 1 : 0) + (signal9Enable ? 1 : 0) + 
              (signal10Enable ? 1 : 0)

if signalCount == 0
    runtime.error("PRODUCTION WARNING: At least one signal should be enabled for trading")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• WEBHOOK INTEGRATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TradersPost webhook message formatting

// Webhook message variables already declared in TradersPost section
// Exit messages already declared in TradersPost webhook section

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PERFORMANCE MONITORING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Production performance metrics

if barstate.islast and debugEnabled
    var table perfTable = table.new(position.bottom_right, 2, 8, bgcolor=color.new(color.white, 90), border_width=1)
    
    table.cell(perfTable, 0, 0, "EZ Algo Trader Performance", text_color=color.black, text_size=size.normal, bgcolor=color.new(color.blue, 80))
    table.cell(perfTable, 1, 0, "", bgcolor=color.new(color.blue, 80))
    
    table.cell(perfTable, 0, 1, "Active Signals", text_color=color.black)
    table.cell(perfTable, 1, 1, str.tostring(sigCountLong + sigCountShort), text_color=color.black)
    
    table.cell(perfTable, 0, 2, "Position Size", text_color=color.black)
    table.cell(perfTable, 1, 2, str.tostring(strategy.position_size), text_color=color.black)
    
    table.cell(perfTable, 0, 3, "Entry Price", text_color=color.black)
    table.cell(perfTable, 1, 3, str.tostring(strategyEntryPrice), text_color=color.black)
    
    table.cell(perfTable, 0, 4, "Unrealized P&L", text_color=color.black)
    table.cell(perfTable, 1, 4, str.tostring(strategy.openprofit), text_color=strategy.openprofit >= 0 ? color.green : color.red)
    
    table.cell(perfTable, 0, 5, "Total Trades", text_color=color.black)
    table.cell(perfTable, 1, 5, str.tostring(strategy.closedtrades), text_color=color.black)
    
    table.cell(perfTable, 0, 6, "Win Rate", text_color=color.black)
    winRate = strategy.closedtrades > 0 ? strategy.wintrades / strategy.closedtrades * 100 : 0
    table.cell(perfTable, 1, 6, str.tostring(winRate, "#.##") + "%", text_color=winRate >= 70 ? color.green : color.red)
    
    table.cell(perfTable, 0, 7, "Status", text_color=color.black)
    statusText = strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "FLAT"
    statusColor = strategy.position_size > 0 ? color.green : strategy.position_size < 0 ? color.red : color.gray
    table.cell(perfTable, 1, 7, statusText, text_color=statusColor)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FINAL PRODUCTION NOTES â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ðŸš€ EZ ALGO TRADER - PRODUCTION READY
// 
// CRITICAL SETUP REQUIREMENTS:
// 1. Connect external indicators to signal sources (37 connections total)
// 2. Configure position sizing and risk management
// 3. Enable appropriate exit systems (SPL recommended)
// 4. Set up TradersPost webhook for automated trading
// 5. Test with paper trading before live deployment
// 
// SAFETY FEATURES:
// âœ… Memory-safe debug system (no label leaks)
// âœ… Production safety validations
// âœ… Intelligent blocking status display
// âœ… Comprehensive error handling
// âœ… Performance monitoring dashboard
// âœ… Professional webhook integration
// 
// STATUS: PRODUCTION READY ðŸš€
