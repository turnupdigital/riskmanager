//
// ğŸš¨================================================================================================ğŸš¨
// ğŸš¨ EZ ALGO TRADER - PURE STRATEGY PROTECTION PROMPT
// ğŸš¨================================================================================================ğŸš¨
//
// PRIMARY MANDATE: PROTECT THE MAGIC
// This Pine Script strategy is achieving unbelievable win rates through a streamlined, battle-tested system.
// This is now a PURE STRATEGY focused on execution performance. The current functionality is SACRED and must be preserved at all costs.
//
//
// ğŸ”’ ABSOLUTE PRESERVATION RULES: DO NOT MODIFY THE FOLLOWING CORE SYSTEMS ğŸ”’
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
// 1. Multi-Signal Processing Logic (Lines ~50-200)
//    - Signal detection arrays and processing
//    - Signal combination and confluence calculations
//    - Entry signal generation with directional bias
//
// 2. Exit System Architecture (Lines ~800-1200)
//    - Multi-method exit logic (MA, Fixed, Smart Profit Locker)
//    - Intrabar exit system with anti-spam flags
//    - Exit interception and trend-riding integration
//
// 3. Trend-Riding Overlay System (Lines ~1300-1500)
//    - Signal-driven trend rider logic
//    - Exit interception during trend-riding mode
//    - Safety net mechanisms (catastrophic stops, max hold)
//
// 4. Directional Bias Filter Integration (Lines ~1600-1800)
//    - RBW, Hull Suite, SuperTrend, Quadrant calculations
//    - Confluence voting system and bias application
//
// 5. Real Strategy Execution (Lines ~1000-1200)
//    - strategy.entry() and strategy.exit() calls
//    - TradersPost webhook integration
//    - Position sizing and risk management
//
//
// ğŸš« STRICT PROHIBITIONS: NEVER DO THESE ğŸš«
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
// - DO NOT Remove Core Strategy Logic (Signal processing, exits, trend-riding).
// - DO NOT Add Heavy Visual Elements (Backtesting tables, complex debug panels, heavy labels).
// - DO NOT Break Exit System Integration (Do not alter strategy.exit() call patterns).
// - DO NOT Alter Working Mathematical Formulas (ATR, confluence math, filter calculations).
//
//
// âœ… APPROVED MODIFICATION AREAS âœ…
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
// - New Filter Additions: Follow the existing pattern for adding new directional bias filters.
// - Minimal Visual Elements: Essential plotshape() for entry/exit signals and core indicator plots ONLY.
// - Parameter Tuning: Adjust default values for existing parameters.
// - Built-in Indicator Integration: Add new `ta.*` functions for additional filters.
//
//
// âš¡ EMERGENCY PROTOCOL: IF SOMETHING BREAKS âš¡
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
// - IMMEDIATELY REVERT to the last working version.
// - Identify the exact change that caused the issue.
// - Use version control to restore functionality.
//
// This prompt serves as a guardian for a battle-tested, high-performing trading strategy. Treat it with the respect it deserves.
// ğŸš¨================================================================================================ğŸš¨

// 2025 Andres Garcia â€” EZ Algo Trader (Beta)
//  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Enhanced Multi-Signal Risk Management System
//  â€¢ Professional risk management with multiple exit strategies
//  â€¢ TradersPost webhook integration for automated trading
//  â€¢ Configurable position sizing and stop-loss/take-profit levels
//  â€¢ Integrated debugging logger for development
//  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//@version=6

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DEBUG SYSTEM (MEMORY SAFE) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Memory-safe debug system that doesn't create label leaks

// Debug configuration
bool debugEnabled = input.bool(false, 'ğŸ” Enable Debug Labels', group = 'ğŸ› ï¸ Debug System', tooltip = 'Show debug information in strategy tester logs')

// Memory-safe debug functions using log output instead of labels
// This prevents memory leaks while preserving debug functionality
debugLog(string message) =>
    if debugEnabled
        log.info("DEBUG: " + message)

debugInfo(string message) =>
    if debugEnabled
        log.info("INFO: " + message)

debugWarn(string message) =>
    if debugEnabled
        log.warning("WARN: " + message)

debugError(string message) =>
    if debugEnabled
        log.error("ERROR: " + message)

debugTrace(string message) =>
    if debugEnabled
        log.info("TRACE: " + message)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LABEL POOL HELPERS (Memory-Safe) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Minimal helper set â€“ capped pool, no heavy visuals
var int MAX_LABELS = 50
var label[] longLabelPool = array.new<label>()
var label[] shortLabelPool = array.new<label>()

// Fetches an existing label from the pool or creates a new one (max MAX_LABELS per side)
getPooledLabel(bool isLong) =>
    pool = isLong ? longLabelPool : shortLabelPool
    label lbl = na
    if array.size(pool) < MAX_LABELS
        lbl := label.new(bar_index, na, '', color = color.new(color.white, 100), textcolor = color.white, size = size.small, style = label.style_label_left)
        array.push(pool, lbl)
    else
        lbl := array.get(pool, bar_index % MAX_LABELS)
    lbl

// Updates a pooled labelâ€™s position, text, and colour
updateLabel(label lbl, int x, float y, string txt, color col) =>
    if not na(lbl)
        label.set_x(lbl, x)
        label.set_y(lbl, y)
        label.set_text(lbl, txt)
        label.set_textcolor(lbl, col)
        label.set_color(lbl, color.new(col, 80))
        label.set_style(lbl, label.style_label_left)
        label.set_size(lbl, size.small)


strategy(title = 'EZ Algo Trade Manager', overlay = true, default_qty_type = strategy.fixed, default_qty_value = 1, calc_on_order_fills = true, process_orders_on_close = true, calc_on_every_tick = false)
// User-controllable quantity

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• GLOBAL VARIABLE DECLARATIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Declare all variables early to avoid scope issues

// Trend-riding system variables
var int trendRidingBarsActive = 0
var bool inTrendRidingMode = false
var int trendRidingStartBar = 0

// Exit system variables
var float smartOffset = na
var string exitComment = na
var string exitReason = na

// Hybrid Exit Mode Variables
var bool inHybridExitMode = false
var int hybridModeStartBar = 0

// ATR and other technical variables
// ATR is calculated using user-configurable atrLen in the ATR Settings section

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MEMORY OPTIMIZATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Backtesting arrays removed for memory efficiency
// Strategy execution logic preserved in protected sections

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CRITICAL INPUT DECLARATIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// These inputs must be declared early as they're used in backtest functions
positionQty = input.int(1, 'Number of Contracts', minval = 1, maxval = 1000, group = 'Position Size', tooltip = 'Set the number of contracts/shares to trade per signal')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• BACKTEST PROCESSING FUNCTIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Core functions for processing individual signal backtests
// NOTE: Functions are defined later in the script to avoid duplication

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 0 Â· POSITION SIZE & PRIMARY SIGNALS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Position Size Control (moved to early declarations section)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MULTI-SIGNAL INPUT SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Support for multiple buy/sell indicators with AI-style quality assessment

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SIGNAL SOURCE INPUTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
signal1Enable = input.bool(true, 'ğŸ“Š Signal 1', inline = 'sig1', group = 'ğŸ”„ Multi-Signals', tooltip = 'Primary signal source')
signal1LongSrc = input.source(close, 'Long', inline = 'sig1', group = 'ğŸ”„ Multi-Signals')
signal1ShortSrc = input.source(close, 'Short', inline = 'sig1', group = 'ğŸ”„ Multi-Signals')
signal1Name = input.string('LuxAlgo', 'Name', inline = 'sig1name', group = 'ğŸ”„ Multi-Signals')
signal1Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig1name', group = 'ğŸ”„ Multi-Signals')

signal2Enable = input.bool(false, 'ğŸ“Š Signal 2', inline = 'sig2', group = 'ğŸ”„ Multi-Signals')
signal2LongSrc = input.source(close, 'Long', inline = 'sig2', group = 'ğŸ”„ Multi-Signals')
signal2ShortSrc = input.source(close, 'Short', inline = 'sig2', group = 'ğŸ”„ Multi-Signals')
signal2Name = input.string('UTBot', 'Name', inline = 'sig2name', group = 'ğŸ”„ Multi-Signals')
signal2Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig2name', group = 'ğŸ”„ Multi-Signals')

signal3Enable = input.bool(false, 'ğŸ“Š Signal 3', inline = 'sig3', group = 'ğŸ”„ Multi-Signals')
signal3LongSrc = input.source(close, 'Long', inline = 'sig3', group = 'ğŸ”„ Multi-Signals')
signal3ShortSrc = input.source(close, 'Short', inline = 'sig3', group = 'ğŸ”„ Multi-Signals')
signal3Name = input.string('VIDYA', 'Name', inline = 'sig3name', group = 'ğŸ”„ Multi-Signals')
signal3Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig3name', group = 'ğŸ”„ Multi-Signals')

signal4Enable = input.bool(false, 'ğŸ“Š Signal 4', inline = 'sig4', group = 'ğŸ”„ Multi-Signals')
signal4LongSrc = input.source(close, 'Long', inline = 'sig4', group = 'ğŸ”„ Multi-Signals')
signal4ShortSrc = input.source(close, 'Short', inline = 'sig4', group = 'ğŸ”„ Multi-Signals')
signal4Name = input.string('KyleAlgo', 'Name', inline = 'sig4name', group = 'ğŸ”„ Multi-Signals')
signal4Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig4name', group = 'ğŸ”„ Multi-Signals')

signal5Enable = input.bool(false, 'ğŸ“Š Signal 5', inline = 'sig5', group = 'ğŸ”„ Multi-Signals')
signal5LongSrc = input.source(close, 'Long', inline = 'sig5', group = 'ğŸ”„ Multi-Signals')
signal5ShortSrc = input.source(close, 'Short', inline = 'sig5', group = 'ğŸ”„ Multi-Signals')
signal5Name = input.string('Wonder', 'Name', inline = 'sig5name', group = 'ğŸ”„ Multi-Signals')
signal5Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig5name', group = 'ğŸ”„ Multi-Signals')

signal6Enable = input.bool(false, 'ğŸ“Š Signal 6', inline = 'sig6', group = 'ğŸ”„ Multi-Signals')
signal6LongSrc = input.source(close, 'Long', inline = 'sig6', group = 'ğŸ”„ Multi-Signals')
signal6ShortSrc = input.source(close, 'Short', inline = 'sig6', group = 'ğŸ”„ Multi-Signals')
signal6Name = input.string('Custom1', 'Name', inline = 'sig6name', group = 'ğŸ”„ Multi-Signals')
signal6Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig6name', group = 'ğŸ”„ Multi-Signals')

signal7Enable = input.bool(false, 'ğŸ“Š Signal 7', inline = 'sig7', group = 'ğŸ”„ Multi-Signals')
signal7LongSrc = input.source(close, 'Long', inline = 'sig7', group = 'ğŸ”„ Multi-Signals')
signal7ShortSrc = input.source(close, 'Short', inline = 'sig7', group = 'ğŸ”„ Multi-Signals')
signal7Name = input.string('Custom2', 'Name', inline = 'sig7name', group = 'ğŸ”„ Multi-Signals')
signal7Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig7name', group = 'ğŸ”„ Multi-Signals')

signal8Enable = input.bool(false, 'ğŸ“Š Signal 8', inline = 'sig8', group = 'ğŸ”„ Multi-Signals')
signal8LongSrc = input.source(close, 'Long', inline = 'sig8', group = 'ğŸ”„ Multi-Signals')
signal8ShortSrc = input.source(close, 'Short', inline = 'sig8', group = 'ğŸ”„ Multi-Signals')
signal8Name = input.string('Custom3', 'Name', inline = 'sig8name', group = 'ğŸ”„ Multi-Signals')
signal8Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig8name', group = 'ğŸ”„ Multi-Signals')

signal9Enable = input.bool(false, 'ğŸ“Š Signal 9', inline = 'sig9', group = 'ğŸ”„ Multi-Signals')
signal9LongSrc = input.source(close, 'Long', inline = 'sig9', group = 'ğŸ”„ Multi-Signals')
signal9ShortSrc = input.source(close, 'Short', inline = 'sig9', group = 'ğŸ”„ Multi-Signals')
signal9Name = input.string('Custom4', 'Name', inline = 'sig9name', group = 'ğŸ”„ Multi-Signals')
signal9Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig9name', group = 'ğŸ”„ Multi-Signals')

signal10Enable = input.bool(false, 'ğŸ“Š Signal 10', inline = 'sig10', group = 'ğŸ”„ Multi-Signals')
signal10LongSrc = input.source(close, 'Long', inline = 'sig10', group = 'ğŸ”„ Multi-Signals')
signal10ShortSrc = input.source(close, 'Short', inline = 'sig10', group = 'ğŸ”„ Multi-Signals')
signal10Name = input.string('Custom5', 'Name', inline = 'sig10name', group = 'ğŸ”„ Multi-Signals')
signal10Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig10name', group = 'ğŸ”„ Multi-Signals')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LABELING OPTIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
displayEntryLabels = input.bool(true,  'Show Entry Labels', group = 'ğŸ“ Labeling')
labelColorLong     = input.color(color.green, 'Long Label Colour',  group = 'ğŸ“ Labeling', inline='lblcl')
labelColorShort    = input.color(color.red,   'Short Label Colour', group = 'ğŸ“ Labeling', inline='lblcl')

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENHANCED SIGNAL PROCESSING (BUG FIX) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CRITICAL SAFETY: Signals must NEVER fire when source equals default close price
// This prevents false signals from unconnected inputs and ensures only real indicators fire
// Enhanced validation with explicit rejection of default sources

// Helper function to validate signal sources (prevents default close from generating signals)
isValidSignalSource(src) =>
    not na(src) and src != close and src != open and src != high and src != low

// Enhanced validation for external indicators (Signal 5 fix)
// More permissive validation that allows external indicators to work properly
// Only blocks truly invalid signals (na values or disabled signals)
isValidExternalSignal(src) =>
    not na(src)  // Only check for na values, allow price-based external indicators

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIGNAL USAGE PROCESSING HELPER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW FEATURE: Process signals based on usage dropdown settings
// Allows each signal to be configured for specific entry/exit behavior

// Signal Usage Processing Function
processSignalWithUsage(bool rawLongSignal, bool rawShortSignal, string usage) =>
    var bool processedLong = false
    var bool processedShort = false
    var bool isEntrySignal = false
    var bool isExitSignal = false
    
    // Determine signal type based on usage
    isEntrySignal := usage == 'Entry All' or usage == 'Entry Long Only' or usage == 'Entry Short Only'
    isExitSignal := usage == 'Exit All' or usage == 'Exit Long Only' or usage == 'Exit Short Only'
    
    // Process signals based on usage setting
    if usage == 'Entry All'
        processedLong := rawLongSignal
        processedShort := rawShortSignal
    else if usage == 'Entry Long Only'
        processedLong := rawLongSignal
        processedShort := false  // Block short entries
    else if usage == 'Entry Short Only'
        processedLong := false   // Block long entries
        processedShort := rawShortSignal
    else if usage == 'Exit All'
        // Exit signals are handled separately in trend-riding logic
        processedLong := false
        processedShort := false
    else if usage == 'Exit Long Only'
        // Exit signals are handled separately in trend-riding logic
        processedLong := false
        processedShort := false
    else if usage == 'Exit Short Only'
        // Exit signals are handled separately in trend-riding logic
        processedLong := false
        processedShort := false
    else if usage == 'Observe'
        // Signal is tracked but doesn't trigger trades
        processedLong := false
        processedShort := false
    else
        // Default to 'Entry All' behavior
        processedLong := rawLongSignal
        processedShort := rawShortSignal
    
    [processedLong, processedShort, isEntrySignal, isExitSignal]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIGNAL PROCESSING LOGIC â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRITICAL: This is the core signal detection system - DO NOT BREAK
// Enhanced with usage dropdown functionality for flexible signal behavior

// Raw signal detection (unchanged core logic)
rawSig1Long = signal1Enable and isValidSignalSource(signal1LongSrc) ? (signal1LongSrc > 0 or bool(signal1LongSrc) == true) : false
rawSig1Short = signal1Enable and isValidSignalSource(signal1ShortSrc) ? (signal1ShortSrc > 0 or bool(signal1ShortSrc) == true) : false
rawSig2Long = signal2Enable and isValidSignalSource(signal2LongSrc) ? (signal2LongSrc > 0 or bool(signal2LongSrc) == true) : false
rawSig2Short = signal2Enable and isValidSignalSource(signal2ShortSrc) ? (signal2ShortSrc > 0 or bool(signal2ShortSrc) == true) : false
rawSig3Long = signal3Enable and isValidSignalSource(signal3LongSrc) ? (signal3LongSrc > 0 or bool(signal3LongSrc) == true) : false
rawSig3Short = signal3Enable and isValidSignalSource(signal3ShortSrc) ? (signal3ShortSrc > 0 or bool(signal3ShortSrc) == true) : false
rawSig4Long = signal4Enable and isValidSignalSource(signal4LongSrc) ? (signal4LongSrc > 0 or bool(signal4LongSrc) == true) : false
rawSig4Short = signal4Enable and isValidSignalSource(signal4ShortSrc) ? (signal4ShortSrc > 0 or bool(signal4ShortSrc) == true) : false
rawSig5Long = signal5Enable and isValidExternalSignal(signal5LongSrc) ? (signal5LongSrc > 0 or bool(signal5LongSrc) == true) : false
rawSig5Short = signal5Enable and isValidExternalSignal(signal5ShortSrc) ? (signal5ShortSrc > 0 or bool(signal5ShortSrc) == true) : false
rawSig6Long = signal6Enable and isValidSignalSource(signal6LongSrc) ? (signal6LongSrc > 0 or bool(signal6LongSrc) == true) : false
rawSig6Short = signal6Enable and isValidSignalSource(signal6ShortSrc) ? (signal6ShortSrc > 0 or bool(signal6ShortSrc) == true) : false
rawSig7Long = signal7Enable and isValidSignalSource(signal7LongSrc) ? (signal7LongSrc > 0 or bool(signal7LongSrc) == true) : false
rawSig7Short = signal7Enable and isValidSignalSource(signal7ShortSrc) ? (signal7ShortSrc > 0 or bool(signal7ShortSrc) == true) : false
rawSig8Long = signal8Enable and isValidSignalSource(signal8LongSrc) ? (signal8LongSrc > 0 or bool(signal8LongSrc) == true) : false
rawSig8Short = signal8Enable and isValidSignalSource(signal8ShortSrc) ? (signal8ShortSrc > 0 or bool(signal8ShortSrc) == true) : false
rawSig9Long = signal9Enable and isValidSignalSource(signal9LongSrc) ? (signal9LongSrc > 0 or bool(signal9LongSrc) == true) : false
rawSig9Short = signal9Enable and isValidSignalSource(signal9ShortSrc) ? (signal9ShortSrc > 0 or bool(signal9ShortSrc) == true) : false
rawSig10Long = signal10Enable and isValidSignalSource(signal10LongSrc) ? (signal10LongSrc > 0 or bool(signal10LongSrc) == true) : false
rawSig10Short = signal10Enable and isValidSignalSource(signal10ShortSrc) ? (signal10ShortSrc > 0 or bool(signal10ShortSrc) == true) : false

// Process signals with usage settings (NEW FEATURE)
[sig1Long, sig1Short, sig1IsEntry, sig1IsExit] = processSignalWithUsage(rawSig1Long, rawSig1Short, signal1Usage)
[sig2Long, sig2Short, sig2IsEntry, sig2IsExit] = processSignalWithUsage(rawSig2Long, rawSig2Short, signal2Usage)
[sig3Long, sig3Short, sig3IsEntry, sig3IsExit] = processSignalWithUsage(rawSig3Long, rawSig3Short, signal3Usage)
[sig4Long, sig4Short, sig4IsEntry, sig4IsExit] = processSignalWithUsage(rawSig4Long, rawSig4Short, signal4Usage)
[sig5Long, sig5Short, sig5IsEntry, sig5IsExit] = processSignalWithUsage(rawSig5Long, rawSig5Short, signal5Usage)
[sig6Long, sig6Short, sig6IsEntry, sig6IsExit] = processSignalWithUsage(rawSig6Long, rawSig6Short, signal6Usage)
[sig7Long, sig7Short, sig7IsEntry, sig7IsExit] = processSignalWithUsage(rawSig7Long, rawSig7Short, signal7Usage)
[sig8Long, sig8Short, sig8IsEntry, sig8IsExit] = processSignalWithUsage(rawSig8Long, rawSig8Short, signal8Usage)
[sig9Long, sig9Short, sig9IsEntry, sig9IsExit] = processSignalWithUsage(rawSig9Long, rawSig9Short, signal9Usage)
[sig10Long, sig10Short, sig10IsEntry, sig10IsExit] = processSignalWithUsage(rawSig10Long, rawSig10Short, signal10Usage)

// Debug validation: Alert when signals are blocked due to default sources
if debugEnabled and signal1Enable and not isValidSignalSource(signal1LongSrc)
    debugWarn("Signal 1 Long blocked: Source equals default close price. Connect external indicator.")
if debugEnabled and signal1Enable and not isValidSignalSource(signal1ShortSrc)
    debugWarn("Signal 1 Short blocked: Source equals default close price. Connect external indicator.")

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SIGNAL ARRAYS FOR PROCESSING (MEMORY LEAK FIX) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CRITICAL FIX: Use persistent arrays with proper memory management
// Create arrays once and reuse them instead of creating new ones every bar
var allLongSignals = array.new<bool>(10)
var allShortSignals = array.new<bool>(10)

// Update array values efficiently (reuse existing arrays)
array.set(allLongSignals, 0, sig1Long)
array.set(allLongSignals, 1, sig2Long)
array.set(allLongSignals, 2, sig3Long)
array.set(allLongSignals, 3, sig4Long)
array.set(allLongSignals, 4, sig5Long)
array.set(allLongSignals, 5, sig6Long)
array.set(allLongSignals, 6, sig7Long)
array.set(allLongSignals, 7, sig8Long)
array.set(allLongSignals, 8, sig9Long)
array.set(allLongSignals, 9, sig10Long)
array.set(allShortSignals, 0, sig1Short)
array.set(allShortSignals, 1, sig2Short)
array.set(allShortSignals, 2, sig3Short)
array.set(allShortSignals, 3, sig4Short)
array.set(allShortSignals, 4, sig5Short)
array.set(allShortSignals, 5, sig6Short)
array.set(allShortSignals, 6, sig7Short)
array.set(allShortSignals, 7, sig8Short)
array.set(allShortSignals, 8, sig9Short)
array.set(allShortSignals, 9, sig10Short)

// Count active signals
longSignalCount = (sig1Long ? 1 : 0) + (sig2Long ? 1 : 0) + (sig3Long ? 1 : 0) + (sig4Long ? 1 : 0) + (sig5Long ? 1 : 0) + (sig6Long ? 1 : 0) + (sig7Long ? 1 : 0) + (sig8Long ? 1 : 0) + (sig9Long ? 1 : 0) + (sig10Long ? 1 : 0)
shortSignalCount = (sig1Short ? 1 : 0) + (sig2Short ? 1 : 0) + (sig3Short ? 1 : 0) + (sig4Short ? 1 : 0) + (sig5Short ? 1 : 0) + (sig6Short ? 1 : 0) + (sig7Short ? 1 : 0) + (sig8Short ? 1 : 0) + (sig9Short ? 1 : 0) + (sig10Short ? 1 : 0)



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PRIMARY SIGNAL COMBINATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Note: Primary signals are defined below after imports (line 126-127)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RBW FILTER IMPORT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Import enhanced_ta library for existing RBW filter (defined later)
import HeWhoMustNotBeNamed/enhanced_ta/14 as eta

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FLIPFLOP RANGE-BREAKOUT FILTER (OPTIONAL) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Inline port of FlipFlopFilter.pine (â‰ˆ150 lines). OFF by default; fully user-configurable.

// â”€â”€â”€â”€â”€ USER SETTINGS â”€â”€â”€â”€â”€
ffEnable  = input.bool(false,  'ğŸš¦ Enable FlipFlop Filter', group='ğŸ†• FlipFlop Filter')
ffShowBg  = input.bool(true,   'Show Range/Breakout BG',   group='ğŸ†• FlipFlop Filter', inline='ff1')
ffSigSrc  = input.string('Any','Signal Source', options=['Breakout','Reversal','Any'], group='ğŸ†• FlipFlop Filter', inline='ff1')
ffAtrLen   = input.int(400,  'ATR Length',         group='ğŸ†• FlipFlop Filter')
ffAbsMax   = input.float(2.0,'AbsMax Ã—ATR', step=0.1, group='ğŸ†• FlipFlop Filter')
ffMinFlips = input.int(3,    'Min Small Flips',    group='ğŸ†• FlipFlop Filter')
ffBreakK   = input.float(0.6,'BreakK Ã—ATR', step=0.05, group='ğŸ†• FlipFlop Filter')
ffRunThres = input.float(2.0,'runATR Threshold', step=0.1, group='ğŸ†• FlipFlop Filter')
ffDecay    = input.int(1,'Small Flip Decay',   minval=1, maxval=10, group='ğŸ†• FlipFlop Filter')

// External pulses (optional)
ff_longEntSrc   = input.source(close, 'Ext Long ENTRY',  group='ğŸ†• FlipFlop Filter')
ff_longExitSrc  = input.source(close, 'Ext Long EXIT',   group='ğŸ†• FlipFlop Filter')
ff_shortEntSrc  = input.source(close, 'Ext Short ENTRY', group='ğŸ†• FlipFlop Filter')
ff_shortExitSrc = input.source(close, 'Ext Short EXIT',  group='ğŸ†• FlipFlop Filter')

// â”€â”€â”€â”€â”€ INTERNAL CALCULATIONS â”€â”€â”€â”€â”€
ff_isPulse(sig) => nz(sig,0) != 0 and nz(sig[1],0) == 0
ffATR  = ta.atr(ffAtrLen)
ffDir  = close >= open ? 1 : -1
ffFlip = ta.change(ffDir) != 0
var int ff_runID = 0
ff_runID := ffFlip ? ff_runID + 1 : ff_runID
ff_runMove = math.abs(close - ta.valuewhen(ffFlip, close[1], 0))
// Hardened division guard
ff_runATR  = (not na(ffATR) and ffATR > 0.0001) ? ff_runMove / ffATR : 0.0
ff_lastInRun = ta.barssince(ffFlip[1]) == 0

// MEMORY-SAFE fixed-length buffer (max 20)
var float[] ff_buf = array.new_float()
if ff_lastInRun
    if array.size(ff_buf) >= 20
        array.shift(ff_buf)
    array.push(ff_buf, ff_runATR)
ff_isSmall = ff_runATR < ffAbsMax

var bool ff_inRange = false
var float ff_hi = na
var float ff_lo = na
var int ff_smallCnt = 0
ff_brkLong = false
ff_brkShort = false
if not ff_inRange
    if ff_lastInRun
        // Increment or decay small-flip counter
        ff_smallCnt := ff_isSmall ? ff_smallCnt + 1 : math.max(ff_smallCnt - ffDecay, 0)
    if ff_smallCnt >= ffMinFlips
        ff_inRange := true
        ff_hi := high
        ff_lo := low
else
    ff_dynUp = (high - ff_hi) > ffBreakK * ffATR
    ff_dynDn = (ff_lo - low)  > ffBreakK * ffATR
    ff_atrUp = ff_runATR > ffRunThres and ffDir == 1  and ff_lastInRun
    ff_atrDn = ff_runATR > ffRunThres and ffDir == -1 and ff_lastInRun
    if ff_dynUp or ff_atrUp
        ff_brkLong := true
        ff_inRange := false
        ff_smallCnt := 0
    else if ff_dynDn or ff_atrDn
        ff_brkShort := true
        ff_inRange := false
        ff_smallCnt := 0
    else
        ff_hi := math.max(ff_hi, high)
        ff_lo := math.min(ff_lo, low)

var bool ff_trendMode = false
if ff_brkLong or ff_brkShort
    ff_trendMode := true
if ff_inRange
    ff_trendMode := false

ff_revLongEntry  = ff_trendMode and ff_isPulse(ff_longEntSrc)
ff_revShortEntry = ff_trendMode and ff_isPulse(ff_shortEntSrc)

ff_buySig  = (ffSigSrc == 'Breakout' and ff_brkLong)  or (ffSigSrc == 'Reversal' and ff_revLongEntry)  or (ffSigSrc == 'Any' and (ff_brkLong  or ff_revLongEntry))
ff_sellSig = (ffSigSrc == 'Breakout' and ff_brkShort) or (ffSigSrc == 'Reversal' and ff_revShortEntry) or (ffSigSrc == 'Any' and (ff_brkShort or ff_revShortEntry))

// Background highlight (must be global call)
var color ff_bg = na
ff_bg := ffEnable and ffShowBg and ff_inRange ? color.new(color.blue, 90) : na
bgcolor(ff_bg)

ff_longGate  = not ffEnable ? true : ff_buySig
ff_shortGate = not ffEnable ? true : ff_sellSig

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• BUILD SIGNAL NAME FUNCTION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Builds a "+"-concatenated string of active signal names on the current bar
// Declared after all signal and FlipFlop variables exist to prevent undeclared identifier errors
buildSignalName(bool isLong) =>
    string names = ""
    if isLong
        if sig1Long  
            names := names == "" ? signal1Name : names + "+" + signal1Name
        if sig2Long  
            names := names == "" ? signal2Name : names + "+" + signal2Name
        if sig3Long  
            names := names == "" ? signal3Name : names + "+" + signal3Name
        if sig4Long  
            names := names == "" ? signal4Name : names + "+" + signal4Name
        if sig5Long  
            names := names == "" ? signal5Name : names + "+" + signal5Name
        if sig6Long  
            names := names == "" ? signal6Name : names + "+" + signal6Name
        if sig7Long  
            names := names == "" ? signal7Name : names + "+" + signal7Name
        if sig8Long  
            names := names == "" ? signal8Name : names + "+" + signal8Name
        if sig9Long  
            names := names == "" ? signal9Name : names + "+" + signal9Name
        if sig10Long 
            names := names == "" ? signal10Name : names + "+" + signal10Name
        if ff_buySig 
            names := names == "" ? "FlipFlop" : names + "+FlipFlop"
    else
        if sig1Short  
            names := names == "" ? signal1Name : names + "+" + signal1Name
        if sig2Short  
            names := names == "" ? signal2Name : names + "+" + signal2Name
        if sig3Short  
            names := names == "" ? signal3Name : names + "+" + signal3Name
        if sig4Short  
            names := names == "" ? signal4Name : names + "+" + signal4Name
        if sig5Short  
            names := names == "" ? signal5Name : names + "+" + signal5Name
        if sig6Short  
            names := names == "" ? signal6Name : names + "+" + signal6Name
        if sig7Short  
            names := names == "" ? signal7Name : names + "+" + signal7Name
        if sig8Short  
            names := names == "" ? signal8Name : names + "+" + signal8Name
        if sig9Short  
            names := names == "" ? signal9Name : names + "+" + signal9Name
        if sig10Short 
            names := names == "" ? signal10Name : names + "+" + signal10Name
        if ff_sellSig 
            names := names == "" ? "FlipFlop" : names + "+FlipFlop"
    names

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIGNAL PROCESSING SETUP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Legacy compatibility - combine all signals
primaryLongSig = sig1Long or sig2Long or sig3Long or sig4Long or sig5Long or sig6Long or sig7Long or sig8Long or sig9Long or sig10Long
primaryShortSig = sig1Short or sig2Short or sig3Short or sig4Short or sig5Short or sig6Short or sig7Short or sig8Short or sig9Short or sig10Short

// â”€â”€â”€â”€â”€ APPLY FLIPFLOP FILTER â”€â”€â”€â”€â”€
if ffEnable
    primaryLongSig := primaryLongSig and ff_longGate
    primaryShortSig := primaryShortSig and ff_shortGate

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1 Â· TRADERSPOST JSON HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€ Pre-built JSON messages (compile-time constants) â”€â”€â”€â”€â”€
// Use TradingView alert placeholders so we avoid any per-bar string operations.
// Placeholders {{close}} and {{timenow}} will be expanded at alert trigger time.
var string _jsonBase = '{"ticker":"' + syminfo.ticker + '","price":{{close}},"time":{{timenow}}'

var string longEntryMsg = _jsonBase + ',"action":"buy","sentiment":"long"}'
var string shortEntryMsg = _jsonBase + ',"action":"sell","sentiment":"short"}'
var string flatExitMsg = _jsonBase + ',"action":"exit","sentiment":"flat"}'
var string longExitMsg = _jsonBase + ',"action":"sell","sentiment":"flat"}' // closes long
var string shortExitMsg = _jsonBase + ',"action":"buy","sentiment":"flat"}' // closes short

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2 Â· ATR SETTINGS (BUG FIX) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
atrLen = input.int(14, 'ATR Length', minval = 1, group = 'ATR Settings')

// CRITICAL FIX: ATR Validation to prevent silent failures
// Raw ATR calculation
rawATR = ta.atr(atrLen)

// Validated ATR with fallback protection
atrVal = na(rawATR) or rawATR <= 0 ? ta.sma(high - low, math.min(atrLen, bar_index + 1)) : rawATR

// Final safety check: ensure ATR is never zero or negative
atrVal := math.max(atrVal, 0.0001)  // Minimum ATR of 0.0001 to prevent division by zero

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3 Â· EXIT PARAMETERS (ASCII SAFE) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
maExitOn = input.bool(true, 'Enable MA Exit', group = 'MA Exit')
maLen = input.int(21, 'MA Length', minval = 1, group = 'MA Exit')
maType = input.string('EMA', 'MA Type', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA'], group = 'MA Exit')
// Intrabar exits removed - exits only trigger once per bar on close

priceMA = maType == 'SMA' ? ta.sma(close, maLen) : maType == 'EMA' ? ta.ema(close, maLen) : maType == 'WMA' ? ta.wma(close, maLen) : maType == 'VWMA' ? ta.vwma(close, maLen) : ta.rma(close, maLen)

fixedEnable = input.bool(false, 'Enable Fixed SL/TP', group = 'Fixed SL/TP')
fixedUnit = input.string('ATR', 'Unit', options = ['ATR', 'Points'], group = 'Fixed SL/TP')
fixedStop = input.float(1.0, 'Stop Size', step = 0.1, minval = 0.0, group = 'Fixed SL/TP')

tpCalc(d) =>
    fixedUnit == 'ATR' ? d * atrVal : d

tp1Enable = input.bool(false, 'TP1', inline = 'tp1', group = 'Fixed SL/TP')
tp1Size = input.float(1.5, '', inline = 'tp1', group = 'Fixed SL/TP')
tp2Enable = input.bool(false, 'TP2', inline = 'tp2', group = 'Fixed SL/TP')
tp2Size = input.float(3.0, '', inline = 'tp2', group = 'Fixed SL/TP')
tp3Enable = input.bool(false, 'TP3', inline = 'tp3', group = 'Fixed SL/TP')
tp3Size = input.float(4.0, '', inline = 'tp3', group = 'Fixed SL/TP')



// Smart Profit Locker (Aggressive Profit Protection)
smartProfitEnable = input.bool(false, 'ğŸ¯ Enable Smart Profit Locker', group = 'Smart Profit Locker', tooltip = 'Aggressive profit-taking with adjustable pullback sensitivity')
smartProfitType = input.string('ATR', 'Type', options = ['ATR', 'Points', 'Percent'], group = 'Smart Profit Locker')
smartProfitVal = input.float(3.1, 'Value', step = 0.1, group = 'Smart Profit Locker')
smartProfitOffset = input.float(0.10, 'Pullback %', step = 0.05, minval = 0.01, maxval = 1.0, group = 'Smart Profit Locker', tooltip = 'Pullback percentage to trigger exit (0.10 = 10%)')
// CRITICAL FIX: User-configurable fallback for invalid calculations
smartProfitFallback = input.float(50.0, 'Fallback Value', step = 1.0, minval = 0.1, group = 'Smart Profit Locker', tooltip = 'Fallback value when calculation fails. Set appropriately for your symbol: Forex ~0.001, Crypto ~1.0, Stocks ~0.50')

// Traditional Trailing Stop - REMOVED (use Smart Profit Locker with 100% offset for traditional behavior)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 4 Â· BACKTESTING PANEL CONTROLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showBacktestTable = input.bool(true, 'ğŸ“Š Individual Signal Backtest', group = 'ğŸ” Backtesting Panels', tooltip = 'Show individual signal performance (existing table)')
backtestLookback = input.string('7 Days', 'Backtest Lookback Period', options = ['3 Days', '7 Days', '30 Days', '90 Days'], group = 'ğŸ” Backtesting Panels', tooltip = 'How far back to analyze performance')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MEMORY OPTIMIZATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Backtesting functions and arrays removed for memory efficiency
// Strategy execution logic preserved in protected sections


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ENTRY SIGNAL DECLARATIONS (BUG FIX) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRITICAL FIX: Declare entry signal variables here, assign values after filter calculations
// This fixes the circular dependency where signals were used before being calculated

// Entry signal variable declarations (assigned later after all filters are calculated)
var bool longEntrySignal = false
var bool shortEntrySignal = false

// Initialize debug logging on first bar
if barstate.isfirst
    debugInfo('EZAlgoTrader initialized with debug logging')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ENTRY LOGIC (FIXED - MOVED TO PROPER LOCATION) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRITICAL FIX: Entry signals are now calculated at the end of the script (line ~1400+)
// This section is a placeholder - actual entry logic moved to after all calculations

// Entry logic is now handled at the end of the script after all filters are calculated
// This fixes the circular dependency where entry signals were used before being defined

// The actual entry conditions are:
// longEntrySignal := primaryLongSig and longDirectionalBias and entryProbabilityOK  
// shortEntrySignal := primaryShortSig and shortDirectionalBias and entryProbabilityOK

// Entry execution happens via strategy.entry() calls at the end of the script

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• REAL STRATEGY EXIT LOGIC (CRITICAL FIX) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This section bridges the gap between combo backtesting and actual strategy execution
// All exit methods now control the REAL strategy, not just the display panel

// Track entry price for distance-based exits
var float strategyEntryPrice = na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• EXIT CONTROL FLAGS (INTRABAR SYSTEM) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Per-method flags to prevent duplicate alerts and enable prioritization
var bool maExitSent = false
var bool fixedExitSent = false
var bool fibExitSent = false
var bool trailExitSent = false
var bool customExitSent = false
var bool inPosition = false
var bool exitInProgress = false

// Position tracking and flag reset logic
if strategy.position_size == 0
    strategyEntryPrice := na
else if strategy.position_size != 0 and na(strategyEntryPrice)
    strategyEntryPrice := strategy.position_avg_price

// Reset all exit flags on new position entry
currentPosition = strategy.position_size != 0
if currentPosition and not inPosition
    // New trade detected - reset all flags
    maExitSent := false
    fixedExitSent := false
    fibExitSent := false
    trailExitSent := false
    customExitSent := false
    exitInProgress := false
    inPosition := true
else if not currentPosition and inPosition
    // Trade closed - update state
    inPosition := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ROBUST INTRABAR EXIT SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Exit logic that works properly while preventing alert spam
// Key insight: strategy.exit() calls must run every bar, only alerts should be limited

// â”€â”€â”€â”€â”€â”€â”€â”€ 1. MA EXIT (Intrabar with Anti-Spam) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if maExitOn and strategy.position_size != 0
    longMaExit = strategy.position_size > 0 and close < priceMA
    shortMaExit = strategy.position_size < 0 and close > priceMA
    
    if longMaExit and not maExitSent
        strategy.close('Long', comment='MA Exit ', alert_message=longExitMsg)
        maExitSent := true
    else if shortMaExit and not maExitSent
        strategy.close('Short', comment='MA Exit ', alert_message=shortExitMsg)
        maExitSent := true

// â”€â”€â”€â”€â”€â”€â”€â”€ 2. FIXED SL/TP (Always Active) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if fixedEnable and not na(strategyEntryPrice) and strategy.position_size != 0
    stopDistance = tpCalc(fixedStop)
    profitDistance = tp1Enable ? tpCalc(tp1Size) : na
    
    // Ensure distances are valid
    if na(stopDistance) or stopDistance <= 0
        stopDistance := 0.01  // Safe default
    
    if strategy.position_size > 0  // Long position
        stopLevel = math.max(strategyEntryPrice - stopDistance, close * 0.99)
        profitLevel = not na(profitDistance) ? strategyEntryPrice + profitDistance : na
        strategy.exit('Fixed-Long', from_entry='Long', stop=stopLevel, limit=profitLevel, comment='Fixed SL/TP')
        if not fixedExitSent
            fixedExitSent := true
    
    else if strategy.position_size < 0  // Short position
        stopLevel = math.min(strategyEntryPrice + stopDistance, close * 1.01)
        profitLevel = not na(profitDistance) ? strategyEntryPrice - profitDistance : na
        strategy.exit('Fixed-Short', from_entry='Short', stop=stopLevel, limit=profitLevel, comment='Fixed SL/TP')
        if not fixedExitSent
            fixedExitSent := true



// â”€â”€â”€â”€â”€â”€â”€â”€ 4. SMART PROFIT LOCKER (Aggressive Profit Protection) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SIGNAL-DRIVEN TREND RIDER INTEGRATION: Block Smart Profit Locker during trend-riding mode
// Only run Smart Profit Locker in Normal Mode or Hybrid Exit Mode
if smartProfitEnable and strategy.position_size != 0 and not (inTrendRidingMode and not inHybridExitMode)
    smartDistance = smartProfitType == 'ATR' ? smartProfitVal * atrVal : smartProfitType == 'Points' ? smartProfitVal : strategyEntryPrice * smartProfitVal / 100.0
    
    // CRITICAL FIX: Symbol-aware Smart Profit Locker validation
    // Replace hardcoded fallback with dynamic symbol-appropriate defaults
    if na(smartDistance) or smartDistance <= 0
        // Dynamic fallback based on symbol type and current price
        symbolType = syminfo.type
        currentPrice = close
        
        // Symbol-aware fallback calculation
        smartDistance := symbolType == "forex" ? currentPrice * 0.001 : symbolType == "crypto" ? currentPrice * 0.005 : currentPrice < 10 ? currentPrice * 0.02 : currentPrice < 100 ? currentPrice * 0.01 : currentPrice * 0.005
        
        // Ensure minimum viable distance (never less than 1 tick)
        smartDistance := math.max(smartDistance, syminfo.mintick * 10)
    
    // MODE-BASED EXIT BEHAVIOR
    if inHybridExitMode
        // HYBRID MODE: Use TIGHT trailing stops when exit indicators fire during trend-riding
        smartDistance := smartDistance * 1.0  // 1x ATR (tight profit protection)
        smartOffset := smartDistance * 0.50  // 50% offset (aggressive profit taking)
        exitComment := 'Hybrid Exit Mode'
    else
        // NORMAL MODE: Use regular Smart Profit Locker settings
        smartOffset := smartDistance * math.max(smartProfitOffset, 0.01)
        exitComment := 'Smart Profit Locker'
    
    if strategy.position_size > 0  // Long position
        strategy.exit('Smart-Long', from_entry='Long', trail_points=math.max(smartDistance, 0.01), trail_offset=math.max(smartOffset, 0.01), comment=exitComment)
        if not trailExitSent
            trailExitSent := true
    else if strategy.position_size < 0  // Short position
        strategy.exit('Smart-Short', from_entry='Short', trail_points=math.max(smartDistance, 0.01), trail_offset=math.max(smartOffset, 0.01), comment=exitComment)
        if not trailExitSent
            trailExitSent := true

// â”€â”€â”€â”€â”€â”€â”€â”€ 5. TRADITIONAL TRAILING STOP - REMOVED â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Use Smart Profit Locker with different offset values:
// â€¢ 10% offset = Aggressive profit taking
// â€¢ 100% offset = Traditional trailing stop behavior

// â”€â”€â”€â”€â”€â”€â”€â”€ 6. RELATIVE BANDWIDTH DIRECTIONAL FILTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Compact multi-column panel for volatility-based directional bias
rbwEnable = input.bool(true, 'ğŸ“Š Enable RBW Filter', group='ğŸ“Š Relative Bandwidth Filter', inline='rbw0')

// Band Type Selection (Row 1)
rbwBandType = input.string("KC", "Band Type", group='ğŸ“Š Relative Bandwidth Filter', options=["BB", "KC", "DC"], inline='rbw1')
rbwSource = input.source(close, "Source", group='ğŸ“Š Relative Bandwidth Filter', inline='rbw1')

// Band Parameters (Row 2) 
rbwLength = input.int(100, "Length", group='ğŸ“Š Relative Bandwidth Filter', inline='rbw2')
rbwMultiplier = input.float(2.0, "Mult", step=0.5, group='ğŸ“Š Relative Bandwidth Filter', inline='rbw2')

// Additional Options (Row 3)
rbwUseTR = input.bool(true, "Use TR", group='ğŸ“Š Relative Bandwidth Filter', inline='rbw3')
rbwUseAltSrc = input.bool(false, "Alt Src", group='ğŸ“Š Relative Bandwidth Filter', inline='rbw3')

// Signal Configuration (Row 4)
rbwDesiredCond = input.string("Higher Bandwidth", "Condition", group='ğŸ“Š Relative Bandwidth Filter', options=["Higher Bandwidth", "Lower Bandwidth"], inline='rbw4')
rbwRefBand = input.string("Middle", "Reference", group='ğŸ“Š Relative Bandwidth Filter', options=["Upper", "Lower", "Middle"], inline='rbw4')

// ATR and Filter Settings (Row 5)
rbwATRLength = input.int(20, "ATR Len", group='ğŸ“Š Relative Bandwidth Filter', inline='rbw5')
rbwBBType = input.string("sma", "BB Type", group='ğŸ“Š Relative Bandwidth Filter', options=["sma", "ema", "hma", "rma", "wma", "vwma", "linreg", "median"], inline='rbw5')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• EXTENDED BIAS FILTERS (6 INDICATORS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Professional trend-based directional bias filters with confluence logic

// Confluence Logic (Row 1)
biasConfluence = input.string('Any', 'Confluence Mode', options=['Any', 'Majority', 'All'], group='ğŸ¯ Extended Bias Filters', inline='conf1', tooltip='Any: At least one filter agrees | Majority: Most filters agree | All: All enabled filters agree')

// â”€â”€â”€â”€â”€â”€â”€â”€ ROW 1: CORE TREND FILTERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Hull Suite Filter (Section 1)
hullEnable = input.bool(true, 'ğŸ“ˆ Hull Suite', group='ğŸ¯ Extended Bias Filters', inline='hull1')
hullLength = input.int(55, 'Length', minval=10, maxval=200, group='ğŸ¯ Extended Bias Filters', inline='hull1')
hullMode = input.string('Hma', 'Type', options=['Hma', 'Ehma', 'Thma'], group='ğŸ¯ Extended Bias Filters', inline='hull2')

// SuperTrend Filter (Section 2)
supertrendEnable = input.bool(false, 'ğŸ”¥ SuperTrend', group='ğŸ¯ Extended Bias Filters', inline='st1')
supertrendFactor = input.float(3.0, 'Factor', minval=1.0, maxval=10.0, step=0.1, group='ğŸ¯ Extended Bias Filters', inline='st1')
supertrendATR = input.int(10, 'ATR', minval=5, maxval=50, group='ğŸ¯ Extended Bias Filters', inline='st2')

// Quadrant NW Filter (Section 3)
quadrantEnable = input.bool(false, 'ğŸ“Š Quadrant NW', group='ğŸ¯ Extended Bias Filters', inline='quad1')
quadrantLookback = input.float(8.0, 'Lookback', minval=3.0, maxval=25.0, step=0.5, group='ğŸ¯ Extended Bias Filters', inline='quad1')
quadrantWeight = input.float(8.0, 'Weight', minval=1.0, maxval=20.0, step=0.25, group='ğŸ¯ Extended Bias Filters', inline='quad2')

// â”€â”€â”€â”€â”€â”€â”€â”€ ROW 2: ADVANCED TREND FILTERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Adaptive SuperTrend Filter (Section 4)
adaptiveSTEnable = input.bool(false, 'ğŸ¤– Adaptive ST', group='ğŸ¯ Extended Bias Filters', inline='ast1')
adaptiveSTLength = input.int(14, 'Length', minval=5, maxval=50, group='ğŸ¯ Extended Bias Filters', inline='ast1')
adaptiveSTFactor = input.float(2.5, 'Factor', minval=1.0, maxval=5.0, step=0.1, group='ğŸ¯ Extended Bias Filters', inline='ast2')

// Volumatic VIDYA Filter (Section 5)
volumaticEnable = input.bool(false, 'ğŸ“Š Volumatic', group='ğŸ¯ Extended Bias Filters', inline='vol1')
volumaticLength = input.int(20, 'Length', minval=5, maxval=100, group='ğŸ¯ Extended Bias Filters', inline='vol1')
volumaticAlpha = input.float(0.2, 'Alpha', minval=0.01, maxval=1.0, step=0.01, group='ğŸ¯ Extended Bias Filters', inline='vol2')

// Smoothed Heiken Ashi Filter (Section 6)
smoothHAEnable = input.bool(false, 'ğŸ•¯ï¸ Smooth HA', group='ğŸ¯ Extended Bias Filters', inline='sha1')
smoothHALength = input.int(10, 'Length', minval=3, maxval=50, group='ğŸ¯ Extended Bias Filters', inline='sha1')
smoothHAMode = input.string('EMA', 'Smooth', options=['EMA', 'SMA', 'WMA'], group='ğŸ¯ Extended Bias Filters', inline='sha2')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MULTI-TIMEFRAME ZIGZAG FILTER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Advanced trend analysis using higher timeframe ZigZag pivots

// MTF ZigZag Enable Toggle (Row 1)
mtfZigzagEnable = input.bool(false, 'ğŸ“ˆ MTF ZigZag', group='ğŸ¯ Advanced Bias Filters', inline='mtf1', tooltip='Enable Multi-Timeframe ZigZag trend analysis. Uses higher timeframe pivot analysis to detect strong trending conditions. Only uses confirmed bars (no repainting).')

// MTF ZigZag Parameters (Row 2)
mtfTimeframe = input.timeframe('60', 'MTF Timeframe', group='ğŸ¯ Advanced Bias Filters', inline='mtf2', tooltip='Higher timeframe for trend analysis. Common choices: 15 for 5m charts, 60 for 15m charts, 240 for 1H charts. Higher timeframes give stronger trend signals but slower response.')
mtfZigzagLength = input.int(21, 'ZZ Length', minval=5, group='ğŸ¯ Advanced Bias Filters', inline='mtf2', tooltip='ZigZag sensitivity. Lower values (5-10) = more sensitive, more signals. Higher values (20-50) = less sensitive, stronger trends only.')

// MTF ZigZag Advanced (Row 3)
mtfDepth = input.int(200, 'ZZ Depth', minval=50, maxval=500, step=50, group='ğŸ¯ Advanced Bias Filters', inline='mtf3', tooltip='Number of pivots to analyze. Higher values give more historical context but use more memory. 200 is good balance for most timeframes.')
mtfMinPivotAge = input.int(2, 'Min Pivot Age', minval=1, maxval=5, group='ğŸ¯ Advanced Bias Filters', inline='mtf3', tooltip='Minimum bars a pivot must be old to be considered confirmed. 2+ bars ensures no repainting.')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• REVERSAL PROBABILITY BIAS FILTER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Statistical reversal probability analysis for intelligent trend continuation
// Uses AlgoAlpha + LuxAlgo probability indicators for bias decisions

// Reversal Probability Enable Toggle (Row 1)
reversalProbEnable = input.bool(false, 'ğŸ“Š Reversal Probability', group='ğŸ¯ Probability Bias Filter', inline='prob1', tooltip='Enable reversal probability bias filter. Uses statistical analysis to determine trend continuation likelihood. LOW probability = continue trend, HIGH probability = neutral/exit bias.')
reversalProbPrimary = input.bool(false, 'â­ Primary Mode', group='ğŸ¯ Probability Bias Filter', inline='prob1', tooltip='Make reversal probability the primary bias filter. When enabled, this filter can work alone when other filters are disabled.')

// Probability Thresholds (Row 2)
reversalProbThreshold = input.float(30.0, 'Bias Threshold %', minval=10.0, maxval=90.0, step=5.0, group='ğŸ¯ Probability Bias Filter', inline='prob2', tooltip='Reversal probability threshold for bias decisions. Below this % = continue trend bias. Default 30% = conservative. Lower = more aggressive trend continuation.')
reversalExitThreshold = input.float(70.0, 'Exit Threshold %', minval=30.0, maxval=95.0, step=5.0, group='ğŸ¯ Probability Bias Filter', inline='prob2', tooltip='Reversal probability threshold for exit decisions. Above this % = consider exiting. Separate from bias threshold for independent testing.')

// Trend-Riding Integration (Row 3)
reversalProbRequiredForTrend = input.bool(false, 'ğŸš€ Required for Trend-Riding', group='ğŸ¯ Probability Bias Filter', inline='prob3', tooltip='Require LOW reversal probability for trend-riding activation. When enabled, trend-riding mode will only activate if reversal probability is below threshold.')
reversalProbWeight = input.float(1.0, 'Filter Weight', minval=0.1, maxval=3.0, step=0.1, group='ğŸ¯ Probability Bias Filter', inline='prob3', tooltip='Weight of this filter in confluence voting. 1.0 = equal weight. Higher values give this filter more influence in bias decisions.')

// Entry Probability Filter (Row 4) - NEW FEATURE
entryProbFilterEnable = input.bool(false, 'ğŸš« Entry Probability Filter', group='ğŸ¯ Probability Bias Filter', inline='prob4', tooltip='OPTIONAL: Block entries when reversal probability is too high (e.g., gap opens at extremes). Prevents entering at 84%+ reversal probability zones. OFF by default.')
entryProbFilterThreshold = input.float(84.0, 'Block Above %', minval=70.0, maxval=95.0, step=1.0, group='ğŸ¯ Probability Bias Filter', inline='prob4', tooltip='Block entries when reversal probability exceeds this threshold. 84% = AlgoAlpha extreme level. 90% = LuxAlgo 90th percentile. Protects against gap-open losses.')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND-RIDING OVERLAY SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Advanced exit system to "let winners run" in strong trending conditions

// Trend-Riding Enable Toggle (Row 1)
trendRidingEnable = input.bool(true, 'ğŸš€ Trend-Riding Mode', group='ğŸ¯ Trend-Riding System', inline='tr1', tooltip='Enable trend-riding overlay that overrides Smart Profit Locker when all filters strongly agree. Designed to "let winners run" in obvious trending conditions while preserving high win rate in other scenarios.')

// Activation Requirements (Row 2)
trendActivationMode = input.string('Majority Filters', 'Activation', options=['Majority Filters', 'All Filters', 'Custom Count'], group='ğŸ¯ Trend-Riding System', inline='tr2', tooltip='How many directional bias filters must agree to activate trend-riding mode. "All Filters" = strongest requirement, "Majority" = more frequent activation.')
trendMinFilters = input.int(4, 'Min Count', minval=2, maxval=6, group='ğŸ¯ Trend-Riding System', inline='tr2', tooltip='Minimum number of filters that must agree (only used with "Custom Count" mode). Higher numbers = stronger trends required.')

// Trend Strength Requirements (Row 3)
trendMinBars = input.int(3, 'Min Trend Bars', minval=1, maxval=10, group='ğŸ¯ Trend-Riding System', inline='tr3', tooltip='Minimum consecutive bars all filters must agree before activating trend-riding. Prevents activation on brief/false trend signals.')
trendMaxHold = input.int(50, 'Max Hold Bars', minval=10, maxval=200, group='ğŸ¯ Trend-Riding System', inline='tr3', tooltip='Maximum bars to stay in trend-riding mode regardless of trend strength. Prevents overnight risk and ensures eventual exit.')

// Activation Timing (Row 3.5) - NEW FEATURE
trendActivationTiming = input.string('After Entry Only', 'Activation Timing', options=['After Entry Only', 'Pre-Entry Detection'], group='ğŸ¯ Trend-Riding System', inline='tr3b', tooltip='AFTER ENTRY ONLY: Traditional behavior - trend-riding activates only when already in position. PRE-ENTRY DETECTION: Advanced mode - trend-riding can activate before entry when strong trend detected, allowing immediate trend-riding mode on entry.')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIGNAL-DRIVEN TREND RIDER EXIT SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Revolutionary exit system: Instead of price-based exits, use opposite signals from primary indicators

// Exit Signal Selection Header (Row 4)
trendRiderExitHeader = input.string('--- Exit Signal Source ---', 'Signal Exit Config', group='ğŸ¯ Trend-Riding System', inline='tr4', tooltip='Select which primary signals can trigger exits during trend-riding mode. When trend-riding is active, normal exits are ignored and the system waits for opposite signals from selected indicators.')

// Signal Selection Checkboxes (Row 5)
useExitSignal1 = input.bool(true, 'Exit: Sig 1', group='ğŸ¯ Trend-Riding System', inline='tr5', tooltip='Use opposite signal from Signal 1 (LuxAlgo) to exit trend-riding mode. If in long trade, waits for LuxAlgo sell signal.')
useExitSignal2 = input.bool(false, 'Exit: Sig 2', group='ğŸ¯ Trend-Riding System', inline='tr5', tooltip='Use opposite signal from Signal 2 (UTBot) to exit trend-riding mode.')
useExitSignal3 = input.bool(false, 'Exit: Sig 3', group='ğŸ¯ Trend-Riding System', inline='tr5', tooltip='Use opposite signal from Signal 3 (VIDYA) to exit trend-riding mode.')

// Additional Signal Selection (Row 6)
useExitSignal4 = input.bool(false, 'Exit: Sig 4', group='ğŸ¯ Trend-Riding System', inline='tr6', tooltip='Use opposite signal from Signal 4 (KyleAlgo) to exit trend-riding mode.')
useExitSignal5 = input.bool(false, 'Exit: Sig 5', group='ğŸ¯ Trend-Riding System', inline='tr6', tooltip='Use opposite signal from Signal 5 (Wonder) to exit trend-riding mode.')
useExitSignal6 = input.bool(false, 'Exit: Sig 6', group='ğŸ¯ Trend-Riding System', inline='tr6', tooltip='Use opposite signal from Signal 6 (Custom1) to exit trend-riding mode.')
useExitSignal7 = input.bool(false, 'Exit: Sig 7', group='ğŸ¯ Trend-Riding System', inline='tr6', tooltip='Use opposite signal from Signal 7 (Custom2) to exit trend-riding mode.')
useExitSignal8 = input.bool(false, 'Exit: Sig 8', group='ğŸ¯ Trend-Riding System', inline='tr6', tooltip='Use opposite signal from Signal 8 (Custom3) to exit trend-riding mode.')
useExitSignal9 = input.bool(false, 'Exit: Sig 9', group='ğŸ¯ Trend-Riding System', inline='tr6', tooltip='Use opposite signal from Signal 9 (Custom4) to exit trend-riding mode.')
useExitSignal10 = input.bool(false, 'Exit: Sig 10', group='ğŸ¯ Trend-Riding System', inline='tr6', tooltip='Use opposite signal from Signal 10 (Custom5) to exit trend-riding mode.')

// Confluence and Safety Settings (Row 7)
minOppositeSignals = input.int(1, 'Min Exit Signals', minval=1, maxval=10, group='ğŸ¯ Trend-Riding System', inline='tr7', tooltip='Minimum number of selected opposite signals required to trigger exit. 1 = exit on first available signal. 2+ = wait for confluence of multiple opposite signals.')
enableTrendBreakSafety = input.bool(true, 'Trend Break Safety', group='ğŸ¯ Trend-Riding System', inline='tr7', tooltip='Exit immediately if trend consensus breaks (filters no longer agree). Critical safety net to prevent being stuck in sideways markets.')

// Catastrophic Stop Safety (Row 8)
enableCatastrophicStop = input.bool(true, 'Catastrophic Stop', group='ğŸ¯ Trend-Riding System', inline='tr8', tooltip='Respect catastrophic stop-loss even during trend-riding. Uses 3x normal stop distance as final safety net.')
catastrophicStopMultiplier = input.float(3.0, 'Cat Stop Mult', minval=2.0, maxval=5.0, step=0.5, group='ğŸ¯ Trend-Riding System', inline='tr8', tooltip='Multiplier for catastrophic stop distance. 3.0 = 3x normal trailing stop distance as absolute maximum loss.')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADAPTIVE EXIT SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Impulsive move detection and rapid exit capabilities

// Impulsive Exit Enable (Row 1)
impulsiveExitEnable = input.bool(true, 'âš¡ Impulsive Exits', group='ğŸ¯ Adaptive Exit System', inline='ie1', tooltip='Enable real-time exits for impulsive reversal moves. Protects against large adverse moves that happen within a single bar.')
momentumExitEnable = input.bool(false, 'ğŸ“‰ Momentum Exits', group='ğŸ¯ Adaptive Exit System', inline='ie1', tooltip='Enable exits after consecutive adverse bars. Protects against slow bleeds where price gradually moves against position.')

// Impulsive Move Thresholds (Row 2)
impulsiveATRThreshold = input.float(2.0, 'ATR Threshold', minval=1.0, maxval=5.0, step=0.1, group='ğŸ¯ Adaptive Exit System', inline='ie2', tooltip='Bar body size threshold for impulsive move detection. 2.0 = bar body must be 2x ATR to trigger. Lower = more sensitive.')
impulsiveMaxLoss = input.float(0.5, 'Max Loss %', minval=0.1, maxval=2.0, step=0.1, group='ğŸ¯ Adaptive Exit System', inline='ie2', tooltip='Maximum percentage loss allowed within a single bar before immediate exit. 0.5% = exit if position loses more than 0.5% intrabar.')

// Volume and Momentum Confirmation (Row 3)
impulsiveVolumeMultiplier = input.float(1.5, 'Volume Mult', minval=1.0, maxval=3.0, step=0.1, group='ğŸ¯ Adaptive Exit System', inline='ie3', tooltip='Volume multiplier for impulsive move confirmation. 1.5 = volume must be 1.5x average to confirm impulsive move. Higher = more conservative.')
impulsiveVolumePeriod = input.int(20, 'Volume Period', minval=5, maxval=50, group='ğŸ¯ Adaptive Exit System', inline='ie3', tooltip='Period for volume moving average comparison. 20 = compare current volume to 20-bar SMA. Lower = more sensitive to recent volume changes.')
impulsiveMomentumBars = input.int(2, 'Momentum Bars', minval=1, maxval=5, group='ğŸ¯ Adaptive Exit System', inline='ie3', tooltip='Number of consecutive adverse bars to trigger momentum exit. 2 = exit after 2 consecutive bars against position.')

// Exit Mode Selection (Row 4)
adaptiveExitMode = input.string('Adaptive', 'Exit Mode', options=['Confirmed Only', 'Adaptive', 'Aggressive'], group='ğŸ¯ Adaptive Exit System', inline='ie4', tooltip='Exit timing mode. Confirmed Only = wait for bar close. Adaptive = real-time exits in high volatility. Aggressive = always use real-time exits.')
volatilityThreshold = input.float(1.2, 'Vol Threshold', minval=1.0, maxval=2.0, step=0.1, group='ğŸ¯ Adaptive Exit System', inline='ie4', tooltip='Volatility ratio threshold for adaptive mode. 1.2 = use real-time exits when current ATR is 1.2x average ATR.')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• EXIT INDICATOR INTEGRATION SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Advanced exit signal detection using multiple reversal indicators
// Implements hybrid exit mode to reduce profit giveback in trend-riding

// Exit Indicator Enable Toggles (Row 1)
exitIndicator1Enable = input.bool(true, 'ğŸ”„ AlgoAlpha Reversal', group='ğŸš¨ Exit Indicators', inline='exit1', tooltip='Enable AlgoAlpha Reversal Signal detection. Extremely accurate reversal signals for trend exit confirmation.')
exitIndicator2Enable = input.bool(false, 'ğŸ”„ LuxAlgo RevProb', group='ğŸš¨ Exit Indicators', inline='exit1', tooltip='Enable LuxAlgo Reversal Probability zones for exit signal detection.')
exitIndicator3Enable = input.bool(false, 'ğŸ”„ Reversal Candles', group='ğŸš¨ Exit Indicators', inline='exit1', tooltip='Enable simple reversal candlestick pattern detection.')

// External Plot Integration (Row 2) - 3 Plot Points for LuxAlgo Integration
exitPlot1Enable = input.bool(false, 'ğŸ“Š Exit Plot 1', group='ğŸš¨ Exit Indicators', inline='exit2', tooltip='Enable external exit plot 1. Connect your LuxAlgo Long Exit signal here.')
exitPlot1Source = input.source(close, 'Plot 1 Src', group='ğŸš¨ Exit Indicators', inline='exit2', tooltip='Source for external exit plot 1 (LuxAlgo Long Exit)')
exitPlot2Enable = input.bool(false, 'ğŸ“Š Exit Plot 2', group='ğŸš¨ Exit Indicators', inline='exit2', tooltip='Enable external exit plot 2. Connect your LuxAlgo Short Exit signal here.')
exitPlot2Source = input.source(close, 'Plot 2 Src', group='ğŸš¨ Exit Indicators', inline='exit2', tooltip='Source for external exit plot 2 (LuxAlgo Short Exit)')

// Additional Plot Point (Row 3)
exitPlot3Enable = input.bool(false, 'ğŸ“Š Exit Plot 3', group='ğŸš¨ Exit Indicators', inline='exit3', tooltip='Enable external exit plot 3. Additional exit signal input for custom indicators.')
exitPlot3Source = input.source(close, 'Plot 3 Src', group='ğŸš¨ Exit Indicators', inline='exit3', tooltip='Source for external exit plot 3 (Custom Exit Signal)')

// Hybrid Exit Mode Configuration (Row 4)
hybridExitEnable = input.bool(true, 'ğŸ”„ Hybrid Exit Mode', group='ğŸš¨ Exit Indicators', inline='exit4', tooltip='Enable hybrid exit mode. When exit indicators reach threshold, switch from signal-based to Smart Profit Locker mode.')
hybridExitThreshold = input.int(2, 'Exit Threshold', minval=1, maxval=5, group='ğŸš¨ Exit Indicators', inline='exit4', tooltip='Number of exit indicators required to trigger hybrid mode switch. 2 = switch to Smart Profit Locker when 2+ exit indicators trigger.')

// AlgoAlpha Reversal Signal Parameters (Row 5)
algoAlphaLookback = input.int(12, 'AA Lookback', minval=5, maxval=20, group='ğŸš¨ Exit Indicators', inline='exit5', tooltip='AlgoAlpha lookback period for reversal detection. Lower = more sensitive.')
algoAlphaConfirmation = input.int(3, 'AA Confirm', minval=1, maxval=5, group='ğŸš¨ Exit Indicators', inline='exit5', tooltip='AlgoAlpha confirmation period. Number of bars to confirm reversal signal.')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ALGOA ALPHA REVERSAL SIGNAL CALCULATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Core logic ported from AlgoAlphaReversalSignal.pine for exit detection

// AlgoAlpha Variables
var int aaBullCandleScore = 0
var int aaBearCandleScore = 0
var bool aaBullReversalCandidate = false
var bool aaBearReversalCandidate = false
var float aaBullReversalLow = 0.0
var float aaBullReversalHigh = 0.0
var float aaBearReversalLow = 0.0
var float aaBearReversalHigh = 0.0
var bool aaBullSignalConfirmed = false
var bool aaBearSignalConfirmed = false
var int aaBullCandleCounter = 0
var int aaBearCandleCounter = 0

// AlgoAlpha Signal Detection
aaVolumeIsHigh = volume > ta.sma(volume, 20)
aaBullSignal = false
aaBearSignal = false

if exitIndicator1Enable
    // Reset candle scores
    aaBullCandleScore := 0
    aaBearCandleScore := 0
    
    // Loop through the lookback period
    for i = 0 to algoAlphaLookback - 1 by 1
        if close < low[i]
            aaBullCandleScore := aaBullCandleScore + 1
        if close > high[i]
            aaBearCandleScore := aaBearCandleScore + 1
    
    // Bearish reversal detection (exit signal for long positions)
    if aaBearCandleScore == algoAlphaLookback - 1
        aaBearReversalCandidate := true
        aaBearReversalLow := low
        aaBearReversalHigh := high
        aaBearSignalConfirmed := false
        aaBearCandleCounter := 0
    
    if aaBearReversalCandidate
        aaBearCandleCounter := aaBearCandleCounter + 1
        if close > aaBearReversalHigh
            aaBearReversalCandidate := false
    
    aaBearCondition = false
    if aaBearReversalCandidate and close < aaBearReversalLow and not aaBearSignalConfirmed and aaBearCandleCounter <= algoAlphaConfirmation + 1
        aaBearSignalConfirmed := true
        aaBearCondition := true
    
    if aaBearCondition
        if aaVolumeIsHigh  // Volume confirmation
            aaBearSignal := true
    
    // Bullish reversal detection (exit signal for short positions)
    if aaBullCandleScore == algoAlphaLookback - 1
        aaBullReversalCandidate := true
        aaBullReversalLow := low
        aaBullReversalHigh := high
        aaBullSignalConfirmed := false
        aaBullCandleCounter := 0
    
    if aaBullReversalCandidate
        aaBullCandleCounter := aaBullCandleCounter + 1
        if close < aaBullReversalLow
            aaBullReversalCandidate := false
    
    aaBullCondition = false
    if aaBullReversalCandidate and close > aaBullReversalHigh and not aaBullSignalConfirmed and aaBullCandleCounter <= algoAlphaConfirmation + 1
        aaBullSignalConfirmed := true
        aaBullCondition := true
    
    if aaBullCondition
        if aaVolumeIsHigh  // Volume confirmation
            aaBullSignal := true

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• REVERSAL PROBABILITY CALCULATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Composite probability analysis using AlgoAlpha + LuxAlgo indicators
// Provides statistical likelihood of trend reversal for intelligent bias decisions

// AlgoAlpha Probability Calculation (ported from AlgoAlphaReversalProbability.pine)
var durations = array.new_int()
cut = ta.barssince(ta.cross(close, ta.ema(close, 21)))  // Simplified trend cross detection

if cut == 0 and cut != cut[1]
    durations.unshift(cut[1])

basis = durations.avg()
stdDev = durations.stdev()

// Statistical probability calculation using cumulative distribution function
f_cdf(z) =>
    a1 = 0.254829592
    a2 = -0.284496736
    a3 = 1.421413741
    a4 = -1.453152027
    a5 = 1.061405429
    p = 0.3275911
    
    sign = z < 0 ? -1 : 1
    x = math.abs(z) / math.sqrt(2)
    t = 1 / (1 + p * x)
    erf_approx = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * math.exp(-x * x)
    
    0.5 * (1 + sign * erf_approx)

z = na(stdDev) or stdDev == 0 ? 0 : (cut - basis) / stdDev
algoAlphaProbability = f_cdf(z) * 100  // Convert to percentage (0-100)

// LuxAlgo Probability Zone Estimation (simplified)
// Based on current price position relative to recent pivots
pivotHigh = ta.pivothigh(high, 10, 10)
pivotLow = ta.pivotlow(low, 10, 10)
var float lastPivotHigh = na
var float lastPivotLow = na

if not na(pivotHigh)
    lastPivotHigh := pivotHigh
if not na(pivotLow)
    lastPivotLow := pivotLow

// Estimate probability zone based on price position
pricePosition = na(lastPivotHigh) or na(lastPivotLow) ? 50 : 
  ((close - lastPivotLow) / (lastPivotHigh - lastPivotLow)) * 100

// Convert to probability zones (25%, 50%, 75%, 90%)
luxAlgoProbabilityZone = 
  pricePosition > 90 ? 90 :
  pricePosition > 75 ? 75 :
  pricePosition > 50 ? 50 : 25

// Composite Reversal Probability (weighted average)
compositeProbability = reversalProbEnable ? 
  (algoAlphaProbability * 0.6 + luxAlgoProbabilityZone * 0.4) : 50

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ENTRY PROBABILITY FILTER â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NEW FEATURE: Block entries at extreme reversal probability levels
// Prevents entering trades at gap opens or other extreme reversal zones

// Entry Probability Filter Logic
entryProbabilityOK = entryProbFilterEnable ? 
  (compositeProbability <= entryProbFilterThreshold) : true  // Block entries above threshold

// Debug output for Entry Probability Filter
if entryProbFilterEnable and not entryProbabilityOK
    debugInfo("ğŸš« ENTRY BLOCKED: Reversal probability " + str.tostring(compositeProbability, "#.#") + "% exceeds threshold " + str.tostring(entryProbFilterThreshold, "#.#") + "%")

// Reversal Probability Bias Logic
reversalProbLongBias = reversalProbEnable ? 
  (compositeProbability < reversalProbThreshold) : true  // Low probability = continue long trend
reversalProbShortBias = reversalProbEnable ? 
  (compositeProbability < reversalProbThreshold) : true  // Low probability = continue short trend

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• EXIT INDICATOR VOTING SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Hybrid exit mode: count exit indicators and switch to Smart Profit Locker

// External Plot Signal Detection (for LuxAlgo integration)
exitPlot1LongSignal = exitPlot1Enable and exitPlot1Source > exitPlot1Source[1]  // Rising signal = long exit
exitPlot1ShortSignal = exitPlot1Enable and exitPlot1Source < exitPlot1Source[1]  // Falling signal = short exit
exitPlot2LongSignal = exitPlot2Enable and exitPlot2Source > exitPlot2Source[1]  // Rising signal = long exit  
exitPlot2ShortSignal = exitPlot2Enable and exitPlot2Source < exitPlot2Source[1]  // Falling signal = short exit
exitPlot3LongSignal = exitPlot3Enable and exitPlot3Source > exitPlot3Source[1]  // Rising signal = long exit
exitPlot3ShortSignal = exitPlot3Enable and exitPlot3Source < exitPlot3Source[1]  // Falling signal = short exit
// Simple Reversal Candle Detection (basic implementation)
reversalCandleBull = exitIndicator3Enable and (close > open and close[1] < open[1] and close > high[1])  // Bullish engulfing
reversalCandleBear = exitIndicator3Enable and (close < open and close[1] > open[1] and close < low[1])   // Bearish engulfing

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• WEIGHTED EXIT SIGNAL COUNTING SYSTEM (CRITICAL FIX) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRITICAL FIX: Replace binary counting with weighted signal strength analysis
// This fixes the bug where all signals were weighted equally regardless of strength

// Signal Weight Definitions (based on reliability and strength)
aaSignalWeight = 2.0      // AlgoAlpha: High reliability, volume-confirmed reversal signals
externalPlotWeight = 1.5  // External plots: Medium-high reliability (LuxAlgo, etc.)
reversalCandleWeight = 0.8 // Reversal candles: Lower reliability, basic pattern recognition

// CRITICAL FIX: Declare variables before usage to prevent undeclared identifier errors
averageATR = math.max(ta.sma(atrVal, 50), 0.0001)  // Division by zero protection
volatilityRatio = atrVal / averageATR

// Declare smartDistance as a global variable for use across exit systems
var float smartDistance = na

// Market Context Multipliers (enhance signal quality based on conditions)
// Note: bullishVotes and bearishVotes will be calculated later in the directional bias section
volatilityMultiplier = volatilityRatio > 1.5 ? 1.2 : volatilityRatio < 0.8 ? 0.9 : 1.0
// Temporary trendStrengthMultiplier (will be recalculated later with proper votes)
trendStrengthMultiplier = 1.0  // Default neutral multiplier

// Calculate Weighted Exit Signal Strength for Long Positions (bearish exit signals)
longExitSignalCount = 0.0
if aaBearSignal
    aaStrength = aaVolumeIsHigh ? aaSignalWeight * 1.2 : aaSignalWeight * 0.9  // Volume confirmation bonus
    longExitSignalCount := longExitSignalCount + (aaStrength * volatilityMultiplier)
if exitPlot1LongSignal
    longExitSignalCount := longExitSignalCount + (externalPlotWeight * trendStrengthMultiplier)
if exitPlot2LongSignal
    longExitSignalCount := longExitSignalCount + (externalPlotWeight * trendStrengthMultiplier)
if exitPlot3LongSignal
    longExitSignalCount := longExitSignalCount + (externalPlotWeight * trendStrengthMultiplier)
if reversalCandleBear
    candleStrength = math.abs(close - open) / atrVal  // Candle body size relative to ATR
    weightedCandleSignal = reversalCandleWeight * math.min(candleStrength, 2.0)  // Cap at 2x weight
    longExitSignalCount := longExitSignalCount + weightedCandleSignal

// Calculate Weighted Exit Signal Strength for Short Positions (bullish exit signals)
shortExitSignalCount = 0.0
if aaBullSignal
    aaStrength = aaVolumeIsHigh ? aaSignalWeight * 1.2 : aaSignalWeight * 0.9  // Volume confirmation bonus
    shortExitSignalCount := shortExitSignalCount + (aaStrength * volatilityMultiplier)
if exitPlot1ShortSignal
    shortExitSignalCount := shortExitSignalCount + (externalPlotWeight * trendStrengthMultiplier)
if exitPlot2ShortSignal
    shortExitSignalCount := shortExitSignalCount + (externalPlotWeight * trendStrengthMultiplier)
if exitPlot3ShortSignal
    shortExitSignalCount := shortExitSignalCount + (externalPlotWeight * trendStrengthMultiplier)
if reversalCandleBull
    candleStrength = math.abs(close - open) / atrVal  // Candle body size relative to ATR
    weightedCandleSignal = reversalCandleWeight * math.min(candleStrength, 2.0)  // Cap at 2x weight
    shortExitSignalCount := shortExitSignalCount + weightedCandleSignal

// Enhanced Hybrid Exit Mode Trigger Detection
// Combines binary signal counting with reversal probability analysis
probabilityExitTriggered = reversalProbEnable and compositeProbability >= reversalExitThreshold

// Multiple trigger modes:
// 1. Binary signals only (original logic)
// 2. Probability only (new statistical approach) 
// 3. Combined mode (signals + probability confirmation)
binaryExitTriggeredLong = hybridExitEnable and longExitSignalCount >= hybridExitThreshold
binaryExitTriggeredShort = hybridExitEnable and shortExitSignalCount >= hybridExitThreshold

// Final hybrid exit decision (enhanced logic)
hybridExitTriggeredLong = binaryExitTriggeredLong or (reversalProbEnable and probabilityExitTriggered)
hybridExitTriggeredShort = binaryExitTriggeredShort or (reversalProbEnable and probabilityExitTriggered)

// Activate Hybrid Exit Mode
if not inHybridExitMode and strategy.position_size != 0
    if (strategy.position_size > 0 and hybridExitTriggeredLong) or (strategy.position_size < 0 and hybridExitTriggeredShort)
        inHybridExitMode := true
        hybridModeStartBar := bar_index
        if debugEnabled
            exitSignalType = strategy.position_size > 0 ? "Long" : "Short"
            signalCount = strategy.position_size > 0 ? longExitSignalCount : shortExitSignalCount
            binaryTriggered = strategy.position_size > 0 ? binaryExitTriggeredLong : binaryExitTriggeredShort
            probTriggered = probabilityExitTriggered
            triggerReason = binaryTriggered and probTriggered ? "Signals+Probability" : 
                           binaryTriggered ? "Binary Signals" : "Probability Only"
            probInfo = reversalProbEnable ? (" | RevProb: " + str.tostring(compositeProbability, "#.#") + "% (" + str.tostring(reversalExitThreshold, "#.#") + "% threshold)") : ""
            debugInfo("ğŸ”„ HYBRID EXIT: Activated for " + exitSignalType + " position. Trigger: " + triggerReason + " | Signals: " + str.tostring(signalCount) + "/" + str.tostring(hybridExitThreshold) + probInfo)

// Deactivate Hybrid Exit Mode (when position closes)
if inHybridExitMode and strategy.position_size == 0
    inHybridExitMode := false
    if debugEnabled
        barsInHybrid = bar_index - hybridModeStartBar
        debugInfo("ğŸ”„ HYBRID EXIT: Deactivated. Duration: " + str.tostring(barsInHybrid) + " bars")

// RBW Calculation Logic - Variable Declarations
var float rbwUpper = na
var float rbwLower = na
var float rbwMiddle = na
var float rbwRelativeBandwidth = na
var int rbwSignal = 0
var float rbwBBMiddle = na
var float rbwBBUpper = na
var float rbwBBLower = na
var float rbwRef = na
var float rbwStdDev = na
var float rbwATR = na

if rbwEnable
    // Bollinger Bands
    if rbwBandType == "BB"
        rbwMiddle := ta.sma(rbwSource, rbwLength)
        rbwStdDev := ta.stdev(rbwSource, rbwLength)
        rbwUpper := rbwMiddle + rbwStdDev * rbwMultiplier
        rbwLower := rbwMiddle - rbwStdDev * rbwMultiplier
    
    // Keltner Channels  
    else if rbwBandType == "KC"
        rbwMiddle := ta.sma(rbwSource, rbwLength)
        rbwATR := rbwUseTR ? ta.atr(rbwLength) : ta.rma(high - low, rbwLength)
        rbwUpper := rbwMiddle + rbwATR * rbwMultiplier
        rbwLower := rbwMiddle - rbwATR * rbwMultiplier
    
    // Donchian Channels
    else if rbwBandType == "DC"
        rbwUpper := ta.highest(rbwUseAltSrc ? high : rbwSource, rbwLength)
        rbwLower := ta.lowest(rbwUseAltSrc ? low : rbwSource, rbwLength)
        rbwMiddle := (rbwUpper + rbwLower) / 2

    // Relative Bandwidth calculation (DIVISION BY ZERO FIX)
    if not na(rbwUpper) and not na(rbwLower)
        rbwATR := ta.atr(rbwATRLength)
        // CRITICAL FIX: Comprehensive protection against division by zero
        if not na(rbwATR) and rbwATR > 0.0001  // Increased minimum threshold
            rbwRelativeBandwidth := (rbwUpper - rbwLower) / rbwATR
        else
            // Fallback: Use normalized bandwidth when ATR is invalid
            rbwRelativeBandwidth := na(rbwUpper - rbwLower) ? 0.0 : math.abs(rbwUpper - rbwLower) * 100
        
        // CRITICAL FIX: Move signal calculation outside the else block so it always executes
        // Calculate reference bands for signal
        rbwBBMiddle := ta.sma(rbwRelativeBandwidth, 100)
        rbwBBUpper := rbwBBMiddle + ta.stdev(rbwRelativeBandwidth, 100) * 1.0
        rbwBBLower := rbwBBMiddle - ta.stdev(rbwRelativeBandwidth, 100) * 1.0
        
        rbwRef := rbwRefBand == "Middle" ? rbwBBMiddle : rbwRefBand == "Upper" ? rbwBBUpper : rbwBBLower
        rbwSignal := rbwRelativeBandwidth > rbwRef ? 2 : 0
        rbwSignal := rbwDesiredCond == "Lower Bandwidth" ? math.abs(rbwSignal-2) : rbwSignal

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HULL SUITE CALCULATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Hull Moving Average trend detection

// Hull MA calculation functions (must be defined outside conditional blocks)
HMA(src, length) =>
    ta.wma(2 * ta.wma(src, length / 2) - ta.wma(src, length), math.round(math.sqrt(length)))

EHMA(src, length) =>
    ta.ema(2 * ta.ema(src, length / 2) - ta.ema(src, length), math.round(math.sqrt(length)))

THMA(src, length) =>
    ta.wma(ta.wma(src, length / 3) * 3 - ta.wma(src, length / 2) - ta.wma(src, length), length)

var float hullMA = na
var bool hullBullish = false

if hullEnable
    // Calculate Hull MA based on selected mode (THMA LENGTH BUG FIX)
    // CRITICAL FIX: THMA should use full hullLength, not divided by 2
    hullMA := hullMode == 'Hma' ? HMA(close, hullLength) : hullMode == 'Ehma' ? EHMA(close, hullLength) : hullMode == 'Thma' ? THMA(close, hullLength) : na
    
    // Determine trend direction (current > 2 bars ago = bullish)
    hullBullish := not na(hullMA) and hullMA > hullMA[2]
else
    // When disabled, set neutral (allow all trades)
    hullBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SUPERTREND CALCULATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SuperTrend directional bias
var float supertrend = na
var float supertrendDirection = na
var bool supertrendBullish = false

if supertrendEnable
    [st, dir] = ta.supertrend(supertrendFactor, supertrendATR)
    supertrend := st
    supertrendDirection := dir
    
    // CRITICAL FIX: SuperTrend Direction Logic Verification
    // Pine Script ta.supertrend() returns:
    // dir = 1 when price is BELOW SuperTrend (bearish/downtrend)
    // dir = -1 when price is ABOVE SuperTrend (bullish/uptrend)
    // Therefore: bullish when dir < 0 (dir = -1) is CORRECT
    supertrendBullish := dir < 0  // Verified: Uptrend when direction = -1
else
    // When disabled, set neutral (allow all trades)
    supertrendBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• QUADRANT (NADARAYA-WATSON) CALCULATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Rational Quadratic Kernel regression for trend detection

// Kernel regression function (must be defined outside conditional blocks)
kernel_regression(src, h, r) =>
    float currentWeight = 0.0
    float cumulativeWeight = 0.0
    int size = math.min(25, bar_index)  // Limit lookback for performance
    
    for i = 0 to size
        y = src[i]
        w = math.pow(1 + math.pow(i, 2) / (math.pow(h, 2) * 2 * r), -r)
        currentWeight := currentWeight + y * w
        cumulativeWeight := cumulativeWeight + w
    
    cumulativeWeight > 0 ? currentWeight / cumulativeWeight : src

var float quadrantEstimate = na
var bool quadrantBullish = false

if quadrantEnable
    // Calculate kernel estimate
    quadrantEstimate := kernel_regression(close, quadrantLookback, quadrantWeight)
    
    // Determine trend direction
    quadrantBullish := not na(quadrantEstimate) and quadrantEstimate > quadrantEstimate[1]
else
    // When disabled, set neutral (allow all trades)
    quadrantBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MULTI-TIMEFRAME ZIGZAG CALCULATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Simplified MTF ZigZag for directional bias (confirmed bars only)

// Simplified ZigZag calculation for directional bias
simple_zigzag(src, length) =>
    var float zz_high = na
    var float zz_low = na
    var int trend = 0
    var float last_pivot = na
    
    // Calculate pivot highs and lows (confirmed only)
    pivot_high = ta.pivothigh(src, length, length)
    pivot_low = ta.pivotlow(src, length, length)
    
    // Update ZigZag points and trend direction
    if not na(pivot_high) and (na(last_pivot) or pivot_high != last_pivot)
        zz_high := pivot_high
        last_pivot := pivot_high
        trend := 1  // Uptrend (higher high)
    
    if not na(pivot_low) and (na(last_pivot) or pivot_low != last_pivot)
        zz_low := pivot_low
        last_pivot := pivot_low
        trend := -1  // Downtrend (lower low)
    
    [zz_high, zz_low, trend]

var float mtfZigzagHigh = na
var float mtfZigzagLow = na
var int mtfZigzagTrend = 0
var bool mtfZigzagBullish = false

// CRITICAL FIX: Declare zigzag variables before usage
var float zz_h = na
var float zz_l = na
var int zz_trend = 0

if mtfZigzagEnable
    // CRITICAL FIX: Enhanced Anti-Repainting Protection for MTF ZigZag
    // Use additional offset and confirmation to eliminate repainting risk
    [htf_high, htf_low, htf_close] = request.security(syminfo.tickerid, mtfTimeframe, [high[2], low[2], close[2]], lookahead=barmerge.lookahead_off)
    
    // Additional confirmation: Only update on confirmed higher timeframe bar close
    htf_bar_time = request.security(syminfo.tickerid, mtfTimeframe, time[2], lookahead=barmerge.lookahead_off)
    var float last_htf_time = na
    htf_bar_confirmed = na(last_htf_time) or htf_bar_time != last_htf_time
    
    if htf_bar_confirmed
        last_htf_time := htf_bar_time
        // Calculate ZigZag on higher timeframe using confirmed data only
        [zz_h, zz_l, zz_trend] = simple_zigzag(htf_high, mtfZigzagLength)
    
    // Update ZigZag values when new pivots are detected
    if not na(zz_h)
        mtfZigzagHigh := zz_h
        mtfZigzagTrend := zz_trend
    
    if not na(zz_l)
        mtfZigzagLow := zz_l
        mtfZigzagTrend := zz_trend
    
    // Determine trend direction - simplified logic
    // Bullish if trend is up (1), bearish if trend is down (-1)
    mtfZigzagBullish := mtfZigzagTrend == 1
else
    // When disabled, set neutral values
    mtfZigzagBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADVANCED TREND INDICATORS (INTERNAL CALCULATIONS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Adaptive SuperTrend Calculation (K-Means Inspired)
var bool adaptiveSTBullish = false
var float adaptiveST = na
var int adaptiveSTDirection = 1

if adaptiveSTEnable
    // Enhanced SuperTrend with adaptive ATR multiplier
    atr = ta.atr(adaptiveSTLength)
    hl2_ma = ta.ema(hl2, adaptiveSTLength)
    
    // Adaptive factor based on volatility clustering
    volatility = ta.stdev(close, adaptiveSTLength) / ta.sma(close, adaptiveSTLength)
    adaptiveFactor = adaptiveSTFactor * (1 + volatility)
    
    // Calculate adaptive SuperTrend bands
    upper_band = hl2_ma + (adaptiveFactor * atr)
    lower_band = hl2_ma - (adaptiveFactor * atr)
    
    // SuperTrend logic with adaptive bands
    prev_upper = nz(upper_band[1], upper_band)
    prev_lower = nz(lower_band[1], lower_band)
    
    upper_band := close[1] > prev_upper ? math.max(upper_band, prev_upper) : upper_band
    lower_band := close[1] < prev_lower ? math.min(lower_band, prev_lower) : lower_band
    
    // Determine trend direction
    adaptiveSTDirection := close <= lower_band[1] ? 1 : close >= upper_band[1] ? -1 : nz(adaptiveSTDirection[1], 1)
    adaptiveST := adaptiveSTDirection == 1 ? lower_band : upper_band
    
    // Bullish when price is above adaptive SuperTrend
    adaptiveSTBullish := adaptiveSTDirection == -1
else
    adaptiveSTBullish := false

// Volumatic VIDYA Calculation (Volume-Weighted Dynamic Average)
var bool volumaticBullish = false
var float volumaticVIDYA = na

if volumaticEnable
    // Calculate Chande Momentum Oscillator for VIDYA
    cmo_up = math.max(close - close[1], 0)
    cmo_down = math.max(close[1] - close, 0)
    cmo_sum_up = ta.sma(cmo_up, volumaticLength)
    cmo_sum_down = ta.sma(cmo_down, volumaticLength)
    cmo = (cmo_sum_up - cmo_sum_down) / (cmo_sum_up + cmo_sum_down)
    
    // Volume-weighted alpha calculation
    vol_ratio = volume / ta.sma(volume, volumaticLength)
    dynamic_alpha = math.abs(cmo) * volumaticAlpha * vol_ratio
    dynamic_alpha := math.min(dynamic_alpha, 1.0)  // Cap at 1.0
    
    // VIDYA calculation
    volumaticVIDYA := na(volumaticVIDYA[1]) ? close : volumaticVIDYA[1] + dynamic_alpha * (close - volumaticVIDYA[1])
    
    // Bullish when price is above VIDYA and VIDYA is rising
    volumaticBullish := close > volumaticVIDYA and volumaticVIDYA > volumaticVIDYA[2]
else
    volumaticBullish := false

// Smoothed Heiken Ashi Calculation (Enhanced)
var bool smoothHABullish = false
var float haOpen = na

if smoothHAEnable
    // Enhanced HA calculation with multiple smoothing options
    haClose = (open + high + low + close) / 4
    haOpen := na(haOpen[1]) ? (open + close) / 2 : (haOpen[1] + haClose[1]) / 2
    haHigh = math.max(high, math.max(haOpen, haClose))
    haLow = math.min(low, math.min(haOpen, haClose))
    
    // Apply selected smoothing method
    smoothHAClose = smoothHAMode == 'EMA' ? ta.ema(haClose, smoothHALength) : 
                   smoothHAMode == 'SMA' ? ta.sma(haClose, smoothHALength) : 
                   ta.wma(haClose, smoothHALength)
    
    smoothHAOpen = smoothHAMode == 'EMA' ? ta.ema(haOpen, smoothHALength) : 
                  smoothHAMode == 'SMA' ? ta.sma(haOpen, smoothHALength) : 
                  ta.wma(haOpen, smoothHALength)
    
    // Enhanced trend detection with momentum confirmation
    ha_trend = smoothHAClose > smoothHAOpen
    ha_momentum = smoothHAClose > smoothHAClose[1] and smoothHAOpen > smoothHAOpen[1]
    
    // Bullish when both trend and momentum align
    smoothHABullish := ha_trend and ha_momentum
else
    smoothHABullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DIRECTIONAL BIAS INTEGRATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Apply directional bias filters to entry signals with confluence logic

// Individual Filter Bias Logic (Fixed: disabled filters don't vote)
rbwLongBias = rbwEnable ? (rbwSignal == 2) : true  // If enabled: bullish signal required. If disabled: allow all
rbwShortBias = rbwEnable ? (rbwSignal == 0) : true  // If enabled: bearish signal required. If disabled: allow all

hullLongBias = hullEnable ? hullBullish : true  // If enabled: bullish trend required. If disabled: allow all
hullShortBias = hullEnable ? (not hullBullish) : true  // If enabled: bearish trend required. If disabled: allow all

supertrendLongBias = supertrendEnable ? supertrendBullish : true  // If enabled: bullish trend required. If disabled: allow all
supertrendShortBias = supertrendEnable ? (not supertrendBullish) : true  // If enabled: bearish trend required. If disabled: allow all

quadrantLongBias = quadrantEnable ? quadrantBullish : true  // If enabled: bullish trend required. If disabled: allow all
quadrantShortBias = quadrantEnable ? (not quadrantBullish) : true  // If enabled: bearish trend required. If disabled: allow all

mtfZigzagLongBias = mtfZigzagEnable ? mtfZigzagBullish : true  // If enabled: bullish trend required. If disabled: allow all
mtfZigzagShortBias = mtfZigzagEnable ? (not mtfZigzagBullish) : true  // If enabled: bearish trend required. If disabled: allow all

adaptiveSTLongBias = adaptiveSTEnable ? adaptiveSTBullish : true  // If enabled: bullish trend required. If disabled: allow all
adaptiveSTShortBias = adaptiveSTEnable ? (not adaptiveSTBullish) : true  // If enabled: bearish trend required. If disabled: allow all

volumaticLongBias = volumaticEnable ? volumaticBullish : true  // If enabled: bullish trend required. If disabled: allow all
volumaticShortBias = volumaticEnable ? (not volumaticBullish) : true  // If enabled: bearish trend required. If disabled: allow all

smoothHALongBias = smoothHAEnable ? smoothHABullish : true  // If enabled: bullish trend required. If disabled: allow all
smoothHAShortBias = smoothHAEnable ? (not smoothHABullish) : true  // If enabled: bearish trend required. If disabled: allow all

// Reversal Probability Bias Logic (6th Filter)
// Note: reversalProbLongBias/reversalProbShortBias already calculated above

// Confluence Logic Implementation - FIXED WEIGHTED VOTING BUG
// CRITICAL FIX: Use consistent decimal weighting instead of math.round() to prevent unbalanced voting
// This fixes the bug where math.round() created inconsistent filter weights

// Count enabled filters with proper decimal weighting (BUG FIX)
enabledFilters = (rbwEnable ? 1.0 : 0.0) + (hullEnable ? 1.0 : 0.0) + (supertrendEnable ? 1.0 : 0.0) + (quadrantEnable ? 1.0 : 0.0) + (mtfZigzagEnable ? 1.0 : 0.0) + (reversalProbEnable ? reversalProbWeight : 0.0) + (adaptiveSTEnable ? 1.0 : 0.0) + (volumaticEnable ? 1.0 : 0.0) + (smoothHAEnable ? 1.0 : 0.0)

// Count bullish votes with consistent decimal weighting (BUG FIX)
bullishVotes = (rbwEnable and rbwSignal == 2 ? 1.0 : 0.0) + 
              (hullEnable and hullBullish ? 1.0 : 0.0) + 
              (supertrendEnable and supertrendBullish ? 1.0 : 0.0) + 
              (quadrantEnable and quadrantBullish ? 1.0 : 0.0) + 
              (mtfZigzagEnable and mtfZigzagBullish ? 1.0 : 0.0) +
              (reversalProbEnable and reversalProbLongBias ? reversalProbWeight : 0.0) +
              (adaptiveSTEnable and adaptiveSTBullish ? 1.0 : 0.0) +
              (volumaticEnable and volumaticBullish ? 1.0 : 0.0) +
              (smoothHAEnable and smoothHABullish ? 1.0 : 0.0)

// Count bearish votes with consistent decimal weighting (BUG FIX)
bearishVotes = (rbwEnable and rbwSignal == 0 ? 1.0 : 0.0) + 
              (hullEnable and not hullBullish ? 1.0 : 0.0) + 
              (supertrendEnable and not supertrendBullish ? 1.0 : 0.0) + 
              (quadrantEnable and not quadrantBullish ? 1.0 : 0.0) + 
              (mtfZigzagEnable and not mtfZigzagBullish ? 1.0 : 0.0) +
              (reversalProbEnable and reversalProbShortBias ? reversalProbWeight : 0.0) +
              (adaptiveSTEnable and not adaptiveSTBullish ? 1.0 : 0.0) +
              (volumaticEnable and not volumaticBullish ? 1.0 : 0.0) +
              (smoothHAEnable and not smoothHABullish ? 1.0 : 0.0)

// Calculate trend strength multiplier now that votes are available
trendStrengthMultiplier := math.max(bullishVotes, bearishVotes) >= 3 ? 1.1 : 0.95

// Apply confluence mode - SIMPLIFIED LOGIC
longDirectionalBias = enabledFilters == 0 ? true :  // No filters = allow all
  biasConfluence == 'Any' ? bullishVotes > 0 :  // At least one bullish vote
  biasConfluence == 'Majority' ? bullishVotes >= math.ceil(enabledFilters / 2.0) :  // Majority bullish
  biasConfluence == 'All' ? bullishVotes == enabledFilters : false  // All filters bullish

shortDirectionalBias = enabledFilters == 0 ? true :  // No filters = allow all
  biasConfluence == 'Any' ? bearishVotes > 0 :  // At least one bearish vote
  biasConfluence == 'Majority' ? bearishVotes >= math.ceil(enabledFilters / 2.0) :  // Majority bearish
  biasConfluence == 'All' ? bearishVotes == enabledFilters : false  // All filters bearish

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND-RIDING OVERLAY LOGIC â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Advanced exit system to "let winners run" in strong trending conditions

// Variables are now declared at the top of the script to avoid scope issues

// Calculate trend strength for activation
trendStrengthScore = math.max(bullishVotes, bearishVotes)  // Score based on number of agreeing filters

// Determine if trend-riding should activate
trendActivationThreshold = trendActivationMode == 'All Filters' ? enabledFilters : 
  trendActivationMode == 'Majority Filters' ? math.ceil(enabledFilters / 2.0) : trendMinFilters

// Check for trend-riding activation conditions
// Enhanced with optional reversal probability requirement
reversalProbOK = reversalProbRequiredForTrend ? (compositeProbability < reversalProbThreshold) : true

strongTrendDetected = enabledFilters > 0 and 
  (bullishVotes >= trendActivationThreshold or bearishVotes >= trendActivationThreshold) and
  reversalProbOK  // Optional: require low reversal probability for trend activation

// Track consecutive bars of strong trend
if strongTrendDetected
    trendRidingBarsActive := trendRidingBarsActive + 1
else
    trendRidingBarsActive := 0

// Activate trend-riding mode
if trendRidingEnable and not inTrendRidingMode and trendRidingBarsActive >= trendMinBars and (trendActivationTiming == 'After Entry Only' or strategy.position_size != 0)
    inTrendRidingMode := true
    trendRidingStartBar := bar_index
    probInfo = reversalProbRequiredForTrend ? (" | RevProb: " + str.tostring(compositeProbability, "#.#") + "%") : ""
    debugInfo("ğŸš€ Trend-Riding Mode ACTIVATED - Bar: " + str.tostring(bar_index) + ", Filters: " + str.tostring(trendStrengthScore) + probInfo)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIGNAL-DRIVEN TREND RIDER EXIT LOGIC â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Revolutionary exit system: Replace price-based exits with signal-based exits

// Count available opposite signals for exit
oppositeSignalsCount = 0
trendRiderLongExit = false
trendRiderShortExit = false

// Enhanced exit signal detection with usage settings integration
// Uses raw signals for exit-configured signals, processed signals for others

// Helper function to get appropriate signal based on usage
getExitSignal(bool rawLong, bool rawShort, bool processedLong, bool processedShort, string usage, bool isLongPosition) =>
    var bool exitSignal = false
    
    if usage == 'Exit All'
        exitSignal := isLongPosition ? rawShort : rawLong  // Use raw signals for exit-only signals
    else if usage == 'Exit Long Only'
        exitSignal := isLongPosition ? rawShort : false   // Only exit long positions
    else if usage == 'Exit Short Only'
        exitSignal := isLongPosition ? false : rawLong    // Only exit short positions
    else
        exitSignal := isLongPosition ? processedShort : processedLong  // Use processed signals for entry signals
    
    exitSignal

// Check for opposite signals (enhanced with usage settings)
if useExitSignal1 and signal1Enable
    if strategy.position_size > 0 and getExitSignal(rawSig1Long, rawSig1Short, sig1Long, sig1Short, signal1Usage, true)
        oppositeSignalsCount := oppositeSignalsCount + 1
    if strategy.position_size < 0 and getExitSignal(rawSig1Long, rawSig1Short, sig1Long, sig1Short, signal1Usage, false)
        oppositeSignalsCount := oppositeSignalsCount + 1

if useExitSignal2 and signal2Enable
    if strategy.position_size > 0 and getExitSignal(rawSig2Long, rawSig2Short, sig2Long, sig2Short, signal2Usage, true)
        oppositeSignalsCount := oppositeSignalsCount + 1
    if strategy.position_size < 0 and getExitSignal(rawSig2Long, rawSig2Short, sig2Long, sig2Short, signal2Usage, false)
        oppositeSignalsCount := oppositeSignalsCount + 1

if useExitSignal3 and signal3Enable
    if strategy.position_size > 0 and getExitSignal(rawSig3Long, rawSig3Short, sig3Long, sig3Short, signal3Usage, true)
        oppositeSignalsCount := oppositeSignalsCount + 1
    if strategy.position_size < 0 and getExitSignal(rawSig3Long, rawSig3Short, sig3Long, sig3Short, signal3Usage, false)
        oppositeSignalsCount := oppositeSignalsCount + 1

if useExitSignal4 and signal4Enable
    if strategy.position_size > 0 and getExitSignal(rawSig4Long, rawSig4Short, sig4Long, sig4Short, signal4Usage, true)
        oppositeSignalsCount := oppositeSignalsCount + 1
    if strategy.position_size < 0 and getExitSignal(rawSig4Long, rawSig4Short, sig4Long, sig4Short, signal4Usage, false)
        oppositeSignalsCount := oppositeSignalsCount + 1

if useExitSignal5 and signal5Enable
    if strategy.position_size > 0 and getExitSignal(rawSig5Long, rawSig5Short, sig5Long, sig5Short, signal5Usage, true)
        oppositeSignalsCount := oppositeSignalsCount + 1
    if strategy.position_size < 0 and getExitSignal(rawSig5Long, rawSig5Short, sig5Long, sig5Short, signal5Usage, false)
        oppositeSignalsCount := oppositeSignalsCount + 1

if useExitSignal6 and signal6Enable
    if strategy.position_size > 0 and getExitSignal(rawSig6Long, rawSig6Short, sig6Long, sig6Short, signal6Usage, true)
        oppositeSignalsCount := oppositeSignalsCount + 1
    if strategy.position_size < 0 and getExitSignal(rawSig6Long, rawSig6Short, sig6Long, sig6Short, signal6Usage, false)
        oppositeSignalsCount := oppositeSignalsCount + 1

if useExitSignal7 and signal7Enable
    if strategy.position_size > 0 and getExitSignal(rawSig7Long, rawSig7Short, sig7Long, sig7Short, signal7Usage, true)
        oppositeSignalsCount := oppositeSignalsCount + 1
    if strategy.position_size < 0 and getExitSignal(rawSig7Long, rawSig7Short, sig7Long, sig7Short, signal7Usage, false)
        oppositeSignalsCount := oppositeSignalsCount + 1

if useExitSignal8 and signal8Enable
    if strategy.position_size > 0 and getExitSignal(rawSig8Long, rawSig8Short, sig8Long, sig8Short, signal8Usage, true)
        oppositeSignalsCount := oppositeSignalsCount + 1
    if strategy.position_size < 0 and getExitSignal(rawSig8Long, rawSig8Short, sig8Long, sig8Short, signal8Usage, false)
        oppositeSignalsCount := oppositeSignalsCount + 1

if useExitSignal9 and signal9Enable
    if strategy.position_size > 0 and getExitSignal(rawSig9Long, rawSig9Short, sig9Long, sig9Short, signal9Usage, true)
        oppositeSignalsCount := oppositeSignalsCount + 1
    if strategy.position_size < 0 and getExitSignal(rawSig9Long, rawSig9Short, sig9Long, sig9Short, signal9Usage, false)
        oppositeSignalsCount := oppositeSignalsCount + 1

if useExitSignal10 and signal10Enable
    if strategy.position_size > 0 and getExitSignal(rawSig10Long, rawSig10Short, sig10Long, sig10Short, signal10Usage, true)
        oppositeSignalsCount := oppositeSignalsCount + 1
    if strategy.position_size < 0 and getExitSignal(rawSig10Long, rawSig10Short, sig10Long, sig10Short, signal10Usage, false)
        oppositeSignalsCount := oppositeSignalsCount + 1

// Determine if enough opposite signals are present
signalBasedExitTriggered = oppositeSignalsCount >= minOppositeSignals

// Set specific exit flags for long/short
if strategy.position_size > 0
    trendRiderLongExit := signalBasedExitTriggered
if strategy.position_size < 0
    trendRiderShortExit := signalBasedExitTriggered

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND RIDER SAFETY NETS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Critical safety mechanisms to prevent being stuck in bad trades

// Safety Net 1: Trend Break Detection
trendBreakSafetyTriggered = false
if enableTrendBreakSafety and inTrendRidingMode
    // Check if trend consensus has broken
    trendConsensusBroken = not strongTrendDetected
    if trendConsensusBroken
        trendBreakSafetyTriggered := true
        debugWarn("âš ï¸ Trend Break Safety: Consensus lost, exiting trend-riding mode")

// Safety Net 2: Maximum Hold Duration
maxHoldSafetyTriggered = false
if inTrendRidingMode and bar_index - trendRidingStartBar >= trendMaxHold
    maxHoldSafetyTriggered := true
    debugWarn("âš ï¸ Max Hold Safety: " + str.tostring(trendMaxHold) + " bars reached, forcing exit")

// Safety Net 3: Catastrophic Stop Loss
catastrophicStopTriggered = false
if enableCatastrophicStop and strategy.position_size != 0
    // Calculate catastrophic stop distance
    normalStopDistance = atrVal * 3.1  // Normal Smart Profit Locker distance
    catastrophicStopDistance = normalStopDistance * catastrophicStopMultiplier
    
    if strategy.position_size > 0
        catastrophicStopPrice = strategy.position_avg_price - catastrophicStopDistance
        if low <= catastrophicStopPrice
            catastrophicStopTriggered := true
            debugError("ğŸ›‘ Catastrophic Stop: Long position hit " + str.tostring(catastrophicStopMultiplier) + "x stop at " + str.tostring(catastrophicStopPrice))
    
    if strategy.position_size < 0
        catastrophicStopPrice = strategy.position_avg_price + catastrophicStopDistance
        if high >= catastrophicStopPrice
            catastrophicStopTriggered := true
            debugError("ğŸ›‘ Catastrophic Stop: Short position hit " + str.tostring(catastrophicStopMultiplier) + "x stop at " + str.tostring(catastrophicStopPrice))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND RIDER EXIT EXECUTION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Execute exits based on signals or safety nets

// Execute signal-based exits
if inTrendRidingMode and signalBasedExitTriggered
    if strategy.position_size > 0
        strategy.close("Long", comment="Signal Exit", alert_message=longExitMsg)
        debugInfo("âœ… Signal-Based Exit (Long): " + str.tostring(oppositeSignalsCount) + " opposite signals detected")
    if strategy.position_size < 0
        strategy.close("Short", comment="Signal Exit", alert_message=shortExitMsg)
        debugInfo("âœ… Signal-Based Exit (Short): " + str.tostring(oppositeSignalsCount) + " opposite signals detected")
    inTrendRidingMode := false

// Execute safety net exits
if inTrendRidingMode and (trendBreakSafetyTriggered or maxHoldSafetyTriggered or catastrophicStopTriggered)
    exitReason := trendBreakSafetyTriggered ? "Trend Break" : maxHoldSafetyTriggered ? "Max Hold" : "Catastrophic Stop"
    
    if strategy.position_size > 0
        strategy.close("Long", comment=exitReason, alert_message=longExitMsg)
        debugWarn("âš ï¸ Safety Exit (Long): " + exitReason)
    if strategy.position_size < 0
        strategy.close("Short", comment=exitReason, alert_message=shortExitMsg)
        debugWarn("âš ï¸ Safety Exit (Short): " + exitReason)
    inTrendRidingMode := false

// Deactivate trend-riding mode when position closes
if inTrendRidingMode and strategy.position_size == 0
    inTrendRidingMode := false
    trendRidingBarsActive := 0
    debugInfo("ğŸ Trend-Riding Mode DEACTIVATED - Position closed")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADAPTIVE EXIT SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Impulsive move detection and rapid exit capabilities

// Calculate volatility metrics using user-configurable ATR
// (Variables already declared above to prevent undeclared identifier errors)

// Detect impulsive moves
barBodySize = math.abs(close - open)
impulsiveBarDetected = barBodySize > atrVal * impulsiveATRThreshold
volumeConfirmation = volume > ta.sma(volume, impulsiveVolumePeriod) * impulsiveVolumeMultiplier

// Calculate intrabar loss for position
var float entryPrice = na
if strategy.position_size != 0 and na(entryPrice)
    entryPrice := strategy.position_avg_price
else if strategy.position_size == 0
    entryPrice := na

intrabarLossPercent = strategy.position_size > 0 ? 
  (entryPrice - close) / entryPrice * 100 : 
  strategy.position_size < 0 ? 
  (close - entryPrice) / entryPrice * 100 : 0.0

// CRITICAL FIX: Determine exit sensitivity based on mode (works with bar-close execution)
useAggressiveExits = adaptiveExitMode == 'Aggressive' or 
  (adaptiveExitMode == 'Adaptive' and volatilityRatio > volatilityThreshold)

// Impulsive exit conditions (FIXED: Remove real-time dependency)
impulsiveExitTriggered = impulsiveExitEnable and
  ((impulsiveBarDetected and volumeConfirmation) or
   (useAggressiveExits and intrabarLossPercent > impulsiveMaxLoss))

// Momentum exit conditions (consecutive adverse bars)
var int adverseBars = 0
if momentumExitEnable and strategy.position_size != 0
    if strategy.position_size > 0 and close < close[1]
        adverseBars := adverseBars + 1
    else if strategy.position_size < 0 and close > close[1]
        adverseBars := adverseBars + 1
    else
        adverseBars := 0
else
    adverseBars := 0  // Reset when disabled or no position

momentumExitTriggered = momentumExitEnable and adverseBars >= impulsiveMomentumBars

// Define final entry signals with directional bias and Entry Probability Filter applied
longEntrySignal := primaryLongSig and longDirectionalBias and entryProbabilityOK
shortEntrySignal := primaryShortSig and shortDirectionalBias and entryProbabilityOK

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ACTUAL STRATEGY ENTRY EXECUTION (CRITICAL FIX) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CRITICAL: Execute the actual trades using strategy.entry() calls
// This was the missing piece - signals were calculated but trades weren't executed!

// Long Entry Execution â€“ with dynamic label
if longEntrySignal
    if displayEntryLabels
        string longLabelText = buildSignalName(true)
        if longLabelText != ""
            label lbl = getPooledLabel(true)
            updateLabel(lbl, bar_index, low - atrVal * 0.2, longLabelText, labelColorLong)
    entryComment = 'Long' + (longSignalCount > 1 ? ' C:' + str.tostring(longSignalCount) : '')
    strategy.entry('Long', strategy.long, qty = positionQty, comment = entryComment, alert_message = longEntryMsg)
    if debugEnabled
        debugInfo('Long entry triggered: ' + entryComment + ' at price: ' + str.tostring(close))

// Short Entry Execution â€“ with dynamic label
if shortEntrySignal
    if displayEntryLabels
        string shortLabelText = buildSignalName(false)
        if shortLabelText != ""
            label lbl = getPooledLabel(false)
            updateLabel(lbl, bar_index, high + atrVal * 0.2, shortLabelText, labelColorShort)
    entryComment = 'Short' + (shortSignalCount > 1 ? ' C:' + str.tostring(shortSignalCount) : '')
    strategy.entry('Short', strategy.short, qty = positionQty, comment = entryComment, alert_message = shortEntryMsg)
    if debugEnabled
        debugInfo('Short entry triggered: ' + entryComment + ' at price: ' + str.tostring(close))

// NOTE: Individual signal backtest processing is handled later in the script

// Enhanced debug logging for all directional bias filters and systems
if debugEnabled
    // Always show filter status when debug is enabled
    filterStatusMsg = 'FILTER STATUS:'
    filterStatusMsg += ' RBW=' + (rbwEnable ? (rbwSignal == 2 ? 'BULL' : rbwSignal == 0 ? 'BEAR' : 'NEUTRAL(' + str.tostring(rbwSignal) + ')') : 'OFF')
    filterStatusMsg += ' Hull=' + (hullEnable ? (hullBullish ? 'BULL' : 'BEAR') + '(' + str.tostring(hullMA, '#.##') + ')' : 'OFF')
    filterStatusMsg += ' ST=' + (supertrendEnable ? (supertrendBullish ? 'BULL' : 'BEAR') + '(' + str.tostring(supertrendDirection, '#.#') + ')' : 'OFF')
    filterStatusMsg += ' Quad=' + (quadrantEnable ? (quadrantBullish ? 'BULL' : 'BEAR') + '(' + str.tostring(quadrantEstimate, '#.##') + ')' : 'OFF')
    filterStatusMsg += ' MTF-ZZ=' + (mtfZigzagEnable ? (mtfZigzagBullish ? 'BULL' : 'BEAR') + '(' + str.tostring(mtfZigzagTrend) + ')' : 'OFF')
    debugInfo(filterStatusMsg)
    
    // Show confluence calculation with new voting system
    confluenceMsg = 'CONFLUENCE: Mode=' + biasConfluence + ' | Enabled=' + str.tostring(enabledFilters) + ' | BullVotes=' + str.tostring(bullishVotes) + ' | BearVotes=' + str.tostring(bearishVotes)
    confluenceMsg += ' | LongBias=' + (longDirectionalBias ? 'ALLOW' : 'BLOCK') + ' | ShortBias=' + (shortDirectionalBias ? 'ALLOW' : 'BLOCK')
    debugInfo(confluenceMsg)
    
    // Show individual filter votes (only when enabled)
    if enabledFilters > 0
        voteDetailMsg = 'FILTER VOTES:'
        if rbwEnable
            voteDetailMsg += ' RBW=' + (rbwSignal == 2 ? 'BULL' : rbwSignal == 0 ? 'BEAR' : 'NEUTRAL')
        if hullEnable
            voteDetailMsg += ' Hull=' + (hullBullish ? 'BULL' : 'BEAR')
        if supertrendEnable
            voteDetailMsg += ' ST=' + (supertrendBullish ? 'BULL' : 'BEAR')
        if quadrantEnable
            voteDetailMsg += ' Quad=' + (quadrantBullish ? 'BULL' : 'BEAR')
        if mtfZigzagEnable
            voteDetailMsg += ' MTF=' + (mtfZigzagBullish ? 'BULL' : 'BEAR')
        debugInfo(voteDetailMsg)

// Debug logging for trend-riding and adaptive exit systems
if debugEnabled and strategy.position_size != 0
    systemMsg = 'Exit Systems:'
    systemMsg += ' TrendRiding=' + (inTrendRidingMode ? 'ACTIVE(' + str.tostring(bar_index - trendRidingStartBar) + 'bars)' : 'OFF')
    systemMsg += ' | VolRatio=' + str.tostring(volatilityRatio, '#.##')
    systemMsg += ' | ExitMode=' + adaptiveExitMode
    systemMsg += ' | Impulsive=' + (impulsiveExitTriggered ? 'TRIGGERED' : 'OK')
    systemMsg += ' | Momentum=' + (momentumExitTriggered ? 'EXIT(' + str.tostring(adverseBars) + 'bars)' : 'OK')
    systemMsg += ' | IntraLoss=' + str.tostring(intrabarLossPercent, '#.##') + '%'
    debugInfo(systemMsg)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIGNAL-DRIVEN TREND RIDER: EXIT INTERCEPTION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REVOLUTIONARY FEATURE: Intercept and ignore standard exits during trend-riding mode
// This is the core of the Signal-Driven Trend Rider system

// â”€â”€â”€â”€â”€â”€â”€â”€ EXIT INTERCEPTION LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// When trend-riding mode is active, we intercept standard exits and ignore them
// Only signal-based exits and safety nets are allowed to close positions

var bool standardExitBlocked = false
standardExitBlocked := inTrendRidingMode

// â”€â”€â”€â”€â”€â”€â”€â”€ ADAPTIVE EXIT INTEGRATION (RESPECTS TREND-RIDING) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Immediate exit conditions - but respect trend-riding mode for non-catastrophic exits

// Catastrophic exits (always allowed, even during trend-riding)
if strategy.position_size != 0 and impulsiveExitTriggered and not standardExitBlocked
    if strategy.position_size > 0
        strategy.close('Long', comment='Impulsive Exit', alert_message=longExitMsg)
        debugWarn("âš¡ Impulsive Exit (Long): Immediate exit triggered")
    else
        strategy.close('Short', comment='Impulsive Exit', alert_message=shortExitMsg)
        debugWarn("âš¡ Impulsive Exit (Short): Immediate exit triggered")
    
    // Reset tracking variables
    entryPrice := na
    adverseBars := 0

// Momentum exits (blocked during trend-riding unless catastrophic)
else if strategy.position_size != 0 and momentumExitTriggered and not standardExitBlocked
    if strategy.position_size > 0
        strategy.close('Long', comment='Momentum Exit', alert_message=longExitMsg)
        debugWarn("ğŸ“‰ Momentum Exit (Long): " + str.tostring(adverseBars) + " adverse bars")
    else
        strategy.close('Short', comment='Momentum Exit', alert_message=shortExitMsg)
        debugWarn("ğŸ“‰ Momentum Exit (Short): " + str.tostring(adverseBars) + " adverse bars")
    
    // Reset tracking variables
    entryPrice := na
    adverseBars := 0

// â”€â”€â”€â”€â”€â”€â”€â”€ TREND-RIDING EXIT INTERCEPTION FEEDBACK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Provide debug feedback when exits are blocked
if standardExitBlocked and (impulsiveExitTriggered or momentumExitTriggered)
    blockedExitType = impulsiveExitTriggered ? "Impulsive" : "Momentum"
    debugInfo("ğŸš€ TREND-RIDING: " + blockedExitType + " exit INTERCEPTED and IGNORED - Waiting for signal-based exit")
    
    if debugEnabled
        debugInfo('BLOCKED EXIT: ' + blockedExitType + ' | Loss: ' + str.tostring(intrabarLossPercent, '#.##') + '%')

// Trend-riding mode modifications (modify existing exit behavior)
var bool exitOverridden = false
if inTrendRidingMode and strategy.position_size != 0
    // In trend-riding mode, we modify the normal exit logic
    // This is now integrated with Smart Profit Locker above
    exitOverridden := true
    
    if debugEnabled
        trendDuration = bar_index - trendRidingStartBar
        debugInfo('TREND-RIDING ACTIVE: 3x wider stops, 50% offset | Duration: ' + str.tostring(trendDuration) + ' bars | Filters: ' + str.tostring(trendStrengthScore) + '/' + str.tostring(enabledFilters))

// Visual plotting removed for performance optimization
// Core logic preserved: entryBlocked and entryWarning calculations maintained for strategy logic
entryBlocked = entryProbFilterEnable and not entryProbabilityOK
entryWarning = entryProbFilterEnable and entryProbabilityOK and compositeProbability > entryProbFilterThreshold * 0.8

// â”€â”€â”€â”€â”€â”€â”€â”€ 7. CUSTOM EXIT (Always Active) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if strategy.position_size != 0
    customDistance = 2.5 * atrVal
    
    // CRITICAL FIX: Use user-configurable fallback instead of hardcoded value
    if na(smartDistance) or smartDistance <= 0
        smartDistance := smartProfitFallback  // User-configurable fallback value
    
    if strategy.position_size > 0  // Long position
        stopLevel = strategyEntryPrice - customDistance
        if not na(stopLevel) and stopLevel > 0
            strategy.exit('Custom-Long', from_entry='Long', stop=math.max(stopLevel, close * 0.99), comment='Custom Exit')
            if not customExitSent
                customExitSent := true
    
    else if strategy.position_size < 0  // Short position
        stopLevel = strategyEntryPrice + customDistance
        if not na(stopLevel) and stopLevel > 0
            strategy.exit('Custom-Short', from_entry='Short', stop=math.max(stopLevel, close * 1.01), comment='Custom Exit')
            if not customExitSent
                customExitSent := true
