//
// 🚨================================================================================================🚨
// 🚨 EZ ALGO TRADER - PURE STRATEGY PROTECTION PROMPT
// 🚨================================================================================================🚨
//
// PRIMARY MANDATE: PROTECT THE MAGIC
// This Pine Script strategy is achieving unbelievable win rates through a streamlined, battle-tested system.
// This is now a PURE STRATEGY focused on execution performance. The current functionality is SACRED and must be preserved at all costs.
//
//
// 🔒 ABSOLUTE PRESERVATION RULES: DO NOT MODIFY THE FOLLOWING CORE SYSTEMS 🔒
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
// 1. Multi-Signal Processing Logic (Lines ~50-200)
//    - Signal detection arrays and processing
//    - Signal combination and confluence calculations
//    - Entry signal generation with directional bias
//
// 2. Exit System Architecture (Lines ~800-1200)
//    - Multi-method exit logic (MA, Fixed, Smart Profit Locker)
//    - Intrabar exit system with anti-spam flags
//    - Exit interception and trend-riding integration
//
// 3. Trend-Riding Overlay System (Lines ~1300-1500)
//    - Signal-driven trend rider logic
//    - Exit interception during trend-riding mode
//    - Safety net mechanisms (catastrophic stops, max hold)
//
// 4. Directional Bias Filter Integration (Lines ~1600-1800)
//    - RBW, Hull Suite, SuperTrend, Quadrant calculations
//    - Confluence voting system and bias application
//
// 5. Real Strategy Execution (Lines ~1000-1200)
//    - strategy.entry() and strategy.exit() calls
//    - TradersPost webhook integration
//    - Position sizing and risk management
//
//
// 🚫 STRICT PROHIBITIONS: NEVER DO THESE 🚫
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
// - DO NOT Remove Core Strategy Logic (Signal processing, exits, trend-riding).
// - DO NOT Add Heavy Visual Elements (Backtesting tables, complex debug panels, heavy labels).
// - DO NOT Break Exit System Integration (Do not alter strategy.exit() call patterns).
// - DO NOT Alter Working Mathematical Formulas (ATR, confluence math, filter calculations).
//
//
// ✅ APPROVED MODIFICATION AREAS ✅
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
// - New Filter Additions: Follow the existing pattern for adding new directional bias filters.
// - Minimal Visual Elements: Essential plotshape() for entry/exit signals and core indicator plots ONLY.
// - Parameter Tuning: Adjust default values for existing parameters.
// - Built-in Indicator Integration: Add new `ta.*` functions for additional filters.
//
//
// ⚡ EMERGENCY PROTOCOL: IF SOMETHING BREAKS ⚡
//----------------------------------------------------------------------------------------------------------------------------------------------------------------
// - IMMEDIATELY REVERT to the last working version.
// - Identify the exact change that caused the issue.
// - Use version control to restore functionality.
//
// This prompt serves as a guardian for a battle-tested, high-performing trading strategy. Treat it with the respect it deserves.
// 🚨================================================================================================🚨

// 2025 Andres Garcia — EZ Algo Trader (Beta)
//  ────────────────────────────────────────────────────────────────
//  Enhanced Multi-Signal Risk Management System
//  • Professional risk management with multiple exit strategies
//  • TradersPost webhook integration for automated trading
//  • Configurable position sizing and stop-loss/take-profit levels
//  • Integrated debugging logger for development
//  ────────────────────────────────────────────────────────────────
//@version=6

// ═══════════════════ DEBUG SYSTEM (MEMORY SAFE) ═══════════════════
// Memory-safe debug system that doesn't create label leaks

// Debug configuration
bool debugEnabled = input.bool(false, '🔍 Enable Debug Labels', group = '🛠️ Debug System', tooltip = 'Show debug information in strategy tester logs')

// Memory-safe debug functions using log output instead of labels
// This prevents memory leaks while preserving debug functionality
debugLog(string message) =>
    if debugEnabled
        log.info("DEBUG: " + message)

debugInfo(string message) =>
    if debugEnabled
        log.info("INFO: " + message)

debugWarn(string message) =>
    if debugEnabled
        log.warning("WARN: " + message)

debugError(string message) =>
    if debugEnabled
        log.error("ERROR: " + message)

debugTrace(string message) =>
    if debugEnabled
        log.info("TRACE: " + message)

// ═══════════════════ LABEL POOL HELPERS (Memory-Safe) ═══════════════════
// Minimal helper set – capped pool, no heavy visuals
var int MAX_LABELS = 50
var label[] longLabelPool = array.new<label>()
var label[] shortLabelPool = array.new<label>()

// Fetches an existing label from the pool or creates a new one (max MAX_LABELS per side)
getPooledLabel(bool isLong) =>
    pool = isLong ? longLabelPool : shortLabelPool
    label lbl = na
    if array.size(pool) < MAX_LABELS
        lbl := label.new(bar_index, na, '', color = color.new(color.white, 100), textcolor = color.white, size = size.small, style = label.style_label_left)
        array.push(pool, lbl)
    else
        lbl := array.get(pool, bar_index % MAX_LABELS)
    lbl

// Updates a pooled label’s position, text, and colour
updateLabel(label lbl, int x, float y, string txt, color col) =>
    if not na(lbl)
        label.set_x(lbl, x)
        label.set_y(lbl, y)
        label.set_text(lbl, txt)
        label.set_textcolor(lbl, col)
        label.set_color(lbl, color.new(col, 80))
        label.set_style(lbl, label.style_label_left)
        label.set_size(lbl, size.small)


strategy(title = 'EZ Algo Trade Manager', overlay = true, pyramiding = 1, default_qty_type = strategy.fixed, default_qty_value = 1, calc_on_order_fills = true, process_orders_on_close = true, calc_on_every_tick = false)
// User-controllable quantity

// ═══════════════════ GLOBAL VARIABLE DECLARATIONS ═══════════════════
// Declare all variables early to avoid scope issues

// Legacy trend-riding system variables removed (system eliminated)

// Exit system variables
var float smartOffset = na
var string exitComment = na
var string exitReason = na
var bool allowTrendExit = false

// Legacy trend-riding variables (for compatibility with remaining references)
var bool inTrendRidingMode = false
var int trendRidingStartBar = na

// Hybrid Exit Mode variables removed (system eliminated)

// Adaptive SuperTrend K-means Clustering Variables (FULL IMPLEMENTATION)
var array<float> adaptive_hv = array.new_float()
var array<float> adaptive_mv = array.new_float()
var array<float> adaptive_lv = array.new_float()
var array<float> adaptive_amean = array.new_float(1, 0)
var array<float> adaptive_bmean = array.new_float(1, 0)
var array<float> adaptive_cmean = array.new_float(1, 0)
var int adaptiveCluster = na
var int adaptiveNumber = na
var float adaptive_assigned_centroid = na
var int adaptive_iterations = 0

// Adaptive SuperTrend Exit Filter Variables
var bool adaptiveExitBlocked = false
var bool adaptivePendingExit = false
var string adaptiveExitReason = na

// ═══════════════════ CRITICAL INPUT DECLARATIONS ═══════════════════
// These inputs must be declared early as they're used in backtest functions
positionQty = input.int(1, 'Number of Contracts', minval = 1, maxval = 1000, group = 'Position Size', tooltip = 'Set the number of contracts/shares to trade per signal')



// ─────────────────── 0 · POSITION SIZE & PRIMARY SIGNALS ───────────────────
// Position Size Control (moved to early declarations section)

// ═══════════════════ MULTI-SIGNAL INPUT SYSTEM ═══════════════════
// Support for multiple buy/sell indicators with AI-style quality assessment

// ─────────────────── SIGNAL SOURCE INPUTS ───────────────────
signal1Enable = input.bool(true, '📊 Signal 1', inline = 'sig1', group = '🔄 Multi-Signals', tooltip = 'Primary signal source')
signal1LongSrc = input.source(close, 'Long', inline = 'sig1', group = '🔄 Multi-Signals')
signal1ShortSrc = input.source(close, 'Short', inline = 'sig1', group = '🔄 Multi-Signals')
signal1Name = input.string('LuxAlgo', 'Name', inline = 'sig1name', group = '🔄 Multi-Signals')
signal1Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig1name', group = '🔄 Multi-Signals')

signal2Enable = input.bool(false, '📊 Signal 2', inline = 'sig2', group = '🔄 Multi-Signals')
signal2LongSrc = input.source(close, 'Long', inline = 'sig2', group = '🔄 Multi-Signals')
signal2ShortSrc = input.source(close, 'Short', inline = 'sig2', group = '🔄 Multi-Signals')
signal2Name = input.string('UTBot', 'Name', inline = 'sig2name', group = '🔄 Multi-Signals')
signal2Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig2name', group = '🔄 Multi-Signals')

signal3Enable = input.bool(false, '📊 Signal 3', inline = 'sig3', group = '🔄 Multi-Signals')
signal3LongSrc = input.source(close, 'Long', inline = 'sig3', group = '🔄 Multi-Signals')
signal3ShortSrc = input.source(close, 'Short', inline = 'sig3', group = '🔄 Multi-Signals')
signal3Name = input.string('VIDYA', 'Name', inline = 'sig3name', group = '🔄 Multi-Signals')
signal3Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig3name', group = '🔄 Multi-Signals')

signal4Enable = input.bool(false, '📊 Signal 4', inline = 'sig4', group = '🔄 Multi-Signals')
signal4LongSrc = input.source(close, 'Long', inline = 'sig4', group = '🔄 Multi-Signals')
signal4ShortSrc = input.source(close, 'Short', inline = 'sig4', group = '🔄 Multi-Signals')
signal4Name = input.string('KyleAlgo', 'Name', inline = 'sig4name', group = '🔄 Multi-Signals')
signal4Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig4name', group = '🔄 Multi-Signals')

signal5Enable = input.bool(false, '📊 Signal 5', inline = 'sig5', group = '🔄 Multi-Signals')
signal5LongSrc = input.source(close, 'Long', inline = 'sig5', group = '🔄 Multi-Signals')
signal5ShortSrc = input.source(close, 'Short', inline = 'sig5', group = '🔄 Multi-Signals')
signal5Name = input.string('Wonder', 'Name', inline = 'sig5name', group = '🔄 Multi-Signals')
signal5Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig5name', group = '🔄 Multi-Signals')

signal6Enable = input.bool(false, '📊 Signal 6', inline = 'sig6', group = '🔄 Multi-Signals')
signal6LongSrc = input.source(close, 'Long', inline = 'sig6', group = '🔄 Multi-Signals')
signal6ShortSrc = input.source(close, 'Short', inline = 'sig6', group = '🔄 Multi-Signals')
signal6Name = input.string('Custom1', 'Name', inline = 'sig6name', group = '🔄 Multi-Signals')
signal6Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig6name', group = '🔄 Multi-Signals')

signal7Enable = input.bool(false, '📊 Signal 7', inline = 'sig7', group = '🔄 Multi-Signals')
signal7LongSrc = input.source(close, 'Long', inline = 'sig7', group = '🔄 Multi-Signals')
signal7ShortSrc = input.source(close, 'Short', inline = 'sig7', group = '🔄 Multi-Signals')
signal7Name = input.string('Custom2', 'Name', inline = 'sig7name', group = '🔄 Multi-Signals')
signal7Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig7name', group = '🔄 Multi-Signals')

signal8Enable = input.bool(false, '📊 Signal 8', inline = 'sig8', group = '🔄 Multi-Signals')
signal8LongSrc = input.source(close, 'Long', inline = 'sig8', group = '🔄 Multi-Signals')
signal8ShortSrc = input.source(close, 'Short', inline = 'sig8', group = '🔄 Multi-Signals')
signal8Name = input.string('Custom3', 'Name', inline = 'sig8name', group = '🔄 Multi-Signals')
signal8Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig8name', group = '🔄 Multi-Signals')

signal9Enable = input.bool(false, '📊 Signal 9', inline = 'sig9', group = '🔄 Multi-Signals')
signal9LongSrc = input.source(close, 'Long', inline = 'sig9', group = '🔄 Multi-Signals')
signal9ShortSrc = input.source(close, 'Short', inline = 'sig9', group = '🔄 Multi-Signals')
signal9Name = input.string('Custom4', 'Name', inline = 'sig9name', group = '🔄 Multi-Signals')
signal9Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig9name', group = '🔄 Multi-Signals')

signal10Enable = input.bool(false, '📊 Signal 10', inline = 'sig10', group = '🔄 Multi-Signals')
signal10LongSrc = input.source(close, 'Long', inline = 'sig10', group = '🔄 Multi-Signals')
signal10ShortSrc = input.source(close, 'Short', inline = 'sig10', group = '🔄 Multi-Signals')
signal10Name = input.string('Custom5', 'Name', inline = 'sig10name', group = '🔄 Multi-Signals')
signal10Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig10name', group = '🔄 Multi-Signals')

// ═══════════════════ LABELING OPTIONS ═══════════════════
displayEntryLabels = input.bool(true,  'Show Entry Labels', group = '📍 Labeling')
labelColorLong     = input.color(color.green, 'Long Label Colour',  group = '📍 Labeling', inline='lblcl')
labelColorShort    = input.color(color.red,   'Short Label Colour', group = '📍 Labeling', inline='lblcl')

// ─────────────────── ENHANCED SIGNAL PROCESSING (BUG FIX) ───────────────────
// CRITICAL SAFETY: Signals must NEVER fire when source equals default close price
// This prevents false signals from unconnected inputs and ensures only real indicators fire
// Enhanced validation with explicit rejection of default sources

// Helper function to validate signal sources (prevents default close from generating signals)
isValidSignalSource(src) =>
    not na(src) and src != close and src != open and src != high and src != low

// Enhanced validation for external indicators (Signal 5 fix)
// More permissive validation that allows external indicators to work properly
// Only blocks truly invalid signals (na values or disabled signals)
isValidExternalSignal(src) =>
    not na(src)  // Only check for na values, allow price-based external indicators

// ═══════════════════ SIGNAL USAGE PROCESSING HELPER ═══════════════════
// NEW FEATURE: Process signals based on usage dropdown settings
// Allows each signal to be configured for specific entry/exit behavior

// Signal Usage Processing Function
processSignalWithUsage(bool rawLongSignal, bool rawShortSignal, string usage) =>
    var bool processedLong = false
    var bool processedShort = false
    var bool isEntrySignal = false
    var bool isExitSignal = false
    
    // Determine signal type based on usage
    isEntrySignal := usage == 'Entry All' or usage == 'Entry Long Only' or usage == 'Entry Short Only'
    isExitSignal := usage == 'Exit All' or usage == 'Exit Long Only' or usage == 'Exit Short Only'
    
    // Process signals based on usage setting
    if usage == 'Entry All'
        processedLong := rawLongSignal
        processedShort := rawShortSignal
    else if usage == 'Entry Long Only'
        processedLong := rawLongSignal
        processedShort := false  // Block short entries
    else if usage == 'Entry Short Only'
        processedLong := false   // Block long entries
        processedShort := rawShortSignal
    else if usage == 'Exit All'
        // Exit signals are handled separately in trend-riding logic
        processedLong := false
        processedShort := false
    else if usage == 'Exit Long Only'
        // Exit signals are handled separately in trend-riding logic
        processedLong := false
        processedShort := false
    else if usage == 'Exit Short Only'
        // Exit signals are handled separately in trend-riding logic
        processedLong := false
        processedShort := false
    else if usage == 'Observe'
        // Signal is tracked but doesn't trigger trades
        processedLong := false
        processedShort := false
    else
        // Default to 'Entry All' behavior
        processedLong := rawLongSignal
        processedShort := rawShortSignal
    
    [processedLong, processedShort, isEntrySignal, isExitSignal]

// ═══════════════════ SIGNAL PROCESSING LOGIC ═══════════════════
// CRITICAL: This is the core signal detection system - DO NOT BREAK
// Enhanced with usage dropdown functionality for flexible signal behavior

// Raw signal detection (unchanged core logic)
rawSig1Long = signal1Enable and isValidSignalSource(signal1LongSrc) ? (signal1LongSrc > 0 or bool(signal1LongSrc) == true) : false
rawSig1Short = signal1Enable and isValidSignalSource(signal1ShortSrc) ? (signal1ShortSrc > 0 or bool(signal1ShortSrc) == true) : false
rawSig2Long = signal2Enable and isValidSignalSource(signal2LongSrc) ? (signal2LongSrc > 0 or bool(signal2LongSrc) == true) : false
rawSig2Short = signal2Enable and isValidSignalSource(signal2ShortSrc) ? (signal2ShortSrc > 0 or bool(signal2ShortSrc) == true) : false
rawSig3Long = signal3Enable and isValidSignalSource(signal3LongSrc) ? (signal3LongSrc > 0 or bool(signal3LongSrc) == true) : false
rawSig3Short = signal3Enable and isValidSignalSource(signal3ShortSrc) ? (signal3ShortSrc > 0 or bool(signal3ShortSrc) == true) : false
rawSig4Long = signal4Enable and isValidSignalSource(signal4LongSrc) ? (signal4LongSrc > 0 or bool(signal4LongSrc) == true) : false
rawSig4Short = signal4Enable and isValidSignalSource(signal4ShortSrc) ? (signal4ShortSrc > 0 or bool(signal4ShortSrc) == true) : false
rawSig5Long = signal5Enable and isValidExternalSignal(signal5LongSrc) ? (signal5LongSrc > 0 or bool(signal5LongSrc) == true) : false
rawSig5Short = signal5Enable and isValidExternalSignal(signal5ShortSrc) ? (signal5ShortSrc > 0 or bool(signal5ShortSrc) == true) : false
rawSig6Long = signal6Enable and isValidSignalSource(signal6LongSrc) ? (signal6LongSrc > 0 or bool(signal6LongSrc) == true) : false
rawSig6Short = signal6Enable and isValidSignalSource(signal6ShortSrc) ? (signal6ShortSrc > 0 or bool(signal6ShortSrc) == true) : false
rawSig7Long = signal7Enable and isValidSignalSource(signal7LongSrc) ? (signal7LongSrc > 0 or bool(signal7LongSrc) == true) : false
rawSig7Short = signal7Enable and isValidSignalSource(signal7ShortSrc) ? (signal7ShortSrc > 0 or bool(signal7ShortSrc) == true) : false
rawSig8Long = signal8Enable and isValidSignalSource(signal8LongSrc) ? (signal8LongSrc > 0 or bool(signal8LongSrc) == true) : false
rawSig8Short = signal8Enable and isValidSignalSource(signal8ShortSrc) ? (signal8ShortSrc > 0 or bool(signal8ShortSrc) == true) : false
rawSig9Long = signal9Enable and isValidSignalSource(signal9LongSrc) ? (signal9LongSrc > 0 or bool(signal9LongSrc) == true) : false
rawSig9Short = signal9Enable and isValidSignalSource(signal9ShortSrc) ? (signal9ShortSrc > 0 or bool(signal9ShortSrc) == true) : false
rawSig10Long = signal10Enable and isValidSignalSource(signal10LongSrc) ? (signal10LongSrc > 0 or bool(signal10LongSrc) == true) : false
rawSig10Short = signal10Enable and isValidSignalSource(signal10ShortSrc) ? (signal10ShortSrc > 0 or bool(signal10ShortSrc) == true) : false

// Process signals with usage settings (NEW FEATURE)
[sig1Long, sig1Short, sig1IsEntry, sig1IsExit] = processSignalWithUsage(rawSig1Long, rawSig1Short, signal1Usage)
[sig2Long, sig2Short, sig2IsEntry, sig2IsExit] = processSignalWithUsage(rawSig2Long, rawSig2Short, signal2Usage)
[sig3Long, sig3Short, sig3IsEntry, sig3IsExit] = processSignalWithUsage(rawSig3Long, rawSig3Short, signal3Usage)
[sig4Long, sig4Short, sig4IsEntry, sig4IsExit] = processSignalWithUsage(rawSig4Long, rawSig4Short, signal4Usage)
[sig5Long, sig5Short, sig5IsEntry, sig5IsExit] = processSignalWithUsage(rawSig5Long, rawSig5Short, signal5Usage)
[sig6Long, sig6Short, sig6IsEntry, sig6IsExit] = processSignalWithUsage(rawSig6Long, rawSig6Short, signal6Usage)
[sig7Long, sig7Short, sig7IsEntry, sig7IsExit] = processSignalWithUsage(rawSig7Long, rawSig7Short, signal7Usage)
[sig8Long, sig8Short, sig8IsEntry, sig8IsExit] = processSignalWithUsage(rawSig8Long, rawSig8Short, signal8Usage)
[sig9Long, sig9Short, sig9IsEntry, sig9IsExit] = processSignalWithUsage(rawSig9Long, rawSig9Short, signal9Usage)
[sig10Long, sig10Short, sig10IsEntry, sig10IsExit] = processSignalWithUsage(rawSig10Long, rawSig10Short, signal10Usage)

// Debug validation: Alert when signals are blocked due to default sources
if debugEnabled and signal1Enable and not isValidSignalSource(signal1LongSrc)
    debugWarn("Signal 1 Long blocked: Source equals default close price. Connect external indicator.")
if debugEnabled and signal1Enable and not isValidSignalSource(signal1ShortSrc)
    debugWarn("Signal 1 Short blocked: Source equals default close price. Connect external indicator.")

// ─────────────────── SIGNAL ARRAYS FOR PROCESSING (MEMORY LEAK FIX) ───────────────────
// CRITICAL FIX: Use persistent arrays with proper memory management
// Create arrays once and reuse them instead of creating new ones every bar
var allLongSignals = array.new<bool>(10)
var allShortSignals = array.new<bool>(10)

// Update array values efficiently (reuse existing arrays)
array.set(allLongSignals, 0, sig1Long)
array.set(allLongSignals, 1, sig2Long)
array.set(allLongSignals, 2, sig3Long)
array.set(allLongSignals, 3, sig4Long)
array.set(allLongSignals, 4, sig5Long)
array.set(allLongSignals, 5, sig6Long)
array.set(allLongSignals, 6, sig7Long)
array.set(allLongSignals, 7, sig8Long)
array.set(allLongSignals, 8, sig9Long)
array.set(allLongSignals, 9, sig10Long)
array.set(allShortSignals, 0, sig1Short)
array.set(allShortSignals, 1, sig2Short)
array.set(allShortSignals, 2, sig3Short)
array.set(allShortSignals, 3, sig4Short)
array.set(allShortSignals, 4, sig5Short)
array.set(allShortSignals, 5, sig6Short)
array.set(allShortSignals, 6, sig7Short)
array.set(allShortSignals, 7, sig8Short)
array.set(allShortSignals, 8, sig9Short)
array.set(allShortSignals, 9, sig10Short)

// Count active signals
longSignalCount = (sig1Long ? 1 : 0) + (sig2Long ? 1 : 0) + (sig3Long ? 1 : 0) + (sig4Long ? 1 : 0) + (sig5Long ? 1 : 0) + (sig6Long ? 1 : 0) + (sig7Long ? 1 : 0) + (sig8Long ? 1 : 0) + (sig9Long ? 1 : 0) + (sig10Long ? 1 : 0)
shortSignalCount = (sig1Short ? 1 : 0) + (sig2Short ? 1 : 0) + (sig3Short ? 1 : 0) + (sig4Short ? 1 : 0) + (sig5Short ? 1 : 0) + (sig6Short ? 1 : 0) + (sig7Short ? 1 : 0) + (sig8Short ? 1 : 0) + (sig9Short ? 1 : 0) + (sig10Short ? 1 : 0)



// ═══════════════════ PRIMARY SIGNAL COMBINATION ═══════════════════
// Note: Primary signals are defined below after imports (line 126-127)

// ═══════════════════ RBW FILTER IMPORT ═══════════════════
// Import enhanced_ta library for existing RBW filter (defined later)
import HeWhoMustNotBeNamed/enhanced_ta/14 as eta

// ═══════════════════ FLIPFLOP RANGE-BREAKOUT FILTER (OPTIONAL) ═══════════════════
// Inline port of FlipFlopFilter.pine (≈150 lines). OFF by default; fully user-configurable.

// ───── USER SETTINGS ─────
ffEnable  = input.bool(false,  '🚦 Enable FlipFlop Filter', group='🆕 FlipFlop Filter')
ffShowBg  = input.bool(true,   'Show Range/Breakout BG',   group='🆕 FlipFlop Filter', inline='ff1')
ffSigSrc  = input.string('Any','Signal Source', options=['Breakout','Reversal','Any'], group='🆕 FlipFlop Filter', inline='ff1')
ffAtrLen   = input.int(400,  'ATR Length',         group='🆕 FlipFlop Filter')
ffAbsMax   = input.float(2.0,'AbsMax ×ATR', step=0.1, group='🆕 FlipFlop Filter')
ffMinFlips = input.int(3,    'Min Small Flips',    group='🆕 FlipFlop Filter')
ffBreakK   = input.float(0.6,'BreakK ×ATR', step=0.05, group='🆕 FlipFlop Filter')
ffRunThres = input.float(2.0,'runATR Threshold', step=0.1, group='🆕 FlipFlop Filter')
ffDecay    = input.int(1,'Small Flip Decay',   minval=1, maxval=10, group='🆕 FlipFlop Filter')

// External pulses (optional)
ff_longEntSrc   = input.source(close, 'Ext Long ENTRY',  group='🆕 FlipFlop Filter')
ff_longExitSrc  = input.source(close, 'Ext Long EXIT',   group='🆕 FlipFlop Filter')
ff_shortEntSrc  = input.source(close, 'Ext Short ENTRY', group='🆕 FlipFlop Filter')
ff_shortExitSrc = input.source(close, 'Ext Short EXIT',  group='🆕 FlipFlop Filter')

// ───── INTERNAL CALCULATIONS ─────
ff_isPulse(sig) => nz(sig,0) != 0 and nz(sig[1],0) == 0
ffATR  = ta.atr(ffAtrLen)
ffDir  = close >= open ? 1 : -1
ffFlip = ta.change(ffDir) != 0
var int ff_runID = 0
ff_runID := ffFlip ? ff_runID + 1 : ff_runID
ff_runMove = math.abs(close - ta.valuewhen(ffFlip, close[1], 0))
// Hardened division guard
ff_runATR  = (not na(ffATR) and ffATR > 0.0001) ? ff_runMove / ffATR : 0.0
ff_lastInRun = ta.barssince(ffFlip[1]) == 0

// MEMORY-SAFE fixed-length buffer (max 20)
var float[] ff_buf = array.new_float()
if ff_lastInRun
    if array.size(ff_buf) >= 20
        array.shift(ff_buf)
    array.push(ff_buf, ff_runATR)
ff_isSmall = ff_runATR < ffAbsMax

var bool ff_inRange = false
var float ff_hi = na
var float ff_lo = na
var int ff_smallCnt = 0
ff_brkLong = false
ff_brkShort = false
if not ff_inRange
    if ff_lastInRun
        // Increment or decay small-flip counter
        ff_smallCnt := ff_isSmall ? ff_smallCnt + 1 : math.max(ff_smallCnt - ffDecay, 0)
    if ff_smallCnt >= ffMinFlips
        ff_inRange := true
        ff_hi := high
        ff_lo := low
else
    ff_dynUp = (high - ff_hi) > ffBreakK * ffATR
    ff_dynDn = (ff_lo - low)  > ffBreakK * ffATR
    ff_atrUp = ff_runATR > ffRunThres and ffDir == 1  and ff_lastInRun
    ff_atrDn = ff_runATR > ffRunThres and ffDir == -1 and ff_lastInRun
    if ff_dynUp or ff_atrUp
        ff_brkLong := true
        ff_inRange := false
        ff_smallCnt := 0
    else if ff_dynDn or ff_atrDn
        ff_brkShort := true
        ff_inRange := false
        ff_smallCnt := 0
    else
        ff_hi := math.max(ff_hi, high)
        ff_lo := math.min(ff_lo, low)

var bool ff_trendMode = false
if ff_brkLong or ff_brkShort
    ff_trendMode := true
if ff_inRange
    ff_trendMode := false

ff_revLongEntry  = ff_trendMode and ff_isPulse(ff_longEntSrc)
ff_revShortEntry = ff_trendMode and ff_isPulse(ff_shortEntSrc)

ff_buySig  = (ffSigSrc == 'Breakout' and ff_brkLong)  or (ffSigSrc == 'Reversal' and ff_revLongEntry)  or (ffSigSrc == 'Any' and (ff_brkLong  or ff_revLongEntry))
ff_sellSig = (ffSigSrc == 'Breakout' and ff_brkShort) or (ffSigSrc == 'Reversal' and ff_revShortEntry) or (ffSigSrc == 'Any' and (ff_brkShort or ff_revShortEntry))

// Background highlight (must be global call)
var color ff_bg = na
ff_bg := ffEnable and ffShowBg and ff_inRange ? color.new(color.blue, 90) : na
bgcolor(ff_bg)

ff_longGate  = not ffEnable ? true : ff_buySig
ff_shortGate = not ffEnable ? true : ff_sellSig

// ═══════════════════ BUILD SIGNAL NAME FUNCTION ═══════════════════
// Builds a "+"-concatenated string of active signal names on the current bar
// Declared after all signal and FlipFlop variables exist to prevent undeclared identifier errors
buildSignalName(bool isLong) =>
    string names = ""
    if isLong
        if sig1Long  
            names := names == "" ? signal1Name : names + "+" + signal1Name
        if sig2Long  
            names := names == "" ? signal2Name : names + "+" + signal2Name
        if sig3Long  
            names := names == "" ? signal3Name : names + "+" + signal3Name
        if sig4Long  
            names := names == "" ? signal4Name : names + "+" + signal4Name
        if sig5Long  
            names := names == "" ? signal5Name : names + "+" + signal5Name
        if sig6Long  
            names := names == "" ? signal6Name : names + "+" + signal6Name
        if sig7Long  
            names := names == "" ? signal7Name : names + "+" + signal7Name
        if sig8Long  
            names := names == "" ? signal8Name : names + "+" + signal8Name
        if sig9Long  
            names := names == "" ? signal9Name : names + "+" + signal9Name
        if sig10Long 
            names := names == "" ? signal10Name : names + "+" + signal10Name
        if ff_buySig 
            names := names == "" ? "FlipFlop" : names + "+FlipFlop"
    else
        if sig1Short  
            names := names == "" ? signal1Name : names + "+" + signal1Name
        if sig2Short  
            names := names == "" ? signal2Name : names + "+" + signal2Name
        if sig3Short  
            names := names == "" ? signal3Name : names + "+" + signal3Name
        if sig4Short  
            names := names == "" ? signal4Name : names + "+" + signal4Name
        if sig5Short  
            names := names == "" ? signal5Name : names + "+" + signal5Name
        if sig6Short  
            names := names == "" ? signal6Name : names + "+" + signal6Name
        if sig7Short  
            names := names == "" ? signal7Name : names + "+" + signal7Name
        if sig8Short  
            names := names == "" ? signal8Name : names + "+" + signal8Name
        if sig9Short  
            names := names == "" ? signal9Name : names + "+" + signal9Name
        if sig10Short 
            names := names == "" ? signal10Name : names + "+" + signal10Name
        if ff_sellSig 
            names := names == "" ? "FlipFlop" : names + "+FlipFlop"
    names

// ═══════════════════ SIGNAL PROCESSING SETUP ═══════════════════
// Legacy compatibility - combine all signals
primaryLongSig = sig1Long or sig2Long or sig3Long or sig4Long or sig5Long or sig6Long or sig7Long or sig8Long or sig9Long or sig10Long
primaryShortSig = sig1Short or sig2Short or sig3Short or sig4Short or sig5Short or sig6Short or sig7Short or sig8Short or sig9Short or sig10Short

// ───── APPLY FLIPFLOP FILTER ─────
if ffEnable
    primaryLongSig := primaryLongSig and ff_longGate
    primaryShortSig := primaryShortSig and ff_shortGate

// ─────────────────── 1 · TRADERSPOST JSON HELPERS ───────────────

// ───── Pre-built JSON messages (compile-time constants) ─────
// Use TradingView alert placeholders so we avoid any per-bar string operations.
// Placeholders {{close}} and {{timenow}} will be expanded at alert trigger time.
var string _jsonBase = '{"ticker":"' + syminfo.ticker + '","price":{{close}},"time":{{timenow}}'

var string longEntryMsg = _jsonBase + ',"action":"buy","sentiment":"long"}'
var string shortEntryMsg = _jsonBase + ',"action":"sell","sentiment":"short"}'
var string flatExitMsg = _jsonBase + ',"action":"exit","sentiment":"flat"}'
var string longExitMsg = _jsonBase + ',"action":"sell","sentiment":"flat"}' // closes long
var string shortExitMsg = _jsonBase + ',"action":"buy","sentiment":"flat"}' // closes short

// ─────────────────── 2 · ATR SETTINGS (BUG FIX) ───────────────────
atrLen = input.int(14, 'ATR Length', minval = 1, group = 'ATR Settings')

// CRITICAL FIX: ATR Validation to prevent silent failures
// Raw ATR calculation
rawATR = ta.atr(atrLen)

// Validated ATR with fallback protection
var float atrVal = na
atrVal := na(rawATR) or rawATR <= 0 ? ta.sma(high - low, math.min(atrLen, bar_index + 1)) : rawATR

// Final safety check: ensure ATR is never zero or negative
atrVal := math.max(atrVal, 0.0001)  // Minimum ATR of 0.0001 to prevent division by zero

// ───── Volatility Ratio (global) for adaptive stop & debug ─────
// Re-computed every bar (not a "var") so downstream logic can read it.
volatilityRatio = ta.sma(atrVal, 50) > 1e-10 ? atrVal / ta.sma(atrVal, 50) : 1.0


// ─────────────────── 3 · EXIT PARAMETERS (ASCII SAFE) ───────────
maExitOn = input.bool(true, 'Enable MA Exit', group = 'MA Exit')
maLen = input.int(21, 'MA Length', minval = 1, group = 'MA Exit')
maType = input.string('EMA', 'MA Type', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA'], group = 'MA Exit')
// Intrabar exits removed - exits only trigger once per bar on close

priceMA = maType == 'SMA' ? ta.sma(close, maLen) : maType == 'EMA' ? ta.ema(close, maLen) : maType == 'WMA' ? ta.wma(close, maLen) : maType == 'VWMA' ? ta.vwma(close, maLen) : ta.rma(close, maLen)

fixedEnable = input.bool(false, 'Enable Fixed SL/TP', group = 'Fixed SL/TP')
fixedUnit = input.string('ATR', 'Unit', options = ['ATR', 'Points'], group = 'Fixed SL/TP')
fixedStop = input.float(1.0, 'Stop Size', step = 0.1, minval = 0.0, group = 'Fixed SL/TP')

tpCalc(d) =>
    fixedUnit == 'ATR' ? d * atrVal : d

tp1Enable = input.bool(false, 'TP1', inline = 'tp1', group = 'Fixed SL/TP')
tp1Size = input.float(1.5, '', inline = 'tp1', group = 'Fixed SL/TP')
tp2Enable = input.bool(false, 'TP2', inline = 'tp2', group = 'Fixed SL/TP')
tp2Size = input.float(3.0, '', inline = 'tp2', group = 'Fixed SL/TP')
tp3Enable = input.bool(false, 'TP3', inline = 'tp3', group = 'Fixed SL/TP')
tp3Size = input.float(4.0, '', inline = 'tp3', group = 'Fixed SL/TP')

// Smart Profit Locker (Aggressive Profit Protection)
smartProfitEnable = input.bool(false, '🎯 Enable Smart Profit Locker', group = 'Smart Profit Locker', tooltip = 'Aggressive profit-taking with adjustable pullback sensitivity')
smartProfitType = input.string('ATR', 'Type', options = ['ATR', 'Points', 'Percent'], group = 'Smart Profit Locker')
smartProfitVal = input.float(3.1, 'Value', step = 0.1, group = 'Smart Profit Locker')
smartProfitOffset = input.float(0.10, 'Pullback %', step = 0.05, minval = 0.01, maxval = 1.0, group = 'Smart Profit Locker', tooltip = 'Pullback percentage to trigger exit (0.10 = 10%)')
// CRITICAL FIX: User-configurable fallback for invalid calculations
smartProfitFallback = input.float(50.0, 'Fallback Value', step = 1.0, minval = 0.1, group = 'Smart Profit Locker', tooltip = 'Fallback value when calculation fails. Set appropriately for your symbol: Forex ~0.001, Crypto ~1.0, Stocks ~0.50')

// ─── Compatibility Alias Variables (legacy names referenced later) ───
// These bridge old variable names used in preserved exit logic.
smartProfitMultiplier = smartProfitVal  // Legacy name mapping
fixedSlTpEnable = fixedEnable           // Fix typo in later logic
fixedStopLoss = fixedStop               // Stop-loss size alias
fixedTakeProfit = tp1Size               // Default take-profit size (TP1) as placeholder
maExitEnable = maExitOn                 // MA exit enable alias
maExitLine = priceMA                    // MA line alias
trendRiderSignalExit = true             // Default allow signal-based exit (can be later wired to input)


// Traditional Trailing Stop - REMOVED (use Smart Profit Locker with 100% offset for traditional behavior)

// ─────────────────── 4 · BACKTESTING PANEL CONTROLS ─────────────────────
showBacktestTable = input.bool(true, '📊 Individual Signal Backtest', group = '🔍 Backtesting Panels', tooltip = 'Show individual signal performance (existing table)')
backtestLookback = input.string('7 Days', 'Backtest Lookback Period', options = ['3 Days', '7 Days', '30 Days', '90 Days'], group = '🔍 Backtesting Panels', tooltip = 'How far back to analyze performance')

// ═══════════════════ ENTRY SIGNAL DECLARATIONS (BUG FIX) ═══════════════════
// CRITICAL FIX: Declare entry signal variables here, assign values after filter calculations
// This fixes the circular dependency where signals were used before being calculated

// Entry signal variable declarations (assigned later after all filters are calculated)
var bool longEntrySignal = false
var bool shortEntrySignal = false

// Initialize debug logging on first bar
if barstate.isfirst
    debugInfo('EZAlgoTrader initialized with debug logging')


// ═══════════════════ REAL STRATEGY EXIT LOGIC (CRITICAL FIX) ═══════════════════
// This section bridges the gap between combo backtesting and actual strategy execution
// All exit methods now control the REAL strategy, not just the display panel

// Track entry price for distance-based exits
var float strategyEntryPrice = na

// ═══════════════════ EXIT CONTROL FLAGS (INTRABAR SYSTEM) ═══════════════════
// Per-method flags to prevent duplicate alerts and enable prioritization
var bool maExitSent = false
var bool fixedExitSent = false
var bool fibExitSent = false
var bool trailExitSent = false
var bool customExitSent = false
var bool inPosition = false
var bool exitInProgress = false

// Position tracking and flag reset logic
if strategy.position_size == 0
    strategyEntryPrice := na
else if strategy.position_size != 0 and na(strategyEntryPrice)
    strategyEntryPrice := strategy.position_avg_price

// Reset all exit flags on new position entry
currentPosition = strategy.position_size != 0
if currentPosition and not inPosition
    // New trade detected - reset all flags
    maExitSent := false
    fixedExitSent := false
    fibExitSent := false
    trailExitSent := false
    customExitSent := false
    exitInProgress := false
    inPosition := true
else if not currentPosition and inPosition
    // Trade closed - update state
    inPosition := false

// ═══════════════════ ROBUST INTRABAR EXIT SYSTEM ═══════════════════
// Exit logic that works properly while preventing alert spam
// Key insight: strategy.exit() calls must run every bar, only alerts should be limited

// ──────── 1. MA EXIT (Intrabar with Anti-Spam) ────────────
if maExitOn and strategy.position_size != 0
    longMaExit = strategy.position_size > 0 and close < priceMA
    shortMaExit = strategy.position_size < 0 and close > priceMA
    
    if longMaExit and not maExitSent
        strategy.close('Long', comment='MA Exit ', alert_message=longExitMsg)
        maExitSent := true
    else if shortMaExit and not maExitSent
        strategy.close('Short', comment='MA Exit ', alert_message=shortExitMsg)
        maExitSent := true

// ──────── 2. FIXED SL/TP (Always Active) ────────────
if fixedEnable and not na(strategyEntryPrice) and strategy.position_size != 0
    stopDistance = tpCalc(fixedStop)
    profitDistance = tp1Enable ? tpCalc(tp1Size) : na
    
    // Ensure distances are valid
    if na(stopDistance) or stopDistance <= 0
        stopDistance := 0.01  // Safe default
    
    if strategy.position_size > 0  // Long position
        stopLevel = math.max(strategyEntryPrice - stopDistance, close * 0.99)
        profitLevel = not na(profitDistance) ? strategyEntryPrice + profitDistance : na
        strategy.exit('Fixed-Long', from_entry='Long', stop=stopLevel, limit=profitLevel, comment='Fixed SL/TP')
        if not fixedExitSent
            fixedExitSent := true
    
    else if strategy.position_size < 0  // Short position
        stopLevel = math.min(strategyEntryPrice + stopDistance, close * 1.01)
        profitLevel = not na(profitDistance) ? strategyEntryPrice - profitDistance : na
        strategy.exit('Fixed-Short', from_entry='Short', stop=stopLevel, limit=profitLevel, comment='Fixed SL/TP')
        if not fixedExitSent
            fixedExitSent := true



// ──────── 4. SMART PROFIT LOCKER (Aggressive Profit Protection) ────────────
// NEW TREND-EXIT/HOLD FILTER INTEGRATION: Block Smart Profit Locker when trend-hold filters are active
// Only run Smart Profit Locker when trend-exit is allowed by the new filter system
if smartProfitEnable and strategy.position_size != 0 and allowTrendExit
    smartDistance = smartProfitType == 'ATR' ? smartProfitVal * atrVal : smartProfitType == 'Points' ? smartProfitVal : strategyEntryPrice * smartProfitVal / 100.0
    
    // CRITICAL FIX: Symbol-aware Smart Profit Locker validation
    // Replace hardcoded fallback with dynamic symbol-appropriate defaults
    if na(smartDistance) or smartDistance <= 0
        // Dynamic fallback based on symbol type and current price
        symbolType = syminfo.type
        currentPrice = close
        
        // Symbol-aware fallback calculation
        smartDistance := symbolType == "forex" ? currentPrice * 0.001 : symbolType == "crypto" ? currentPrice * 0.005 : currentPrice < 10 ? currentPrice * 0.02 : currentPrice < 100 ? currentPrice * 0.01 : currentPrice * 0.005
        
        // Ensure minimum viable distance (never less than 1 tick)
        smartDistance := math.max(smartDistance, syminfo.mintick * 10)
    
    // SIMPLIFIED EXIT BEHAVIOR (Hybrid mode removed)
    // Use regular Smart Profit Locker settings
    smartOffset := smartDistance * math.max(smartProfitOffset, 0.01)
    exitComment := 'Smart Profit Locker'
    
    if strategy.position_size > 0  // Long position
        strategy.exit('Smart-Long', from_entry='Long', trail_points=math.max(smartDistance, 0.01), trail_offset=math.max(smartOffset, 0.01), comment=exitComment)
        if not trailExitSent
            trailExitSent := true
    else if strategy.position_size < 0  // Short position
        strategy.exit('Smart-Short', from_entry='Short', trail_points=math.max(smartDistance, 0.01), trail_offset=math.max(smartOffset, 0.01), comment=exitComment)
        if not trailExitSent
            trailExitSent := true

// ═══════════════════ RBW FILTER COMPLETELY REMOVED ═══════════════════
// All RBW filter inputs and logic have been permanently removed to eliminate clutter

// ═══════════════════ LEGACY TREND-RIDING SYSTEM REMOVED ═══════════════════
// The old trend-riding overlay system has been completely removed to eliminate conflicts.
// All trend-based exit logic is now handled by the new Trend-Exit/Hold Filter System below.

// ═══════════════════ TREND-EXIT/HOLD FILTER SYSTEM ═══════════════════
// Visually clear, mechanically simple filters to hold trades longer during obvious trends

// Adaptive SuperTrend "3" Filter (Row 8) - Already implemented
adaptiveExitFilterEnable = input.bool(false, '🔥 Adaptive ST "3" Hold', group='🎯 Trend-Exit Filters', inline='te1', tooltip='Hold trades when Adaptive SuperTrend shows "3" (high volatility). Simple rule: "If you see a 3, don\'t exit"')
adaptiveHoldOn3 = input.bool(true, 'Hold on "3"', group='🎯 Trend-Exit Filters', inline='te1', tooltip='Do not exit when Adaptive SuperTrend displays "3" (high volatility regime)')
adaptiveHoldOn2 = input.bool(false, 'Hold on "2"', group='🎯 Trend-Exit Filters', inline='te1', tooltip='Do not exit when Adaptive SuperTrend displays "2" (medium volatility regime)')
adaptiveHoldOn1 = input.bool(false, 'Hold on "1"', group='🎯 Trend-Exit Filters', inline='te1', tooltip='Do not exit when Adaptive SuperTrend displays "1" (low volatility regime)')

// Moving Average Crossover Filter (Row 9)
maCrossoverFilterEnable = input.bool(false, '📈 MA Crossover Hold', group='🎯 Trend-Exit Filters', inline='te2', tooltip='Hold trades until moving averages cross over. Clear visual crossover signal on chart.')
maCrossoverFastLength = input.int(8, 'Fast MA', minval=1, maxval=50, group='🎯 Trend-Exit Filters', inline='te2', tooltip='Fast moving average length (e.g., 8 SMA)')
maCrossoverSlowLength = input.int(35, 'Slow MA', minval=10, maxval=200, group='🎯 Trend-Exit Filters', inline='te2', tooltip='Slow moving average length (e.g., 35 SMA)')
maCrossoverType = input.string('SMA', 'MA Type', options=['SMA', 'EMA', 'WMA'], group='🎯 Trend-Exit Filters', inline='te2b', tooltip='Type of moving average to use for crossover detection')

// Per-Indicator Trend Exit Toggles (Row 10-11)
indicatorExitHeader = input.string('--- Individual Trend Indicator Exits ---', 'Indicator Exit Config', group='🎯 Trend-Exit Filters', inline='te3', tooltip='Each trend indicator can be used as an individual trend exit. Allows testing each indicator as sole trend exit method.')

// First row of indicator exits
hullTrendExit = input.bool(false, '🌊 Hull Exit', group='🎯 Trend-Exit Filters', inline='te4', tooltip='Exit when Hull Suite trend changes direction')
supertrendTrendExit = input.bool(false, '⚡ SuperTrend Exit', group='🎯 Trend-Exit Filters', inline='te4', tooltip='Exit when SuperTrend direction changes')
quadrantTrendExit = input.bool(false, '🎯 Quadrant Exit', group='🎯 Trend-Exit Filters', inline='te4', tooltip='Exit when Quadrant NW trend changes')

// Second row of indicator exits
adaptiveTrendExit = input.bool(false, '🔄 Adaptive Exit', group='🎯 Trend-Exit Filters', inline='te5', tooltip='Exit when Adaptive SuperTrend trend changes')
volumaticTrendExit = input.bool(false, '📊 Volumatic Exit', group='🎯 Trend-Exit Filters', inline='te5', tooltip='Exit when Volumatic VIDYA trend changes')
smoothHATrendExit = input.bool(false, '🕯️ Smooth HA Exit', group='🎯 Trend-Exit Filters', inline='te5', tooltip='Exit when Smooth Heiken Ashi trend changes')

// External Trend Exit Signal (Row 12)
trendExitSignalEnable = input.bool(false, '📡 External Trend Exit', group='🎯 Trend-Exit Filters', inline='te6', tooltip='Use external indicator (like Trend Strength) for trend exit signals. Connect to buy/sell signal from external indicator.')
trendExitSignalSrc = input.source(close, 'Signal Source', group='🎯 Trend-Exit Filters', inline='te6', tooltip='Connect this to the buy/sell signal output from your external trend exit indicator (e.g., Trend Strength arrows)')

// Filter Combination Logic (Row 13)
trendExitLogic = input.string('Any Filter Triggers Exit', 'Exit Logic', options=['Any Filter Triggers Exit', 'All Filters Must Agree'], group='🎯 Trend-Exit Filters', inline='te7', tooltip='ANY: Exit when first filter condition is met. ALL: Wait for all enabled filters to agree before exiting.')
trendExitDebug = input.bool(false, 'Show Debug Info', group='🎯 Trend-Exit Filters', inline='te7', tooltip='Display debug information about trend-exit filter status on chart')

// ═══════════════════ DIRECTIONAL BIAS SELECTION SYSTEM ═══════════════════
// Choose which trend indicators/inputs to use for directional bias determination

// Master Controls
useLegacyTrendSystem = input.bool(false, '🔄 Use Legacy Trend System', group='🎯 Directional Bias Selection', inline='db1', tooltip='Enable the old trend-following system. Disable this to use only the new flexible bias selection system.')

// Primary Directional Bias Source
primaryBiasSource = input.string('Hull Suite', 'Primary Bias Source', options=['Hull Suite', 'SuperTrend', 'Quadrant NW', 'Adaptive SuperTrend', 'Volumatic VIDYA', 'Smooth Heiken Ashi', 'External Input', 'Price Action'], group='🎯 Directional Bias Selection', inline='db2', tooltip='Primary source for determining directional bias')

// Secondary Directional Bias Source (for confluence)
secondaryBiasSource = input.string('None', 'Secondary Bias Source', options=['None', 'Hull Suite', 'SuperTrend', 'Quadrant NW', 'Adaptive SuperTrend', 'Volumatic VIDYA', 'Smooth Heiken Ashi', 'External Input', 'Price Action'], group='🎯 Directional Bias Selection', inline='db3', tooltip='Optional secondary source for bias confluence. Set to None to use only primary source.')

// External Input for Custom Bias
externalBiasEnable = input.bool(false, '📡 External Bias Input', group='🎯 Directional Bias Selection', inline='db4', tooltip='Enable external input for custom directional bias (e.g., from another indicator)')
externalBiasSrc = input.source(close, 'External Source', group='🎯 Directional Bias Selection', inline='db4', tooltip='Connect to external indicator output for custom bias determination')

// Bias Confluence Logic
biasConfluenceMode = input.string('Primary Only', 'Bias Confluence', options=['Primary Only', 'Both Must Agree', 'Either Can Trigger'], group='🎯 Directional Bias Selection', inline='db5', tooltip='Primary Only: Use only primary source | Both Must Agree: Both sources must agree | Either Can Trigger: Either source can determine bias')

// Individual Trend Indicator Enable/Disable Controls
indicatorControlsHeader = input.string('--- Individual Indicator Controls ---', 'Indicator Controls', group='🎯 Directional Bias Selection', inline='db6', tooltip='Enable/disable individual trend indicators for bias calculation')

// Row 1: Core Indicators
hullBiasEnable = input.bool(true, '🌊 Hull Suite', group='🎯 Directional Bias Selection', inline='db7', tooltip='Enable Hull Suite for bias calculation')
supertrendBiasEnable = input.bool(false, '⚡ SuperTrend', group='🎯 Directional Bias Selection', inline='db7', tooltip='Enable SuperTrend for bias calculation')
quadrantBiasEnable = input.bool(false, '🎯 Quadrant NW', group='🎯 Directional Bias Selection', inline='db7', tooltip='Enable Quadrant NW for bias calculation')

// Row 2: Advanced Indicators
adaptiveBiasEnable = input.bool(false, '🤖 Adaptive ST', group='🎯 Directional Bias Selection', inline='db8', tooltip='Enable Adaptive SuperTrend for bias calculation')
volumaticBiasEnable = input.bool(false, '📊 Volumatic', group='🎯 Directional Bias Selection', inline='db8', tooltip='Enable Volumatic VIDYA for bias calculation')
smoothHABiasEnable = input.bool(false, '🕯️ Smooth HA', group='🎯 Directional Bias Selection', inline='db8', tooltip='Enable Smooth Heiken Ashi for bias calculation')

// ═══════════════════ EXTENDED BIAS FILTERS (6 INDICATORS) ═══════════════════
// Professional trend-based directional bias filters with confluence logic

// Confluence Logic (Row 1)
biasConfluence = input.string('Any', 'Confluence Mode', options=['Any', 'Majority', 'All'], group='🎯 Extended Bias Filters', inline='conf1', tooltip='Any: At least one filter agrees | Majority: Most filters agree | All: All enabled filters agree')

// ──────── ROW 1: CORE TREND FILTERS ────────────
// Hull Suite Filter (Section 1)
hullEnable = input.bool(true, '📈 Hull Suite', group='🎯 Extended Bias Filters', inline='hull1')
hullLength = input.int(55, 'Length', minval=10, maxval=200, group='🎯 Extended Bias Filters', inline='hull1')
hullMode = input.string('Hma', 'Type', options=['Hma', 'Ehma', 'Thma'], group='🎯 Extended Bias Filters', inline='hull2')

// SuperTrend Filter (Section 2)
supertrendEnable = input.bool(false, '🔥 SuperTrend', group='🎯 Extended Bias Filters', inline='st1')
supertrendFactor = input.float(3.0, 'Factor', minval=1.0, maxval=10.0, step=0.1, group='🎯 Extended Bias Filters', inline='st1')
supertrendATR = input.int(10, 'ATR', minval=5, maxval=50, group='🎯 Extended Bias Filters', inline='st2')

// Quadrant NW Filter (Section 3) - FULL NADARAYA-WATSON IMPLEMENTATION
quadrantEnable = input.bool(false, '📊 Quadrant NW', group='🎯 Extended Bias Filters', inline='quad1')
quadrantLookback = input.float(8.0, 'Lookback Window', minval=3.0, maxval=50.0, step=0.5, group='🎯 Extended Bias Filters', inline='quad1', tooltip='The number of bars used for the estimation. Recommended range: 3-50')
quadrantRelativeWeight = input.float(8.0, 'Relative Weighting', minval=0.25, maxval=25.0, step=0.25, group='🎯 Extended Bias Filters', inline='quad2', tooltip='Relative weighting of time frames. Lower values = more long-term influence. Recommended range: 0.25-25')
quadrantStartBar = input.int(25, 'Start Regression at Bar', minval=5, maxval=50, group='🎯 Extended Bias Filters', inline='quad2', tooltip='Bar index to start regression. Omits volatile initial bars. Recommended range: 5-25')

// ──────── ROW 2: ADVANCED TREND FILTERS ────────────
// Adaptive SuperTrend Filter (Section 4) - FULL K-MEANS IMPLEMENTATION
adaptiveSTEnable = input.bool(false, '🤖 Adaptive ST', group='🎯 Extended Bias Filters', inline='ast1')
// Full K-means Clustering Parameters (matching Adaptive.pine exactly)
adaptive_atr_len = input.int(10, 'ATR Length', minval=5, maxval=50, group='🎯 Extended Bias Filters', inline='ast3')
adaptive_fact = input.float(3.0, 'SuperTrend Factor', minval=1.0, maxval=10.0, step=0.1, group='🎯 Extended Bias Filters', inline='ast3')
adaptive_training_period = input.int(100, 'Training Period', minval=50, maxval=200, group='🎯 Extended Bias Filters', inline='ast4')
adaptive_highvol = input.float(0.75, 'High Vol %', minval=0.5, maxval=1.0, step=0.05, group='🎯 Extended Bias Filters', inline='ast4')
adaptive_midvol = input.float(0.5, 'Med Vol %', minval=0.3, maxval=0.7, step=0.05, group='🎯 Extended Bias Filters', inline='ast5')
adaptive_lowvol = input.float(0.25, 'Low Vol %', minval=0.1, maxval=0.5, step=0.05, group='🎯 Extended Bias Filters', inline='ast5')

// Volumatic VIDYA Filter (Section 5) - FULL VARIABLE INDEX DYNAMIC AVERAGE
volumaticEnable = input.bool(false, '📊 Volumatic', group='🎯 Extended Bias Filters', inline='vol1')
volumaticLength = input.int(10, 'VIDYA Length', minval=5, maxval=100, group='🎯 Extended Bias Filters', inline='vol1', tooltip='Length of the VIDYA calculation')
volumaticMomentum = input.int(20, 'VIDYA Momentum', minval=5, maxval=50, group='🎯 Extended Bias Filters', inline='vol2', tooltip='Momentum length for VIDYA calculation')
volumaticBandDistance = input.float(2.0, 'Band Distance', minval=0.1, maxval=5.0, step=0.1, group='🎯 Extended Bias Filters', inline='vol2', tooltip='Distance factor for upper/lower bands')

// Smoothed Heiken Ashi Filter (Section 6) - FULL DUAL SMOOTHING IMPLEMENTATION
smoothHAEnable = input.bool(false, '🕯️ Smooth HA', group='🎯 Extended Bias Filters', inline='sha1')
// Before HA Smoothing (matching original SmoothHK.pine)
smoothHALength = input.int(10, 'Before Smooth Length', minval=1, maxval=50, group='🎯 Extended Bias Filters', inline='sha1', tooltip='Smooth length before HA calculation')
smoothHAMode = input.string('EMA', 'Before MA Type', options=['SMA', 'EMA', 'WMA', 'VWMA', 'RMA', 'DEMA', 'TEMA', 'HMA', 'ALMA', 'LSMA'], group='🎯 Extended Bias Filters', inline='sha2', tooltip='MA type for pre-HA smoothing')
// After HA Smoothing (matching original SmoothHK.pine)
smoothHAAfterLength = input.int(10, 'After Smooth Length', minval=1, maxval=50, group='🎯 Extended Bias Filters', inline='sha3', tooltip='Smooth length after HA calculation')
smoothHAAfterMode = input.string('EMA', 'After MA Type', options=['SMA', 'EMA', 'WMA', 'VWMA', 'RMA', 'DEMA', 'TEMA', 'HMA', 'ALMA', 'LSMA'], group='🎯 Extended Bias Filters', inline='sha3', tooltip='MA type for post-HA smoothing')

// ═══════════════════ DUAL-LAYER MODE SELECTION SYSTEM ═══════════════════
// Intelligent switching between scalping and trend-following modes
// LAYER 1: Step Channel Momentum (Structural Regime Filter)
// LAYER 2: CVD Channel Breakout (Institutional Confirmation)

// ──────── STEP CHANNEL MOMENTUM SETTINGS ────────────
stepChannelEnable = input.bool(true, "Enable Step Channel Filter", group="🎯 Dual-Layer Mode Selection")
stepChannelLength = input.int(3, "Step Channel Length", minval=1, maxval=50, group="🎯 Dual-Layer Mode Selection")
stepChannelMultiplier = input.float(0.6, "Step Channel Multiplier", minval=0.1, maxval=5.0, step=0.1, group="🎯 Dual-Layer Mode Selection")

// Step Channel Visual Settings
stepChannelShowVisuals = input.bool(true, "Show Step Channel Visuals", group="🎯 Dual-Layer Mode Selection")
stepChannelColorUp = input.color(color.rgb(26, 190, 127), "Momentum Up Color", inline="SC Colors", group="🎯 Dual-Layer Mode Selection")
stepChannelColorRange = input.color(color.orange, "Range Color", inline="SC Colors", group="🎯 Dual-Layer Mode Selection")
stepChannelColorDown = input.color(color.rgb(202, 38, 65), "Momentum Down Color", inline="SC Colors", group="🎯 Dual-Layer Mode Selection")
stepChannelShowPivots = input.bool(true, "Show Pivot Points", group="🎯 Dual-Layer Mode Selection")
stepChannelShowCandles = input.bool(true, "Show Momentum Candles", group="🎯 Dual-Layer Mode Selection")
stepChannelShowLines = input.bool(true, "Show Channel Lines", group="🎯 Dual-Layer Mode Selection")
stepChannelShowLabel = input.bool(true, "Show Market State Label", group="🎯 Dual-Layer Mode Selection")

// ──────── LAYER 2: CVD CHANNEL BREAKOUT SETTINGS ────────────
cvdEnable = input.bool(true, '📈 CVD Confirmation', group='🎯 Mode Selection', tooltip='Enable CVD institutional flow confirmation')
cvdAnchor = input.timeframe('120', 'CVD Anchor', group='🎯 Mode Selection', inline='cvd1', tooltip='120=2h, 240=4h, 1D=1day')
cvdThreshold = input.int(1000, 'CVD Threshold', minval=100, maxval=10000, group='🎯 Mode Selection', inline='cvd1', tooltip='CVD must be outside ±threshold for trend mode')
cvdUseCustomTimeframe = input.bool(false, 'Custom CVD TF', group='🎯 Mode Selection', inline='cvd2', tooltip='Override automatic timeframe selection')
cvdCustomTimeframe = input.timeframe('1', 'CVD Custom TF', group='🎯 Mode Selection', inline='cvd2', tooltip='Custom timeframe for CVD calculation')

// ──────── MODE SELECTION LOGIC SETTINGS ────────────
modeSelectionLogic = input.string('Both Required', 'Activation Logic', options=['Step Channel Only', 'CVD Only', 'Both Required', 'Either Filter'], group='🎯 Mode Selection', tooltip='How filters combine: Both Required = maximum selectivity')
scalpOnlyOverride = input.bool(false, 'Force Scalp Mode', group='🎯 Mode Selection', tooltip='Override all filters and force scalp-only mode for testing')
trendModeDebug = input.bool(false, 'Show Debug Info', group='🎯 Mode Selection', tooltip='Display mode selection debug information')

// ═══════════════════ DUAL-LAYER MODE SELECTION CALCULATIONS ═══════════════════
// Intelligent regime detection for scalp vs trend mode switching

// ──────── LAYER 1: STEP CHANNEL MOMENTUM CALCULATION ────────────
// Complete ChartPrime Step Channel Momentum implementation with full visuals
var string stepChannelState = "Range"
var bool stepChannelTrendMode = false
var float stepChannelPivotHigh = na
var float stepChannelPivotLow = na
var color stepChannelCurrentColor = color.orange

// Step Channel calculation variables (global scope for visual access)
var float stepChannelAvg = na
var float stepChannelUpper = na
var float stepChannelLower = na
var float stepChannelATR = na

if stepChannelEnable
    // COMPLETE Step Channel calculation (exact copy from ChartPrime Step Channel Momentum)
    // Calculate pivot highs and lows
    ph = ta.pivothigh(stepChannelLength, stepChannelLength)
    pl = ta.pivotlow(stepChannelLength, stepChannelLength)
    
    // Update pivot variables with visual markers
    if not na(ph)
        stepChannelPivotHigh := ph
        if stepChannelShowPivots and stepChannelShowVisuals
            label.new(bar_index-stepChannelLength, ph, "⬥", style=label.style_label_center, textcolor=chart.fg_color, size=size.normal, color=color(na))
    if not na(pl)
        stepChannelPivotLow := pl
        if stepChannelShowPivots and stepChannelShowVisuals
            label.new(bar_index-stepChannelLength, pl, "⬥", style=label.style_label_center, textcolor=chart.fg_color, size=size.normal, color=color(na))
    
    // Calculate average and ATR-based channel (exact ChartPrime formula)
    stepChannelAvg = math.avg(stepChannelPivotHigh, stepChannelPivotLow)
    stepChannelATR = ta.atr(200) * stepChannelMultiplier
    stepChannelUpper = stepChannelAvg + stepChannelATR
    stepChannelLower = stepChannelAvg - stepChannelATR
    
    // Determine market state and color (exact ChartPrime logic)
    if hl2 > stepChannelUpper
        stepChannelCurrentColor := stepChannelColorUp
        stepChannelTrendMode := true
        stepChannelState := "Momentum Up"
    else if hl2 < stepChannelLower
        stepChannelCurrentColor := stepChannelColorDown
        stepChannelTrendMode := false
        stepChannelState := "Momentum Down"
    else
        stepChannelCurrentColor := stepChannelColorRange
        stepChannelTrendMode := false
        stepChannelState := "Range"
    
    // VISUAL ELEMENTS - Complete ChartPrime visualization
    // NOTE: Plot functions moved to global scope to fix Pine Script compilation errors
    // Visual elements will be handled after the calculation block
else
    stepChannelState := "Disabled"
    stepChannelTrendMode := true  // Allow trend mode when disabled

// ──────── LAYER 2: CVD CHANNEL BREAKOUT CALCULATION ────────────
var bool cvdTrendMode = false
var float cvdValue = na

if cvdEnable
    // CVD timeframe selection
    cvdTimeframe = cvdUseCustomTimeframe ? cvdCustomTimeframe : 
                   timeframe.isseconds ? "1S" :
                   timeframe.isintraday ? "1" :
                   timeframe.isdaily ? "5" : "60"
    
    // FIXED: Proper CVD calculation using TradingView's built-in function
    // This replaces the incorrect manual volume delta calculation
    cvdData = request.security(syminfo.tickerid, cvdAnchor, ta.cum(volume * (close > open ? 1 : close < open ? -1 : 0)))
    cvdValue := cvdData
    
    // Simple channel breakout logic
    cvdTrendMode := math.abs(cvdValue) > cvdThreshold
else
    cvdTrendMode := true  // Allow trend mode when disabled
    cvdValue := 0

// ──────── DUAL-LAYER MODE SELECTION LOGIC ────────────
var bool scalpOnlyMode = true
var bool trendFollowingMode = false
var string currentTradingMode = "SCALP"

if scalpOnlyOverride
    // Force scalp mode override
    scalpOnlyMode := true
    trendFollowingMode := false
    currentTradingMode := "SCALP (FORCED)"
else
    // Apply dual-layer logic based on user selection
    switch modeSelectionLogic
        "Step Channel Only" =>
            trendFollowingMode := stepChannelTrendMode
        "CVD Only" =>
            trendFollowingMode := cvdTrendMode
        "Both Required" =>
            trendFollowingMode := stepChannelTrendMode and cvdTrendMode
        "Either Filter" =>
            trendFollowingMode := stepChannelTrendMode or cvdTrendMode
    
    scalpOnlyMode := not trendFollowingMode
    currentTradingMode := trendFollowingMode ? "TREND" : "SCALP"

// ──────── MODE SELECTION DEBUG AND VISUALIZATION ────────────
if trendModeDebug and barstate.islast
    var table debugTable = table.new(position.top_left, 3, 6, bgcolor=color.new(color.white, 80), border_width=1)
    
    table.cell(debugTable, 0, 0, "Mode Selection Debug", text_color=color.black, text_size=size.normal, bgcolor=color.new(color.blue, 70))
    table.cell(debugTable, 1, 0, "", bgcolor=color.new(color.blue, 70))
    table.cell(debugTable, 2, 0, "", bgcolor=color.new(color.blue, 70))
    
    table.cell(debugTable, 0, 1, "Step Channel:", text_color=color.black, text_size=size.small)
    table.cell(debugTable, 1, 1, stepChannelState, text_color=color.black, text_size=size.small)
    table.cell(debugTable, 2, 1, stepChannelTrendMode ? "✓" : "✗", text_color=stepChannelTrendMode ? color.green : color.red, text_size=size.small)
    
    table.cell(debugTable, 0, 2, "CVD Value:", text_color=color.black, text_size=size.small)
    table.cell(debugTable, 1, 2, str.tostring(math.round(cvdValue)), text_color=color.black, text_size=size.small)
    table.cell(debugTable, 2, 2, cvdTrendMode ? "✓" : "✗", text_color=cvdTrendMode ? color.green : color.red, text_size=size.small)
    
    table.cell(debugTable, 0, 3, "CVD Threshold:", text_color=color.black, text_size=size.small)
    table.cell(debugTable, 1, 3, "±" + str.tostring(cvdThreshold), text_color=color.black, text_size=size.small)
    table.cell(debugTable, 2, 3, "", text_color=color.black, text_size=size.small)
    
    table.cell(debugTable, 0, 4, "Mode Logic:", text_color=color.black, text_size=size.small)
    table.cell(debugTable, 1, 4, modeSelectionLogic, text_color=color.black, text_size=size.small)
    table.cell(debugTable, 2, 4, "", text_color=color.black, text_size=size.small)
    
    table.cell(debugTable, 0, 5, "Trading Mode:", text_color=color.black, text_size=size.small)
    modeColor = trendFollowingMode ? color.new(color.orange, 50) : color.new(color.blue, 50)
    table.cell(debugTable, 1, 5, currentTradingMode, text_color=color.white, text_size=size.small, bgcolor=modeColor)
    table.cell(debugTable, 2, 5, "", text_color=color.black, text_size=size.small)

// Mode label on chart
if stepChannelShowLabel and barstate.islast
    label.new(bar_index, high, currentTradingMode, 
              color=trendFollowingMode ? color.new(color.orange, 0) : color.new(color.blue, 0), 
              textcolor=color.white, 
              style=label.style_label_down, 
              size=size.normal,
              tooltip="Current Trading Mode\nStep Channel: " + stepChannelState + "\nCVD: " + str.tostring(math.round(cvdValue)))

// ═══════════════════ HULL SUITE CALCULATION ═══════════════════
// Hull Moving Average trend detection

// Hull MA calculation functions (must be defined outside conditional blocks)
HMA(src, length) =>
    ta.wma(2 * ta.wma(src, length / 2) - ta.wma(src, length), math.round(math.sqrt(length)))

EHMA(src, length) =>
    ta.ema(2 * ta.ema(src, length / 2) - ta.ema(src, length), math.round(math.sqrt(length)))

THMA(src, length) =>
    ta.wma(ta.wma(src, length / 3) * 3 - ta.wma(src, length / 2) - ta.wma(src, length), length)

var float hullMA = na
var bool hullBullish = false

if hullEnable
    
    // CRITICAL FIX: THMA should use full hullLength, not divided by 2
    hullMA := hullMode == 'Hma' ? HMA(close, hullLength) : hullMode == 'Ehma' ? EHMA(close, hullLength) : hullMode == 'Thma' ? THMA(close, hullLength) : na
    
    // Determine trend direction (current > 2 bars ago = bullish)
    hullBullish := not na(hullMA) and hullMA > hullMA[2]
else
    // When disabled, set neutral (allow all trades)
    hullBullish := false

// ═══════════════════ SUPERTREND CALCULATION ═══════════════════
// SuperTrend directional bias
var float supertrend = na
var float supertrendDirection = na
var bool supertrendBullish = false

if supertrendEnable
    [st, dir] = ta.supertrend(supertrendFactor, supertrendATR)
    supertrend := st
    supertrendDirection := dir
    
    // CRITICAL FIX: SuperTrend Direction Logic Verification
    // Pine Script ta.supertrend() returns:
    // dir = 1 when price is BELOW SuperTrend (bearish/downtrend)
    // dir = -1 when price is ABOVE SuperTrend (bullish/uptrend)
    // Therefore: bullish when dir < 0 (dir = -1) is CORRECT
    supertrendBullish := dir < 0  // Verified: Uptrend when direction = -1
else
    // When disabled, set neutral (allow all trades)
    supertrendBullish := false

// ═══════════════════ QUADRANT (NADARAYA-WATSON) CALCULATION ═══════════════════
// Rational Quadratic Kernel regression for trend detection

// Nadaraya-Watson Kernel Regression Function (exact copy from original Quadrant.pine)
kernel_regression(_src, _size, _h, _r, _x_0) =>
    float _currentWeight = 0.
    float _cumulativeWeight = 0.
    for i = 0 to _size + _x_0 by 1
        y = _src[i]
        w = math.pow(1 + math.pow(i, 2) / (math.pow(_h, 2) * 2 * _r), -_r)
        _currentWeight := _currentWeight + y * w
        _cumulativeWeight := _cumulativeWeight + w
        _cumulativeWeight
    _currentWeight / _cumulativeWeight

var float quadrantEstimate = na
var bool quadrantBullish = false

if quadrantEnable
    // Calculate kernel estimate using proper Nadaraya-Watson parameters
    size = array.size(array.from(close))  // Size of data series
    quadrantEstimate := kernel_regression(close, size, quadrantLookback, quadrantRelativeWeight, quadrantStartBar)
    
    // Determine trend direction (matching original logic)
    quadrantBullish := not na(quadrantEstimate) and quadrantEstimate > quadrantEstimate[1]
else
    // When disabled, set neutral (allow all trades)
    quadrantBullish := false



// ═══════════════════ ADAPTIVE SUPERTREND (FULL K-MEANS IMPLEMENTATION) ═══════════════════
// Complete restoration of Adaptive.pine algorithm with K-means clustering
// Provides volatility classification numbers (1/2/3) for exit filter system

// Pine SuperTrend function (from Adaptive.pine)
adaptive_pine_supertrend(factor, atr_val) =>
    src = hl2
    upperBand = src + factor * atr_val
    lowerBand = src - factor * atr_val
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])
    
    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    int _direction = na
    float superTrend = na
    prevSuperTrend = superTrend[1]
    if na(atr_val[1])
        _direction := 1
    else if prevSuperTrend == prevUpperBand
        _direction := close > upperBand ? -1 : 1
    else
        _direction := close < lowerBand ? 1 : -1
    superTrend := _direction == -1 ? lowerBand : upperBand
    [superTrend, _direction]

// Preserve existing interface variables for backward compatibility
var bool adaptiveSTBullish = false
var float adaptiveST = na
var int adaptiveSTDirection = 1

if adaptiveSTEnable
    // Full K-means clustering algorithm (exact copy from Adaptive.pine)
    volatility = ta.atr(adaptive_atr_len)
    
    upper = ta.highest(volatility, adaptive_training_period)
    lower = ta.lowest(volatility, adaptive_training_period)
    
    high_volatility = lower + (upper - lower) * adaptive_highvol
    medium_volatility = lower + (upper - lower) * adaptive_midvol
    low_volatility = lower + (upper - lower) * adaptive_lowvol
    
    adaptive_iterations := 0
    size_a = 0
    size_b = 0
    size_c = 0
    
    // Initialize centroids on first run
    if array.size(adaptive_amean) == 1 and array.get(adaptive_amean, 0) == 0
        array.set(adaptive_amean, 0, high_volatility)
        array.set(adaptive_bmean, 0, medium_volatility)
        array.set(adaptive_cmean, 0, low_volatility)
    
    // K-means clustering with iterative convergence (from Adaptive.pine)
    if nz(volatility) > 0 and bar_index >= adaptive_training_period - 1
        // Iterative K-means algorithm
        while ((array.size(adaptive_amean) == 1 ? true : (array.get(adaptive_amean, 0) != array.get(adaptive_amean, math.min(1, array.size(adaptive_amean) - 1)))) or 
               (array.size(adaptive_bmean) == 1 ? true : (array.get(adaptive_bmean, 0) != array.get(adaptive_bmean, math.min(1, array.size(adaptive_bmean) - 1)))) or 
               (array.size(adaptive_cmean) == 1 ? true : (array.get(adaptive_cmean, 0) != array.get(adaptive_cmean, math.min(1, array.size(adaptive_cmean) - 1))))) and adaptive_iterations < 10
            
            array.clear(adaptive_hv)
            array.clear(adaptive_mv)
            array.clear(adaptive_lv)
            
            // Assign data points to clusters
            for i = adaptive_training_period - 1 to 0 by 1
                _1 = math.abs(volatility[i] - array.get(adaptive_amean, 0))
                _2 = math.abs(volatility[i] - array.get(adaptive_bmean, 0))
                _3 = math.abs(volatility[i] - array.get(adaptive_cmean, 0))
                
                if _1 < _2 and _1 < _3
                    array.unshift(adaptive_hv, volatility[i])
                else if _2 < _1 and _2 < _3
                    array.unshift(adaptive_mv, volatility[i])
                else if _3 < _1 and _3 < _2
                    array.unshift(adaptive_lv, volatility[i])
            
            // Update centroids
            if array.size(adaptive_hv) > 0
                array.unshift(adaptive_amean, array.avg(adaptive_hv))
            if array.size(adaptive_mv) > 0
                array.unshift(adaptive_bmean, array.avg(adaptive_mv))
            if array.size(adaptive_lv) > 0
                array.unshift(adaptive_cmean, array.avg(adaptive_lv))
            
            size_a := array.size(adaptive_hv)
            size_b := array.size(adaptive_mv)
            size_c := array.size(adaptive_lv)
            adaptive_iterations := adaptive_iterations + 1
    
    // Get current centroids
    hv_new = array.size(adaptive_amean) > 0 ? array.get(adaptive_amean, 0) : high_volatility
    mv_new = array.size(adaptive_bmean) > 0 ? array.get(adaptive_bmean, 0) : medium_volatility
    lv_new = array.size(adaptive_cmean) > 0 ? array.get(adaptive_cmean, 0) : low_volatility
    
    // Calculate distances to each centroid
    vdist_a = math.abs(volatility - hv_new)
    vdist_b = math.abs(volatility - mv_new)
    vdist_c = math.abs(volatility - lv_new)
    
    // Assign to closest cluster (0=high, 1=medium, 2=low)
    adaptiveCluster := vdist_a <= vdist_b and vdist_a <= vdist_c ? 0 : 
                      vdist_b <= vdist_a and vdist_b <= vdist_c ? 1 : 2
    
    // Convert cluster to display number (matching Adaptive.pine exactly)
    adaptiveNumber := 4 - (adaptiveCluster + 1)  // 0->3, 1->2, 2->1
    
    // Get assigned centroid for SuperTrend calculation
    adaptive_assigned_centroid := adaptiveCluster == 0 ? hv_new : adaptiveCluster == 1 ? mv_new : lv_new
    
    // Calculate Adaptive SuperTrend using assigned centroid
    [adaptive_ST_calc, adaptive_dir_calc] = adaptive_pine_supertrend(adaptive_fact, adaptive_assigned_centroid)
    
    // Update interface variables for backward compatibility
    adaptiveST := adaptive_ST_calc
    adaptiveSTDirection := adaptive_dir_calc
    adaptiveSTBullish := adaptive_dir_calc < 0  // Bullish when direction = -1
else
    adaptiveSTBullish := false
    adaptiveCluster := 1  // Default to medium volatility
    adaptiveNumber := 2   // Default to number 2

// ═══════════════════ ADAPTIVE SUPERTREND EXIT FILTER SYSTEM ═══════════════════
// Revolutionary exit filter using volatility classification numbers (1/2/3)
// Blocks scalp exits during specific volatility regimes for better trend riding

if adaptiveExitFilterEnable and adaptiveSTEnable
    // Determine if current volatility number should block exits
    currentlyBlocked = (adaptiveNumber == 3 and adaptiveHoldOn3) or 
                      (adaptiveNumber == 2 and adaptiveHoldOn2) or 
                      (adaptiveNumber == 1 and adaptiveHoldOn1)
    
    // Update exit blocking status
    adaptiveExitBlocked := currentlyBlocked
    
    // Handle pending exit logic
    if adaptiveExitBlocked and not adaptiveExitBlocked[1]
        // Just entered blocked state - no action needed, just block new exits
        adaptivePendingExit := false
        adaptiveExitReason := na
    
    if not adaptiveExitBlocked and adaptiveExitBlocked[1]
        // Just exited blocked state - trigger any pending exits immediately
        if adaptivePendingExit
            // Exit will be triggered by normal exit logic since block is now lifted
            adaptivePendingExit := false
else
    // When filter is disabled, never block exits
    adaptiveExitBlocked := false
    adaptivePendingExit := false
    adaptiveExitReason := na

// ═══════════════════ VOLUMATIC VIDYA CALCULATION (FULL IMPLEMENTATION) ═══════════════════
// Complete Variable Index Dynamic Average with proper CMO and volume weighting
// Exact restoration from original Volumatic.pine by BigBeluga

// VIDYA (Variable Index Dynamic Average) function - exact copy from original
vidya_calc(src, vidya_length, vidya_momentum) =>
    float momentum = ta.change(src)
    float sum_pos_momentum = math.sum(momentum >= 0 ? momentum : 0.0, vidya_momentum)
    float sum_neg_momentum = math.sum(momentum >= 0 ? 0.0 : -momentum, vidya_momentum)
    float abs_cmo = math.abs(100 * (sum_pos_momentum - sum_neg_momentum) / (sum_pos_momentum + sum_neg_momentum))
    float alpha = 2 / (vidya_length + 1)
    var float vidya_value = 0.0
    vidya_value := alpha * abs_cmo / 100 * src + (1 - alpha * abs_cmo / 100) * nz(vidya_value[1])
    ta.sma(vidya_value, 15)  // Smoothed VIDYA as in original

var bool volumaticBullish = false
var float volumaticVIDYA = na
var bool volumatic_is_trend_up = false

if volumaticEnable
    // Calculate VIDYA using complete original algorithm
    volumaticVIDYA := vidya_calc(close, volumaticLength, volumaticMomentum)
    
    // Calculate ATR for band distance (matching original)
    atr_volumatic = ta.atr(200)
    
    // Calculate upper and lower bands
    volumatic_upper = volumaticVIDYA + (atr_volumatic * volumaticBandDistance)
    volumatic_lower = volumaticVIDYA - (atr_volumatic * volumaticBandDistance)
    
    // Trend detection logic (matching original sophisticated logic)
    trend_cross_up = ta.crossover(close, volumaticVIDYA)
    trend_cross_down = ta.crossunder(close, volumaticVIDYA)
    
    // Update trend state
    if trend_cross_up
        volumatic_is_trend_up := true
    else if trend_cross_down
        volumatic_is_trend_up := false
    
    // Bullish when in uptrend and price above VIDYA
    volumaticBullish := volumatic_is_trend_up and close > volumaticVIDYA
else
    volumaticBullish := false
    volumatic_is_trend_up := false

// ═══════════════════ SMOOTHED HEIKEN ASHI (FULL DUAL SMOOTHING IMPLEMENTATION) ═══════════════════
// Complete restoration of dual smoothing algorithm from original SmoothHK.pine
// Implements before-HA and after-HA smoothing with multiple MA types

// Advanced MA function supporting multiple types (matching original capabilities)
get_ma(src, length, ma_type) =>
    switch ma_type
        'SMA' => ta.sma(src, length)
        'EMA' => ta.ema(src, length)
        'WMA' => ta.wma(src, length)
        'VWMA' => ta.vwma(src, length)
        'RMA' => ta.rma(src, length)
        'DEMA' => 2 * ta.ema(src, length) - ta.ema(ta.ema(src, length), length)
        'TEMA' => 
            ema1 = ta.ema(src, length)
            ema2 = ta.ema(ema1, length)
            ema3 = ta.ema(ema2, length)
            3 * ema1 - 3 * ema2 + ema3
        'HMA' => ta.wma(2 * ta.wma(src, length / 2) - ta.wma(src, length), math.round(math.sqrt(length)))
        'ALMA' => ta.alma(src, length, 0.85, 6)
        'LSMA' => ta.linreg(src, length, 0)
        => ta.ema(src, length)  // Default fallback

var bool smoothHABullish = false
var float smoothHA_o = na
var float smoothHA_h = na
var float smoothHA_l = na
var float smoothHA_c = na

if smoothHAEnable
    // PHASE 1: Pre-HA Smoothing (Before HA calculation)
    smooth_open = get_ma(open, smoothHALength, smoothHAMode)
    smooth_high = get_ma(high, smoothHALength, smoothHAMode)
    smooth_low = get_ma(low, smoothHALength, smoothHAMode)
    smooth_close = get_ma(close, smoothHALength, smoothHAMode)
    
    // PHASE 2: Heiken Ashi Calculation (using smoothed OHLC)
    ha_close = (smooth_open + smooth_high + smooth_low + smooth_close) / 4
    ha_open = na(smoothHA_o[1]) ? (smooth_open + smooth_close) / 2 : (smoothHA_o[1] + smoothHA_c[1]) / 2
    ha_high = math.max(smooth_high, math.max(ha_open, ha_close))
    ha_low = math.min(smooth_low, math.min(ha_open, ha_close))
    
    // PHASE 3: Post-HA Smoothing (After HA calculation)
    smoothHA_o := get_ma(ha_open, smoothHAAfterLength, smoothHAAfterMode)
    smoothHA_h := get_ma(ha_high, smoothHAAfterLength, smoothHAAfterMode)
    smoothHA_l := get_ma(ha_low, smoothHAAfterLength, smoothHAAfterMode)
    smoothHA_c := get_ma(ha_close, smoothHAAfterLength, smoothHAAfterMode)
    
    // PHASE 4: Trend Detection (matching original logic)
    // Bullish when smoothed HA close > smoothed HA open (uptrend candle)
    smoothHABullish := smoothHA_c > smoothHA_o
else
    smoothHABullish := false
    smoothHA_o := na
    smoothHA_h := na
    smoothHA_l := na
    smoothHA_c := na

// ═══════════════════ DIRECTIONAL BIAS INTEGRATION ═══════════════════
// Apply directional bias filters to entry signals with confluence logic

// Individual Filter Bias Logic (Fixed: disabled filters don't vote)
// RBW filter removed, so bias defaults to true
rbwLongBias = true  // RBW filter removed
rbwShortBias = true  // RBW filter removed

hullLongBias = hullEnable ? hullBullish : true  // If enabled: bullish trend required. If disabled: allow all
hullShortBias = hullEnable ? (not hullBullish) : true  // If enabled: bearish trend required. If disabled: allow all

supertrendLongBias = supertrendEnable ? supertrendBullish : true  // If enabled: bullish trend required. If disabled: allow all
supertrendShortBias = supertrendEnable ? (not supertrendBullish) : true  // If enabled: bearish trend required. If disabled: allow all

quadrantLongBias = quadrantEnable ? quadrantBullish : true  // If enabled: bullish trend required. If disabled: allow all
quadrantShortBias = quadrantEnable ? (not quadrantBullish) : true  // If enabled: bearish trend required. If disabled: allow all



adaptiveSTLongBias = adaptiveSTEnable ? adaptiveSTBullish : true  // If enabled: bullish trend required. If disabled: allow all
adaptiveSTShortBias = adaptiveSTEnable ? (not adaptiveSTBullish) : true  // If enabled: bearish trend required. If disabled: allow all

volumaticLongBias = volumaticEnable ? volumaticBullish : true  // If enabled: bullish trend required. If disabled: allow all
volumaticShortBias = volumaticEnable ? (not volumaticBullish) : true  // If enabled: bearish trend required. If disabled: allow all

smoothHALongBias = smoothHAEnable ? smoothHABullish : true  // If enabled: bullish trend required. If disabled: allow all
smoothHAShortBias = smoothHAEnable ? (not smoothHABullish) : true  // If enabled: bearish trend required. If disabled: allow all

// ═══════════════════ TREND-EXIT/HOLD FILTER CALCULATIONS ═══════════════════
// Visually clear, mechanically simple filters to hold trades longer during obvious trends

// 1. ADAPTIVE SUPERTREND VOLATILITY FILTER
// Get current Adaptive SuperTrend volatility number (1, 2, or 3)
var int adaptiveSTNumber = na
if adaptiveSTEnable
    // Extract volatility number from Adaptive SuperTrend
    // Number 3 = High Volatility (cluster = 0), Number 2 = Medium (cluster = 1), Number 1 = Low (cluster = 2)
    // Formula: displayed_number = 4 - (cluster + 1)
    adaptiveSTNumber := not na(adaptiveCluster) ? (4 - (adaptiveCluster + 1)) : na
else
    adaptiveSTNumber := na

// Calculate if we should hold based on Adaptive ST number
var bool adaptiveSTHoldSignal = false
if adaptiveExitFilterEnable and not na(adaptiveSTNumber)
    adaptiveSTHoldSignal := (adaptiveHoldOn3 and adaptiveSTNumber == 3) or 
                           (adaptiveHoldOn2 and adaptiveSTNumber == 2) or 
                           (adaptiveHoldOn1 and adaptiveSTNumber == 1)
else
    adaptiveSTHoldSignal := false

// 2. MOVING AVERAGE CROSSOVER FILTER
// Calculate moving averages for crossover detection
var float maCrossoverFast = na
var float maCrossoverSlow = na
var bool maCrossoverHoldSignal = false

if maCrossoverFilterEnable
    // Calculate MAs based on user selection
    maCrossoverFast := maCrossoverType == 'SMA' ? ta.sma(close, maCrossoverFastLength) :
                       maCrossoverType == 'EMA' ? ta.ema(close, maCrossoverFastLength) :
                       ta.wma(close, maCrossoverFastLength)
    
    maCrossoverSlow := maCrossoverType == 'SMA' ? ta.sma(close, maCrossoverSlowLength) :
                       maCrossoverType == 'EMA' ? ta.ema(close, maCrossoverSlowLength) :
                       ta.wma(close, maCrossoverSlowLength)
    
    // For long positions: hold while fast MA > slow MA
    // For short positions: hold while fast MA < slow MA
    if strategy.position_size > 0  // Long position
        maCrossoverHoldSignal := maCrossoverFast > maCrossoverSlow
    else if strategy.position_size < 0  // Short position
        maCrossoverHoldSignal := maCrossoverFast < maCrossoverSlow
    else
        maCrossoverHoldSignal := false
else
    maCrossoverHoldSignal := false

// 3. INDIVIDUAL TREND INDICATOR EXIT SIGNALS
// Calculate exit signals for each trend indicator
var bool hullExitSignal = false
var bool supertrendExitSignal = false
var bool quadrantExitSignal = false
var bool adaptiveExitSignal = false
var bool volumaticExitSignal = false
var bool smoothHAExitSignal = false

// Hull Suite exit signal (trend change)
if hullTrendExit and hullEnable
    if strategy.position_size > 0  // Long position
        hullExitSignal := not hullBullish  // Exit when Hull turns bearish
    else if strategy.position_size < 0  // Short position
        hullExitSignal := hullBullish  // Exit when Hull turns bullish
    else
        hullExitSignal := false
else
    hullExitSignal := false

// SuperTrend exit signal
if supertrendTrendExit and supertrendEnable
    if strategy.position_size > 0
        supertrendExitSignal := not supertrendBullish
    else if strategy.position_size < 0
        supertrendExitSignal := supertrendBullish
    else
        supertrendExitSignal := false
else
    supertrendExitSignal := false

// Quadrant exit signal
if quadrantTrendExit and quadrantEnable
    if strategy.position_size > 0
        quadrantExitSignal := not quadrantBullish
    else if strategy.position_size < 0
        quadrantExitSignal := quadrantBullish
    else
        quadrantExitSignal := false
else
    quadrantExitSignal := false

// Adaptive SuperTrend exit signal
if adaptiveTrendExit and adaptiveSTEnable
    if strategy.position_size > 0
        adaptiveExitSignal := not adaptiveSTBullish
    else if strategy.position_size < 0
        adaptiveExitSignal := adaptiveSTBullish
    else
        adaptiveExitSignal := false
else
    adaptiveExitSignal := false

// Volumatic exit signal
if volumaticTrendExit and volumaticEnable
    if strategy.position_size > 0
        volumaticExitSignal := not volumaticBullish
    else if strategy.position_size < 0
        volumaticExitSignal := volumaticBullish
    else
        volumaticExitSignal := false
else
    volumaticExitSignal := false

// Smooth HA exit signal
if smoothHATrendExit and smoothHAEnable
    if strategy.position_size > 0
        smoothHAExitSignal := not smoothHABullish
    else if strategy.position_size < 0
        smoothHAExitSignal := smoothHABullish
    else
        smoothHAExitSignal := false
else
    smoothHAExitSignal := false

// External trend exit signal (e.g., Trend Strength arrows)
var bool externalTrendExitSignal = false
if trendExitSignalEnable
    // Detect signal changes from external indicator
    // For Trend Strength: arrows appear when trend changes
    // We detect when the signal source changes value (indicating new arrow)
    externalTrendExitSignal := trendExitSignalSrc != trendExitSignalSrc[1]
else
    externalTrendExitSignal := false

// 4. COMBINE ALL TREND-EXIT/HOLD FILTERS
// Calculate overall hold signal and exit signal
var bool trendHoldActive = false
var bool trendExitTriggered = false

// Hold signals (prevent exit)
trendHoldActive := adaptiveSTHoldSignal or maCrossoverHoldSignal

// Exit signals (trigger exit)
individualExitCount = (hullExitSignal ? 1 : 0) + (supertrendExitSignal ? 1 : 0) + 
                     (quadrantExitSignal ? 1 : 0) + (adaptiveExitSignal ? 1 : 0) + 
                     (volumaticExitSignal ? 1 : 0) + (smoothHAExitSignal ? 1 : 0) + 
                     (externalTrendExitSignal ? 1 : 0)

if trendExitLogic == 'Any Filter Triggers Exit'
    trendExitTriggered := individualExitCount > 0
else  // 'All Filters Must Agree'
    enabledExitFilters = (hullTrendExit ? 1 : 0) + (supertrendTrendExit ? 1 : 0) + (quadrantTrendExit ? 1 : 0) + (adaptiveTrendExit ? 1 : 0) + (volumaticTrendExit ? 1 : 0) + (smoothHATrendExit ? 1 : 0) + (trendExitSignalEnable ? 1 : 0)
    trendExitTriggered := enabledExitFilters > 0 and individualExitCount >= enabledExitFilters

// Final trend-exit/hold decision with MODE SELECTION INTEGRATION
// CRITICAL: Mode selection overrides all other exit logic
// SCALP MODE: Always allow exits (ignore trend-hold filters)
// TREND MODE: Apply trend-hold filters as normal

if scalpOnlyMode
    // SCALP MODE: Always allow exits for quick scalping profits
    allowTrendExit := true
else
    // TREND MODE: Apply trend-hold filters to capture larger moves
    // If any hold filter is active, don't exit
    // If no hold filters active and exit signal triggered, allow exit
    allowTrendExit := not trendHoldActive and (not (adaptiveExitFilterEnable or maCrossoverFilterEnable or 
                     hullTrendExit or supertrendTrendExit or quadrantTrendExit or 
                     adaptiveTrendExit or volumaticTrendExit or smoothHATrendExit) or trendExitTriggered)

// Confluence Logic Implementation - FIXED WEIGHTED VOTING BUG
// CRITICAL FIX: Use consistent decimal weighting instead of math.round() to prevent unbalanced voting
// This fixes the bug where math.round() created inconsistent filter weights

// NOTE: enabledFilters, bullishVotes, and bearishVotes are already calculated above (lines 1542-1548)
// Removing duplicate definitions to fix compilation error

// ═══════════════════ DIRECTIONAL BIAS CALCULATION ═══════════════════
// Apply directional bias filters to entry signals with confluence logic

// Initialize directional bias variables
var bool longDirectionalBias = true
var bool shortDirectionalBias = true

// Count enabled filters and calculate votes (RBW removed)
enabledFilters = (hullEnable ? 1.0 : 0.0) + (supertrendEnable ? 1.0 : 0.0) + (quadrantEnable ? 1.0 : 0.0) + (adaptiveSTEnable ? 1.0 : 0.0) + (volumaticEnable ? 1.0 : 0.0) + (smoothHAEnable ? 1.0 : 0.0)

// Count bullish votes (RBW removed)
bullishVotes = (hullEnable and hullBullish ? 1.0 : 0.0) + (supertrendEnable and supertrendBullish ? 1.0 : 0.0) + (quadrantEnable and quadrantBullish ? 1.0 : 0.0) + (adaptiveSTEnable and adaptiveSTBullish ? 1.0 : 0.0) + (volumaticEnable and volumaticBullish ? 1.0 : 0.0) + (smoothHAEnable and smoothHABullish ? 1.0 : 0.0)

// Count bearish votes (RBW removed)
bearishVotes = (hullEnable and not hullBullish ? 1.0 : 0.0) + (supertrendEnable and not supertrendBullish ? 1.0 : 0.0) + (quadrantEnable and not quadrantBullish ? 1.0 : 0.0) + (adaptiveSTEnable and not adaptiveSTBullish ? 1.0 : 0.0) + (volumaticEnable and not volumaticBullish ? 1.0 : 0.0) + (smoothHAEnable and not smoothHABullish ? 1.0 : 0.0)

// Apply confluence logic
longDirectionalBias := enabledFilters == 0 ? true : (biasConfluence == 'Any' and bullishVotes > 0) or (biasConfluence == 'Majority' and bullishVotes > bearishVotes) or (biasConfluence == 'All' and bearishVotes == 0)
shortDirectionalBias := enabledFilters == 0 ? true : (biasConfluence == 'Any' and bearishVotes > 0) or (biasConfluence == 'Majority' and bearishVotes > bullishVotes) or (biasConfluence == 'All' and bullishVotes == 0)



// ═══════════════════ TREND-EXIT/HOLD FILTER CALCULATION ═══════════════════
// NOTE: allowTrendExit calculation is now handled by the dual-layer mode selection system
// This duplicate calculation block has been removed to fix compilation errors

// ═══════════════════ LEGACY TREND-RIDING SYSTEM REMOVED ═══════════════════
// All legacy trend-riding activation/deactivation logic has been completely removed

// ──────────────── ENTRY SIGNAL FINALIZATION ────────────────
// Assign entry signals after all filters & calculations complete.
longEntrySignal := primaryLongSig and longDirectionalBias 
shortEntrySignal := primaryShortSig and shortDirectionalBias

// ═══════════════════ ACTUAL STRATEGY ENTRY EXECUTION (CRITICAL FIX) ═══════════════════
// CRITICAL: Execute the actual trades using strategy.entry() calls
// This was the missing piece - signals were calculated but trades weren't executed!

// Long Entry Execution – with dynamic label
if longEntrySignal
    if displayEntryLabels
        string longLabelText = buildSignalName(true)
        if longLabelText != ""
            label lbl = getPooledLabel(true)
            updateLabel(lbl, bar_index, low - atrVal * 0.2, longLabelText, labelColorLong)
    entryComment = 'Long' + (longSignalCount > 1 ? ' C:' + str.tostring(longSignalCount) : '')
    strategy.entry('Long', strategy.long, qty = positionQty, comment = entryComment, alert_message = longEntryMsg)
    if debugEnabled
        debugInfo('Long entry triggered: ' + entryComment + ' at price: ' + str.tostring(close))

// Short Entry Execution – with dynamic label
if shortEntrySignal
    if displayEntryLabels
        string shortLabelText = buildSignalName(false)
        if shortLabelText != ""
            label lbl = getPooledLabel(false)
            updateLabel(lbl, bar_index, high + atrVal * 0.2, shortLabelText, labelColorShort)
    entryComment = 'Short' + (shortSignalCount > 1 ? ' C:' + str.tostring(shortSignalCount) : '')
    strategy.entry('Short', strategy.short, qty = positionQty, comment = entryComment, alert_message = shortEntryMsg)
    if debugEnabled
        debugInfo('Short entry triggered: ' + entryComment + ' at price: ' + str.tostring(close))

// NOTE: Individual signal backtest processing is handled later in the script

// Enhanced debug logging for all directional bias filters and systems
if debugEnabled
    // Always show filter status when debug is enabled
    filterStatusMsg = 'FILTER STATUS:'
    filterStatusMsg += ' Hull=' + (hullEnable ? (hullBullish ? 'BULL' : 'BEAR') + '(' + str.tostring(hullMA, '#.##') + ')' : 'OFF')
    filterStatusMsg += ' ST=' + (supertrendEnable ? (supertrendBullish ? 'BULL' : 'BEAR') + '(' + str.tostring(supertrendDirection, '#.#') + ')' : 'OFF')
    filterStatusMsg += ' Quad=' + (quadrantEnable ? (quadrantBullish ? 'BULL' : 'BEAR') + '(' + str.tostring(quadrantEstimate, '#.##') + ')' : 'OFF')

    debugInfo(filterStatusMsg)
    
    // Show confluence calculation with new voting system
    confluenceMsg = 'CONFLUENCE: Mode=' + biasConfluence + ' | Enabled=' + str.tostring(enabledFilters) + ' | BullVotes=' + str.tostring(bullishVotes) + ' | BearVotes=' + str.tostring(bearishVotes)
    confluenceMsg += ' | LongBias=' + (longDirectionalBias ? 'ALLOW' : 'BLOCK') + ' | ShortBias=' + (shortDirectionalBias ? 'ALLOW' : 'BLOCK')
    debugInfo(confluenceMsg)
    
    // Show individual filter votes (only when enabled)
    if enabledFilters > 0
        voteDetailMsg = 'FILTER VOTES:'
        // RBW filter removed
        // if rbwEnable
        //     voteDetailMsg += ' RBW=' + (rbwSignal == 2 ? 'BULL' : rbwSignal == 0 ? 'BEAR' : 'NEUTRAL')
        if hullEnable
            voteDetailMsg += ' Hull=' + (hullBullish ? 'BULL' : 'BEAR')
        if supertrendEnable
            voteDetailMsg += ' ST=' + (supertrendBullish ? 'BULL' : 'BEAR')
        if quadrantEnable
            voteDetailMsg += ' Quad=' + (quadrantBullish ? 'BULL' : 'BEAR')

        debugInfo(voteDetailMsg)



// ═══════════════════ SIGNAL-DRIVEN TREND RIDER: EXIT INTERCEPTION ═══════════════════
// REVOLUTIONARY FEATURE: Intercept and ignore standard exits during trend-riding mode
// This is the core of the Signal-Driven Trend Rider system

// ═══════════════════ LEGACY EXIT BLOCKING LOGIC REMOVED ═══════════════════
// All legacy trend-riding exit blocking logic has been removed.
// Exit control is now handled by the new allowTrendExit variable from the Trend-Exit/Hold Filter System.

// ──────── CORE EXIT SYSTEMS (PRESERVED) ────────────
// Smart Profit Locker - Dynamic stop loss with ATR-based distance
// ENHANCED: Now respects trend-exit/hold filters
if strategy.position_size != 0 and smartProfitEnable and allowTrendExit
    // Calculate smart distance
    baseDistance = atrVal * smartProfitMultiplier
    
    // Declare and assign smartDistance
    var float smartDistance = na
    smartDistance := baseDistance
    
    // CRITICAL FIX: Use user-configurable fallback instead of hardcoded value
    if na(smartDistance) or smartDistance <= 0
        smartDistance := smartProfitFallback  // User-configurable fallback value
    
    if strategy.position_size > 0  // Long position
        stopLevel = strategy.position_avg_price - smartDistance
        if not na(stopLevel) and stopLevel > 0
            strategy.exit('SPL-Long', from_entry='Long', stop=stopLevel, comment='Smart Profit Locker')
    
    else if strategy.position_size < 0  // Short position
        stopLevel = strategy.position_avg_price + smartDistance
        if not na(stopLevel) and stopLevel > 0
            strategy.exit('SPL-Short', from_entry='Short', stop=stopLevel, comment='Smart Profit Locker')

// Fixed SL/TP System
// ENHANCED: Now respects trend-exit/hold filters
if strategy.position_size != 0 and fixedSlTpEnable and allowTrendExit
    if strategy.position_size > 0  // Long position
        slLevel = strategy.position_avg_price * (1 - fixedStopLoss / 100)
        tpLevel = strategy.position_avg_price * (1 + fixedTakeProfit / 100)
        strategy.exit('Fixed-Long', from_entry='Long', stop=slLevel, limit=tpLevel, comment='Fixed SL/TP')
    
    else if strategy.position_size < 0  // Short position
        slLevel = strategy.position_avg_price * (1 + fixedStopLoss / 100)
        tpLevel = strategy.position_avg_price * (1 - fixedTakeProfit / 100)
        strategy.exit('Fixed-Short', from_entry='Short', stop=slLevel, limit=tpLevel, comment='Fixed SL/TP')

// MA Exit System  
// ENHANCED: Now respects trend-exit/hold filters
if strategy.position_size != 0 and maExitEnable and allowTrendExit
    if strategy.position_size > 0 and close < maExitLine
        strategy.close('Long', comment='MA Exit', alert_message=longExitMsg)
        debugInfo("📈 MA Exit: Long position closed below MA")
    
    else if strategy.position_size < 0 and close > maExitLine
        strategy.close('Short', comment='MA Exit', alert_message=shortExitMsg)
        debugInfo("📉 MA Exit: Short position closed above MA")

// Signal-Based Trend Rider Exits (from panel configuration)
// ENHANCED: Now respects trend-exit/hold filters
if inTrendRidingMode and strategy.position_size != 0 and allowTrendExit
    // Exit based on signal configuration from trend-riding panel
    if trendRiderSignalExit and ((strategy.position_size > 0 and not longDirectionalBias) or (strategy.position_size < 0 and not shortDirectionalBias))
        if strategy.position_size > 0
            strategy.close('Long', comment='Trend Rider Signal Exit', alert_message=longExitMsg)
            debugInfo("🏄 Trend Rider: Long exit on signal reversal")
        else
            strategy.close('Short', comment='Trend Rider Signal Exit', alert_message=shortExitMsg)
            debugInfo("🏄 Trend Rider: Short exit on signal reversal")
        
        // Reset trend-riding mode
        inTrendRidingMode := false
        trendRidingStartBar := na



// ═══════════════════ LEGACY ADAPTIVE SUPERTREND VISUALIZATION (REMOVED) ═══════════════════
// Old visualization code completely removed to prevent duplicate variable declarations
// All adaptive exit filter visualization is now handled by the new trend-exit filter system below

// ═══════════════════ TREND-EXIT/HOLD FILTER DEBUG VISUALIZATION ═══════════════════
// Professional badge-style debug display for trend-exit/hold filter system

if trendExitDebug and strategy.position_size != 0
    var string trendFilterStatus = ''
    trendFilterStatus := 'TREND EXIT FILTERS\n'
    
    // Adaptive SuperTrend filter status
    if adaptiveExitFilterEnable
        adaptiveStatus = adaptiveSTHoldSignal ? 'HOLD' : 'ALLOW'
        trendFilterStatus += 'Adaptive ST: Vol' + str.tostring(adaptiveSTNumber) + ' [' + adaptiveStatus + ']\n'
    
    // MA Crossover filter status
    if maCrossoverFilterEnable
        maStatus = maCrossoverHoldSignal ? 'HOLD' : 'ALLOW'
        trendFilterStatus += 'MA Cross: ' + str.tostring(maCrossoverFastLength) + '/' + str.tostring(maCrossoverSlowLength) + ' [' + maStatus + ']\n'
    
    // Individual indicator exits
    if hullTrendExit or supertrendTrendExit or quadrantTrendExit or adaptiveTrendExit or volumaticTrendExit or smoothHATrendExit or trendExitSignalEnable
        trendFilterStatus += 'Individual Exits: ' + str.tostring(individualExitCount) + ' triggered\n'
        if trendExitSignalEnable
            externalStatus = externalTrendExitSignal ? 'TRIGGERED' : 'WAITING'
            trendFilterStatus += 'External Exit: [' + externalStatus + ']\n'
    
    // Overall status with clean formatting
    overallStatus = allowTrendExit ? 'EXIT ALLOWED' : 'EXIT BLOCKED'
    trendFilterStatus += '\nSTATUS: ' + overallStatus
    
    // Display professional badge-style debug info
    if barstate.islast
        badgeColor = allowTrendExit ? color.new(color.green, 85) : color.new(color.red, 85)
        debugLabel = label.new(bar_index, high + atrVal * 0.3, trendFilterStatus, 
                              color=badgeColor, 
                              textcolor=color.white, 
                              style=label.style_label_down, 
                              size=size.small)

// Subtle visual markers for trend-exit filter state changes
plotshape(trendExitDebug and trendHoldActive and not trendHoldActive[1], 
          title='Hold Filter Active', 
          style=shape.circle, 
          location=location.belowbar, 
          color=color.new(color.orange, 30), 
          size=size.tiny)

plotshape(trendExitDebug and not trendHoldActive and trendHoldActive[1], 
          title='Hold Filter Inactive', 
          style=shape.xcross, 
          location=location.belowbar, 
          color=color.new(color.gray, 30), 
          size=size.tiny)

// ═══════════════════ STEP CHANNEL MOMENTUM VISUALS ═══════════════════
// Complete ChartPrime Step Channel Momentum visualization (moved to global scope)

// Step Channel visual variables (calculated above in dual-layer mode selection)
stepChannelShowVisualsActive = stepChannelEnable and stepChannelShowVisuals
stepChannelMidLineColor = stepChannelShowVisualsActive and stepChannelShowLines ? stepChannelCurrentColor : na
stepChannelUpperColor = stepChannelShowVisualsActive and stepChannelShowLines ? chart.fg_color : na
stepChannelLowerColor = stepChannelShowVisualsActive and stepChannelShowLines ? chart.fg_color : na
stepChannelCandleColor = stepChannelShowVisualsActive and stepChannelShowCandles ? stepChannelCurrentColor : na

// Step Channel lines (EXACT ChartPrime implementation - 3 lines total)
// Midline: Colored with momentum state (yellow/green/red) - linewidth=3
// Upper/Lower: Chart foreground color (white) - style_linebr
plot(stepChannelEnable and stepChannelShowLines ? stepChannelAvg : na, 
     "Step Channel MidLine", 
     color=stepChannelEnable ? stepChannelCurrentColor : na, 
     linewidth=3)
plot(stepChannelEnable and stepChannelShowLines ? stepChannelUpper : na, 
     "Step Channel Upper", 
     color=stepChannelEnable ? chart.fg_color : na, 
     style=plot.style_linebr)
plot(stepChannelEnable and stepChannelShowLines ? stepChannelLower : na, 
     "Step Channel Lower", 
     color=stepChannelEnable ? chart.fg_color : na, 
     style=plot.style_linebr)

// Step Channel complete candle coloring (EXACT ChartPrime implementation)
// plotcandle() colors body, wicks, AND borders - complete yellow/green/red candles
plotcandle(stepChannelEnable and stepChannelShowCandles ? open : na, 
           stepChannelEnable and stepChannelShowCandles ? high : na, 
           stepChannelEnable and stepChannelShowCandles ? low : na, 
           stepChannelEnable and stepChannelShowCandles ? close : na, 
           title='Step Channel Momentum Candles', 
           color=stepChannelEnable ? stepChannelCurrentColor : na, 
           wickcolor=stepChannelEnable ? stepChannelCurrentColor : na, 
           bordercolor=stepChannelEnable ? stepChannelCurrentColor : na)

// Step Channel market state label (matching ChartPrime exactly)
if stepChannelShowVisualsActive and stepChannelShowLabel and barstate.islast
    label.delete(label.new(bar_index, close, stepChannelState, color=color(na), textcolor=stepChannelCurrentColor, style=label.style_label_left, size=size.large)[1])

// ═══════════════════ ENHANCEMENT SUITE REMOVED ═══════════════════
// Advanced trend enhancement suite has been surgically removed to keep code lean.
// Core functionality preserved: 6 trend indicators, confluence logic, entry/exit systems.
// TOTAL TOGGLES: 1 master + 8 individual = 9 independent control switches
// 🧠 COMPLEXITY LEVEL: Institutional-grade algorithmic trading system
