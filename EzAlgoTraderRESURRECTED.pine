
// ğŸš¨================================================================================================ğŸš¨
// ğŸš¨ EZ ALGO HEDGE FUND - DEVELOPER & AI DIRECTIVES
// ğŸš¨================================================================================================ğŸš¨
//
// PRIMARY DIRECTIVE: PRESERVE CORE FUNCTIONALITY
// This is a pure strategy script focused on execution performance. The core logic is battle-tested and must not be altered.
// Any modifications must be strictly limited to approved areas to prevent unintended consequences.
//
// --------------------------------------------------------------------------------------------------
// ğŸ”’ CORE SYSTEMS - DO NOT MODIFY ğŸ”’
// --------------------------------------------------------------------------------------------------
// 1.  SIGNAL PROCESSING: Multi-signal detection, combination, and entry signal generation.
// 2.  EXIT ARCHITECTURE: Coordinated exits (Smart Profit Locker, Fixed SL/TP, MA-based) and intrabar execution.
// 3.  TREND-RIDING LOGIC: Signal-driven trend mode, exit interception, and safety nets.
// 4.  DIRECTIONAL BIAS FILTERS: Confluence voting and bias application from internal indicators.
// 5.  STRATEGY EXECUTION: `strategy.entry()` and `strategy.exit()` calls, webhook integration, and risk management.
//
// --------------------------------------------------------------------------------------------------
// ğŸš« STRICT PROHIBITIONS ğŸš«
// --------------------------------------------------------------------------------------------------
// - DO NOT alter, simplify, or "optimize" any mathematical formulas.
// - DO NOT modify the fundamental structure of the signal processing or exit systems.
// - DO NOT add heavy visual elements; focus on performance and minimal chart pollution.
//
// --------------------------------------------------------------------------------------------------
// âœ… APPROVED MODIFICATION AREAS âœ…
// --------------------------------------------------------------------------------------------------
// - ADDING NEW FILTERS: New directional bias filters may be added if they follow the existing pattern.
// - PARAMETER TUNING: Default input values can be adjusted for optimization.
// - MINIMAL VISUALS: Essential `plot()` or `plotshape()` for debugging or critical signals are acceptable.
//
// Any deviation from these directives requires express permission. When in doubt, do not modify.
// ğŸš¨================================================================================================ğŸš¨

// --------------------------------------------------------------------------------------------------
// SECTION: SCRIPT CONFIGURATION & METADATA
// --------------------------------------------------------------------------------------------------
// Â© 2025 Andres Garcia â€” EZ Algo Hedge Fund
// This script provides a professional-grade framework for multi-signal quantitative strategies.
// Key Features:
// â€¢ Coordinated multi-method exit system (Smart Profit Locker, Fixed SL/TP, MA-based).
// â€¢ Flexible, multi-source signal processing for entries and trend-based exits.
// â€¢ Integrated with TradersPost for full automation via webhooks.
// â€¢ Memory-safe debugging and label management for high performance.
//
//@version=6

// --------------------------------------------------------------------------------------------------
// SECTION: INPUT DECLARATIONS - MUST BE FIRST
// KEYWORDS: User Inputs, Settings, Configuration, Parameters
// --------------------------------------------------------------------------------------------------
// ALL INPUT DECLARATIONS MUST BE AT THE VERY TOP BEFORE ANY FUNCTIONS OR VARIABLES

// Global Settings
atrPeriod = input.int(14, 'ATR Period', group='Global Settings', tooltip='Average True Range period for various calculations like stops and filters.')
closePosition = input.bool(false, 'ğŸš¨ EMERGENCY CLOSE ALL', group='Global Settings', tooltip='If checked, this will close any open position on the next bar. Use it as a manual override.')

// Visual Settings
scalpModeColor = input.color(#f23645, 'Scalp Mode Color', group='7ï¸âƒ£ Visual Settings')
trendModeColor = input.color(#089981, 'Trend Mode Color', group='7ï¸âƒ£ Visual Settings')
hybridModeColor = input.color(#2157f3, 'Hybrid Mode Color', group='7ï¸âƒ£ Visual Settings')
flatModeColor = input.color(#808080, 'Flat/No Position Color', group='7ï¸âƒ£ Visual Settings')
modeBackgroundIntensity = input.int(60, 'Background Transparency', minval=50, maxval=95, group='7ï¸âƒ£ Visual Settings')

// Debug System
debugLevel = input.string('Off', 'Debug Level', options=['Off', 'Basic', 'Detailed', 'Full'], group='ğŸ› ï¸ Debug System', tooltip='Controls the verbosity of on-chart labels for troubleshooting')

// Exit System Inputs
smartProfitEnable = input.bool(true, 'Enable Smart Profit Locker', group='3ï¸âƒ£ Exit Systems â€º SPL', tooltip='Smart trailing stop that locks in profits')
smartProfitType = input.string('ATR', 'Distance Type', options=['ATR', 'Points', 'Percent'], group='3ï¸âƒ£ Exit Systems â€º SPL')
smartProfitVal = input.float(2.0, 'Distance Value', step=0.1, minval=0.1, group='3ï¸âƒ£ Exit Systems â€º SPL')
smartProfitOffset = input.float(0.1, 'Trail Offset', step=0.01, minval=0.01, group='3ï¸âƒ£ Exit Systems â€º SPL')

fixedEnable = input.bool(false, 'Enable Fixed SL/TP', group='3ï¸âƒ£ Exit Systems â€º Fixed', tooltip='Traditional stop-loss and take-profit levels')
fixedStop = input.float(1.5, 'Stop Loss (ATR)', step=0.1, minval=0.1, group='3ï¸âƒ£ Exit Systems â€º Fixed')
tp1Enable = input.bool(false, 'Enable Take Profit', group='3ï¸âƒ£ Exit Systems â€º Fixed')
tp1Size = input.float(2.0, 'Take Profit (ATR)', step=0.1, minval=0.1, group='3ï¸âƒ£ Exit Systems â€º Fixed')

scalpMAExitOn = input.bool(false, 'Enable Scalp MA Exit', group='3ï¸âƒ£ Exit Systems â€º MA', tooltip='Exit when price crosses moving average (SCALP mode only)')
maLen = input.int(21, 'MA Length', minval=1, group='3ï¸âƒ£ Exit Systems â€º MA')
maType = input.string('EMA', 'MA Type', options=['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA'], group='3ï¸âƒ£ Exit Systems â€º MA')

// BB Exit System removed - was not requested and not needed

// Calculated Values
atrVal = ta.atr(atrPeriod)

// MA Exit Calculation
priceMA = switch maType
    "SMA" => ta.sma(close, maLen)
    "EMA" => ta.ema(close, maLen)
    "WMA" => ta.wma(close, maLen)
    "VWMA" => ta.vwma(close, maLen)
    "SMMA" => ta.rma(close, maLen)
    => ta.ema(close, maLen)

// --------------------------------------------------------------------------------------------------
// SECTION: MEMORY-SAFE LABEL POOL
// KEYWORDS: Label Pool, Chart Labels, Visualization, Performance, Memory Management
// --------------------------------------------------------------------------------------------------
// Manages a fixed-size pool of labels to display information on the chart without creating new labels
// on every bar, which would lead to memory and performance issues.

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• OPTIMIZED LABEL POOL SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’¡ KEY FEATURES:
// - Recycling: Labels are recycled on each new bar, dramatically reducing the number
//   of objects created and avoiding Pine Script's drawing limits.
// - Performance: This is significantly faster than creating new objects on the fly.
// - Priority Allocation: The system gives priority to more important labels (like
//   entry/exit signals) to ensure they are always displayed, even if the label
//   limit for a single bar is reached.
var int MAX_LABELS = 250  // Reduced from 450 to improve performance
var label[] labelPool = array.new<label>()
var int labelPoolIndex = 0
var int labelsCreatedThisBar = 0
var int lastProcessedBar = na
var int priorityLabelsCreated = 0  // Track high-priority labels separately

// Reset counters on new bar (global scope)
currentBar = bar_index
if currentBar != lastProcessedBar
    labelsCreatedThisBar := 0
    priorityLabelsCreated := 0
    lastProcessedBar := currentBar
    
// Smart label recycling with priority-based allocation
getPooledLabel(isPriority = false) =>
    var label result = na
    
    // PRODUCTION SAFETY: Kill-switch for object pool when not in debug mode
    if debugLevel == "Off"
        result := na  // Disable label pool entirely in production mode
    else
        // Priority labels get preferential treatment (signal names, exits)
        if isPriority
            if priorityLabelsCreated < 5 or barstate.islast
                if array.size(labelPool) < MAX_LABELS
                    // Create new label for priority items
                    newLabel = label.new(bar_index, close, "", style=label.style_none, color=color.new(color.white, 100))
                    array.push(labelPool, newLabel)
                    result := newLabel
                
        // Standard allocation logic (optimized)
        if na(result) and array.size(labelPool) < MAX_LABELS and labelsCreatedThisBar < 5  // Reduced from 10 to 5
            // Create new label if pool not full and not too many this bar
            newLabel = label.new(bar_index, close, "", style=label.style_none, color=color.new(color.white, 100))
            array.push(labelPool, newLabel)
            result := newLabel
        else if na(result) and barstate.isconfirmed and array.size(labelPool) > 0
            // Only recycle on confirmed bars to prevent overwrites
            labelToReturn = array.get(labelPool, labelPoolIndex)
            result := labelToReturn
        else if na(result) and array.size(labelPool) > 0
            // Return existing label without advancing pointer
            result := array.get(labelPool, labelPoolIndex)
    
    result

// Helper function to get label without modifying global variables
getLabelFromPool(isPriority = false) =>
    getPooledLabel(isPriority)

// Professional label update function (unchanged)
updateLabel(labelId, x, y, txt, style, bgColor, textColor, size) =>
    if not na(labelId)
        label.set_xy(labelId, x, y)
        label.set_text(labelId, txt)
        label.set_style(labelId, style)
        label.set_color(labelId, bgColor)
        label.set_textcolor(labelId, textColor)
        label.set_size(labelId, size)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONTRAST-SAFE COLOR SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This system ensures that all text on the chart remains readable, regardless of the
// background color it's placed on. 
//
// âš™ï¸ HOW IT WORKS:
// - getSemanticColor(): A helper function that maps abstract concepts ('critical',
//   'success', 'info') to the actual user-defined colors from the input panel. It also
//   applies a standardized transparency level based on the 'priority' of the message.
// - getContrastSafeTextColor(): The core of the system. It calculates the luminance
//   difference between a given background color and the chart's main background. Based
//   on this, it returns either black or white, whichever will be more readable.

getSemanticColor(colorType, priority) =>
    baseColor = switch colorType
        "critical" => scalpModeColor
        "success"  => trendModeColor
        "info"     => hybridModeColor
        "warning"  => color.orange
        "neutral"  => flatModeColor
        => color.gray
    
    transparency = switch priority
        "urgent"     => 0   // Solid
        "important"  => 20  
        "normal"     => 50  
        "background" => modeBackgroundIntensity
    
    color.new(baseColor, transparency)

// Contrast-safe text color detection
getContrastSafeTextColor(backgroundColor) =>
    bgR = color.r(backgroundColor)
    bgG = color.g(backgroundColor)  
    bgB = color.b(backgroundColor)
    chartBgR = color.r(chart.bg_color)
    chartBgG = color.g(chart.bg_color)
    chartBgB = color.b(chart.bg_color)
    
    // Calculate contrast difference
    contrastDiff = math.abs(bgR - chartBgR) + math.abs(bgG - chartBgG) + math.abs(bgB - chartBgB)
    
    // Use white text on dark backgrounds, black on light
    contrastDiff < 240 ? (color.r(chart.bg_color) + color.g(chart.bg_color) + color.b(chart.bg_color) < 384 ? color.white : color.black) : color.white

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PERFORMANCE-OPTIMIZED RENDERING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//designed to reduce the script's
// calculation load, especially on historical data. It intelligently skips the execution
// of non-critical visual updates (like drawing labels or background colors) on bars
// where no trading activity is occurring. This results in a much faster and more
// responsive script.
//
// âš™ï¸ HOW IT WORKS (ZOOM GATING):
// - The script determines a 'skipFactor' based on the chart's timeframe. Lower
//   timeframes have a higher skip factor (e.g., render 1 in every 5 bars), while
//   higher timeframes render every bar.
// - The 'shouldRender' variable is true only on bars that fall on this interval.
// - CRITICALLY, the 'shouldRenderCritical' variable ensures that rendering is NEVER
//   skipped if a position is opened/closed or on the very last bar of the chart.
//   This guarantees that all important events are always visualized.

getOptimizedSkipFactor() =>
    seconds = timeframe.in_seconds(timeframe.period)
    positionActive = strategy.position_size != 0
    
    // Always render when position is active or on important bars
    if positionActive or barstate.isconfirmed
        1  // No skipping for active positions or confirmed bars
    else
        switch
            seconds <= 60   => 5   // 1-minute: every 5th bar when flat
            seconds <= 300  => 3   // 5-minute: every 3rd bar when flat
            seconds <= 900  => 2   // 15-minute: every 2nd bar when flat
            => 1               // Higher timeframes: all bars

skipFactor = getOptimizedSkipFactor()
shouldRender = bar_index % skipFactor == 0

// Note: shouldRenderCritical is calculated in the PERFORMANCE-OPTIMIZED RENDERING section below

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STREAMLINED ANTI-OVERLAP SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// To prevent on-chart labels from drawing on top of one another, which would make
// them unreadable. This system ensures that labels are neatly stacked and spaced
// out, even when multiple events occur in close proximity.

var float[] lastLabelY = array.new<float>(4, na)  // Pre-sized array for better performance
var int[] lastLabelBar = array.new<int>(4, na)    // Pre-sized array for better performance

// No need for initialization code - arrays are pre-sized with na values

// Optimized label positioning with adaptive spacing
getSmartLabelY(baseY, isAbove, priority) =>
    currentBarLocal = bar_index
    atrPadding = ta.atr(14) * 0.2  // Increased spacing for better readability
    
    // Simplified priority mapping
    priorityIndex = switch priority
        "critical"   => 0
        "important"  => 1
        "normal"     => 2
        "debug"      => 3
        => 2
    
    lastY = array.get(lastLabelY, priorityIndex)
    lastBar = array.get(lastLabelBar, priorityIndex)
    
    // Adaptive padding based on priority
    minPadding = atrPadding * (priority == "critical" ? 2.5 : priority == "important" ? 2.0 : 1.5)
    
    // Calculate new Y position with collision avoidance
    newY = float(na)
    if currentBarLocal == lastBar and not na(lastY)
        offset = isAbove ? minPadding : -minPadding
        newY := lastY + offset
    else
        newY := baseY
    
    // Update tracking arrays
    array.set(lastLabelY, priorityIndex, newY)
    array.set(lastLabelBar, priorityIndex, currentBarLocal)
    
    newY

// --------------------------------------------------------------------------------------------------
// SECTION: MEMORY-SAFE DEBUG SYSTEM
// KEYWORDS: Debugging, Memory Management, Performance
// --------------------------------------------------------------------------------------------------
// This system provides a safe way to display debug information on the chart without
// causing memory leaks or performance issues, which are common with dynamic label creation.
// It uses a pre-allocated pool of labels that are recycled, preventing the script from
// hitting Pine Script's 500-drawing limit.

// debugLevel already declared at top

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DEBUG & RENDERING VARIABLES â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// These must be declared early since they're used throughout the script
var bool debugEnabled = false               // Debug system enabled flag
var bool showDebugLabels = false            // Show debug labels flag
var bool showDetailedDebug = false          // Detailed debug mode flag  
var bool showFullDebug = false              // Full debug mode flag
var bool shouldRenderDebug = false          // Should render debug elements

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DEBUG SYSTEM INITIALIZATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Update debug flags based on input values (variables declared early in GLOBAL section)
debugEnabled := debugLevel != "Off"
showDebugLabels := debugEnabled
showDetailedDebug := debugLevel == "Detailed" or debugLevel == "Full"
showFullDebug := debugLevel == "Full"

// Optimized debug message function with priority-based allocation
// Updated for Pine Script consistency - always call but conditionally execute
debugMessage(string type, string message, color bgColor, color txtColor, float yOffset, bool isPriority = false) =>
    // Always call but conditionally execute for Pine Script consistency
    if shouldRenderDebug and debugEnabled
        // Get label with priority flag
        labelId = getLabelFromPool(isPriority)
        if not na(labelId)
            debugColor = getSemanticColor("info", "background")
            textColor = getContrastSafeTextColor(debugColor)
            yPos = getSmartLabelY(high + (high - low) * yOffset, true, isPriority ? "important" : "debug")
            
            // Truncate very long messages to save memory
            displayMessage = str.length(message) > 100 ? str.substring(message, 0, 97) + "..." : message
            updateLabel(labelId, bar_index, yPos, type + ": " + displayMessage, label.style_label_down, debugColor, textColor, size.small)
    // Return a dummy value for consistency
    true

// --------------------------------------------------------------------------------------------------
// SECTION: STRATEGY DECLARATION & CORE SETTINGS
// KEYWORDS: Strategy, Pyramiding, Backtest, Execution, Orders
// --------------------------------------------------------------------------------------------------
strategy('EZ Algo Hedge Fund', 
         overlay=true,  // Strategy plots directly on the main chart.
         calc_on_order_fills=true,  // Recalculates the script each time an order is filled.
         process_orders_on_close=false,  // Enable intrabar processing for continuation entries and Smart Profit Locker exits.
         calc_on_every_tick=true,  // Enable intrabar execution for continuation entries and trailing stops.
         dynamic_requests=true, // Allow request.security() calls in conditional structures
         max_bars_back=500) // Ensure sufficient historical buffer for all calculations

// Duplicate input declarations removed - all inputs now at top of file

// --------------------------------------------------------------------------------------------------
// SECTION: GLOBAL VARIABLE DECLARATIONS
// KEYWORDS: Global Variables, State Management, Strategy State
// --------------------------------------------------------------------------------------------------
// These variables use the `var` keyword to maintain their state across multiple bars.

// --- Exit System State ---
// Manages the state of the various exit systems. The boolean 'sent' flags are
// crucial anti-spam controls, ensuring that we only send one of each type of
// exit order per trade, preventing conflicting or redundant exit signals.
var float smartOffset = na         // Stores the calculated offset for the Smart Profit Locker, determining the trailing distance.
var float smartDistance = na       // Stores the calculated price distance for the Smart Profit Locker exit.
var bool trailExitSent = false       // Anti-spam flag for the Smart Profit Locker. Becomes true after the exit is sent, preventing duplicates.
var bool maExitSent = false          // Anti-spam flag for the Moving Average exit. Becomes true after the exit is sent.
var bool fixedExitSent = false       // Anti-spam flag for the Fixed SL/TP exit. Becomes true after the exit is sent.

// --- Entry Control State ---
var bool entryAllowed = true         // Master flag controlling new entries
var bool longEntrySignal = false     // Final long entry signal for strategy execution
var bool shortEntrySignal = false    // Final short entry signal for strategy execution
var bool baseLongWithBias = false    // Base long signal with directional bias applied
var bool baseShortWithBias = false   // Base short signal with directional bias applied

// --- Additional Position State Variables ---
var bool inPosition = false          // Tracks if currently in a position
var bool fibExitSent = false         // Anti-spam flag for Fibonacci exits
var bool customExitSent = false      // Anti-spam flag for custom exits  
var bool exitInProgress = false      // Tracks if an exit is currently in progress
var bool allowTrendExit = false      // Controls trend-based exit permissions

// --- Message Variables ---
// flatExitMsg will be built later with _jsonBase for proper format

// â”€â”€â”€â”€â”€â”€â”€â”€ TRADE MODE SYSTEM FOR SPL GATING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
var string tradeMode = "SCALP"      // Current trading mode: "SCALP", "HYBRID", or "TREND"  
                                    // SCALP: SPL always active, HYBRID: SPL with conditions, TREND: SPL disabled

// --- Legacy Trend-Riding State (for compatibility) ---
var bool inTrendRidingMode = false  // Tracks if the strategy is currently in trend-riding mode.
var int trendRidingStartBar = na    // The bar_index when trend-riding mode was initiated.

// --- Adaptive SuperTrend K-means Clustering State ---
// These variables support the full K-means implementation for volatility analysis.
var array<float> adaptive_hv = array.new_float()       // High volatility cluster data.
var array<float> adaptive_mv = array.new_float()       // Medium volatility cluster data.
var array<float> adaptive_lv = array.new_float()       // Low volatility cluster data.
var array<float> adaptive_amean = array.new_float(1, 0) // Centroid for cluster A.
var array<float> adaptive_bmean = array.new_float(1, 0) // Centroid for cluster B.
var array<float> adaptive_cmean = array.new_float(1, 0) // Centroid for cluster C.
var float adaptive_assigned_centroid = na              // The centroid assigned to the current bar.
var int adaptive_iterations = 0                        // Tracks iterations for the K-means algorithm.

// --- Adaptive SuperTrend Exit Filter State ---
var bool adaptiveExitBlocked = false // True if the adaptive filter is currently blocking an exit.
var bool adaptivePendingExit = false // True if an exit is waiting for the adaptive filter to be cleared.
var string adaptiveExitReason = na   // The reason for the pending exit.

// --------------------------------------------------------------------------------------------------
// SECTION: GLOBAL CALCULATION SETTINGS
// KEYWORDS: ATR, Volatility
// --------------------------------------------------------------------------------------------------
// All inputs now declared at top after strategy declaration

// --------------------------------------------------------------------------------------------------
// SECTION: POSITION SIZING - USING TV DEFAULTS
// KEYWORDS: Risk Management, Position Size, Quantity, Contracts
// --------------------------------------------------------------------------------------------------
// Position sizing is controlled by TradingView's default strategy settings
// Use the Properties panel to set: Default Quantity Type and Default Quantity Value

// --------------------------------------------------------------------------------------------------
// SECTION: CONTINUATION ENTRY SYSTEM
// KEYWORDS: Continuation Entry, Entry Precision, False Signal Filter
// --------------------------------------------------------------------------------------------------
// This system improves entry precision by waiting for price to move a specified distance in the
// signal's direction before executing the trade, helping to filter out false signals.

// --- Continuation Entry (moved to Multi-Signals section) ---
// This will be moved to the top of Multi-Signals group below

// --- Continuation Entry State Management ---
var float longContinuationLevel = na   // The price level that must be broken for a long entry.
var float shortContinuationLevel = na  // The price level that must be broken for a short entry.
var bool longContinuationActive = false  // True if waiting for a long continuation signal.
var bool shortContinuationActive = false // True if waiting for a short continuation signal.
var int continuationStartBar = na      // The bar_index when the continuation was initiated.
var float continuationStartPrice = na  // The price when the continuation was initiated.

// All exit system inputs and calculations now declared at top after strategy declaration

// --------------------------------------------------------------------------------------------------
// SECTION: EXIT SYSTEMS
// KEYWORDS: Exit Logic, Profit Taking, Stop Loss, Risk Management
// --------------------------------------------------------------------------------------------------
// This implements the proper exit hierarchy with state tracking to prevent conflicts

// 1. Smart Profit Locker (Primary for Scalp Mode)
if smartProfitEnable and strategy.position_size != 0 and not trailExitSent and tradeMode != "TREND"
    if strategy.position_size > 0
        strategy.exit("SPL-Long", "Long", trail_points=smartDistance, trail_offset=smartOffset)
        trailExitSent := true
        if debugEnabled
            debugMessage("INFO", "ğŸ¯ SPL-Long activated - Distance: " + str.tostring(smartDistance, "#.##"), color.green, color.white, 0.05)
    else if strategy.position_size < 0
        strategy.exit("SPL-Short", "Short", trail_points=smartDistance, trail_offset=smartOffset)
        trailExitSent := true
        if debugEnabled
            debugMessage("INFO", "ğŸ¯ SPL-Short activated - Distance: " + str.tostring(smartDistance, "#.##"), color.green, color.white, 0.05)

// Exit systems code moved to proper location after variable declarations

// --------------------------------------------------------------------------------------------------
// SECTION: DIRECTIONAL & REGIME FILTERS
// KEYWORDS: Trend Filter, Regime Filter, Directional Bias
// --------------------------------------------------------------------------------------------------

// --- Step Channel Momentum System ---
stepChannelEnable = input.bool(true, "Enable Step Channel", group="ğŸ¯ Step Channel Scalp Zone", tooltip="Enable the Step Channel system for momentum detection")
// PHASE 2: Separate directional bias from primary mode detection function
stepChannelDirectionalBias = input.bool(false, "Use for Directional Bias", group="ğŸ¯ Step Channel Scalp Zone", tooltip="OPTIONAL: Also use Step Channel for directional bias (blocks opposite direction trades). Primary function is always trend/scalp mode detection.")

// --- Step Channel Variables (declared early for directional bias) ---
var float stepChannelUpper = na
var float stepChannelLower = na

// â”€â”€â”€â”€â”€â”€â”€â”€ SECTION 1: ADAPTIVE SUPERTREND VOLATILITY EXIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
adaptiveExitFilterEnable = input.bool(false, 'ğŸŒªï¸ Enable Volatility Exit Block', group='4ï¸âƒ£ Adaptive SuperTrend Volatility Exit', tooltip='Block exits when volatility regime is active (1, 2, or 3)')
adaptiveRegimeInput = input.source(close, 'Volatility Signal Source', group='4ï¸âƒ£ Adaptive SuperTrend Volatility Exit', tooltip='Connect to Adaptive SuperTrend volatility output (1, 2, or 3)')
adaptiveHoldOn3 = input.bool(true, 'Block Exit on Level 3', group='4ï¸âƒ£ Adaptive SuperTrend Volatility Exit', inline='av1', tooltip='Do not exit when volatility regime is "3" (high volatility)')
adaptiveHoldOn2 = input.bool(false, 'Block Exit on Level 2', group='4ï¸âƒ£ Adaptive SuperTrend Volatility Exit', inline='av1', tooltip='Do not exit when volatility regime is "2" (medium volatility)')
adaptiveHoldOn1 = input.bool(false, 'Block Exit on Level 1', group='4ï¸âƒ£ Adaptive SuperTrend Volatility Exit', inline='av1', tooltip='Do not exit when volatility regime is "1" (low volatility)')

// â”€â”€â”€â”€â”€â”€â”€â”€ SECTION 2: TREND EXIT â€º MOVING AVERAGE CROSSOVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
trendMACrossoverExit = input.bool(false, 'ğŸ“ˆ Enable Trend MA Crossover Exit', group='5ï¸âƒ£ Trend Exit â€º Moving Average Crossover', tooltip='Exit trend positions when MA crossover occurs (TREND mode only)')
maCrossoverFastLength = input.int(8, 'Fast MA Length', minval=1, maxval=50, group='5ï¸âƒ£ Trend Exit â€º Moving Average Crossover', inline='ma1', tooltip='Fast moving average length')
maCrossoverSlowLength = input.int(35, 'Slow MA Length', minval=10, maxval=200, group='5ï¸âƒ£ Trend Exit â€º Moving Average Crossover', inline='ma1', tooltip='Slow moving average length')
maCrossoverType = input.string('SMA', 'MA Type', options=['SMA', 'EMA', 'WMA'], group='5ï¸âƒ£ Trend Exit â€º Moving Average Crossover', inline='ma2', tooltip='Type of moving average to use for crossover detection')

// â”€â”€â”€â”€â”€â”€â”€â”€ SECTION 3: TREND EXIT â€º TREND BREAK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
trendBreakEnable = input.bool(false, 'ğŸ“‰ Enable Trend Break Exit', group='6ï¸âƒ£ Trend Exit â€º Trend Break', tooltip='Exit when any selected trend indicator breaks in opposite direction (whichever happens first)')
trendStrengthTrendExit = input.bool(false, 'ğŸ’ª Trend Strength', group='6ï¸âƒ£ Trend Exit â€º Trend Break', inline='tb1', tooltip='Exit when Trend Strength flips against position direction')
quadrantTrendExit = input.bool(false, 'ğŸ¯ Quadrant NW', group='6ï¸âƒ£ Trend Exit â€º Trend Break', inline='tb1', tooltip='Exit when Quadrant NW flips against position direction')
adaptiveTrendExit = input.bool(false, 'ğŸ”„ Adaptive ST', group='6ï¸âƒ£ Trend Exit â€º Trend Break', inline='tb2', tooltip='Exit when Adaptive SuperTrend flips against position direction')
volumaticTrendExit = input.bool(false, 'ğŸ“Š Volumatic', group='6ï¸âƒ£ Trend Exit â€º Trend Break', inline='tb2', tooltip='Exit when Volumatic VIDYA flips against position direction')
smoothHATrendExit = input.bool(false, 'ğŸ•¯ï¸ Smooth HA', group='6ï¸âƒ£ Trend Exit â€º Trend Break', inline='tb3', tooltip='Exit when Smooth Heiken Ashi flips against position direction')

// External trend exit signal (part of trend break section)
trendExitSignalEnable = input.bool(false, 'ğŸ“¡ External Trend Exit', group='6ï¸âƒ£ Trend Exit â€º Trend Break', inline='te6', tooltip='Use external indicator for trend exit signals')
trendExitSignalSrc = input.source(close, 'Signal Source', group='6ï¸âƒ£ Trend Exit â€º Trend Break', inline='te6', tooltip='Connect to buy/sell signal output from external trend exit indicator')

// Trend break exit logic and debug
trendExitLogic = input.string('Any Filter Triggers Exit', 'Exit Logic', options=['Any Filter Triggers Exit', 'All Filters Must Agree'], group='6ï¸âƒ£ Trend Exit â€º Trend Break', tooltip='ANY: Exit when first filter condition is met. ALL: Wait for all enabled filters to agree before exiting.')
trendExitDebug = input.bool(false, 'Show Debug Info', group='6ï¸âƒ£ Trend Exit â€º Trend Break', tooltip='Display debug information about trend-exit filter status on chart')

// â”€â”€â”€â”€â”€â”€â”€â”€ SECTION 4: DIRECTIONAL BIAS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
directionalBiasEnable = input.bool(false, 'ğŸ§­ Enable Directional Bias', group='7ï¸âƒ£ Directional Bias', tooltip='Only take trades in the direction the majority of selected trend indicators agree on')
biasConfluence = input.string('Majority', 'Confluence Mode', options=['Any', 'Majority', 'All'], group='7ï¸âƒ£ Directional Bias', tooltip='Any: At least one agrees | Majority: Most agree | All: All must agree')
trendStrengthBiasEnable = input.bool(false, 'ğŸ’ª Trend Strength', group='7ï¸âƒ£ Directional Bias', inline='db1', tooltip='Enable Trend Strength for directional bias calculation')
hullBiasEnable = input.bool(true, 'ğŸŒŠ Hull Suite', group='7ï¸âƒ£ Directional Bias', inline='db1', tooltip='Enable Hull Suite for directional bias calculation')
quadrantBiasEnable = input.bool(false, 'ğŸ¯ Quadrant NW', group='7ï¸âƒ£ Directional Bias', inline='db2', tooltip='Enable Quadrant NW for directional bias calculation')
adaptiveBiasEnable = input.bool(false, 'ğŸ¤– Adaptive ST', group='7ï¸âƒ£ Directional Bias', inline='db2', tooltip='Enable Adaptive SuperTrend for directional bias calculation')
volumaticBiasEnable = input.bool(false, 'ğŸ“Š Volumatic', group='7ï¸âƒ£ Directional Bias', inline='db3', tooltip='Enable Volumatic VIDYA for directional bias calculation')
smoothHABiasEnable = input.bool(false, 'ğŸ•¯ï¸ Smooth HA', group='7ï¸âƒ£ Directional Bias', inline='db3', tooltip='Enable Smooth Heiken Ashi for directional bias calculation')

// --------------------------------------------------------------------------------------------------
// SECTION: MULTI-SIGNAL INPUT SYSTEM
// KEYWORDS: Signal Inputs, Entry Signals, External Indicators, LuxAlgo, UTBot, RSI, MACD
// --------------------------------------------------------------------------------------------------
// This system allows for the configuration of up to 10 independent signal sources. Each signal can be
// connected to an external indicator's plot output and configured for specific behaviors.
// The UI is organized into a 3-row layout for clarity and ease of use.

// --- Continuation Entry Controls (Intrabar Execution) ---
continuationEnable = input.bool(true, 'ğŸ¯ Enable Continuation Entry', group='2ï¸âƒ£ Entry Signals', tooltip='Pockets buy/sell signals and waits for price continuation before intrabar entry - improves precision and reduces false signals')
continuationValue = input.float(0.25, 'Continuation Distance', step=0.01, minval=0.01, group='2ï¸âƒ£ Entry Signals', inline='cont1', tooltip='Distance price must move in signal direction before entry (supports 2 decimal precision)')
continuationType = input.string('ATR', 'Type', options=['ATR', 'Points', 'Ticks'], group='2ï¸âƒ£ Entry Signals', inline='cont1', tooltip='ATR: Multiple of ATR value | Points: Absolute price points | Ticks: Number of minimum tick movements')
continuationTimeoutBars = input.int(10, 'Timeout (Bars)', minval=1, group='2ï¸âƒ£ Entry Signals', inline='cont2', tooltip='Number of bars to wait for continuation before cancelling the pending entry')
continuationShowDebug = input.bool(false, 'Show Debug', group='2ï¸âƒ£ Entry Signals', inline='cont2', tooltip='Display continuation status and levels on chart for debugging')

// --- Signal 1 ---
signal1Enable = input.bool(true, 'Signal 1', inline='sig1', group='2ï¸âƒ£ Entry Signals', tooltip='Primary signal source')
signal1Name = input.string('LuxAlgo', 'Name', options=['LuxAlgo', 'UTBot', 'MACD', 'Range Filter', 'Smooth HK', 'Custom'], inline='sig1', group='2ï¸âƒ£ Entry Signals')
signal1Usage = input.string('All Entries', 'Usage', options=['Long Only', 'Short Only', 'All Entries', 'Trend Exit', 'Observe'], inline='sig1', group='2ï¸âƒ£ Entry Signals')
// Row 2: Long + Short Sources
signal1LongSrc = input.source(close, 'Long', inline='sig1src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: LuxAlgo Long, UTBot Long, Smooth HK: Bull Signal Plot, or any Long signal plot')
signal1ShortSrc = input.source(close, 'Short', inline='sig1src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: LuxAlgo Short, UTBot Short, Smooth HK: Bear Signal Plot, or any Short signal plot')

    
// Signal 2
// Row 1: Enable + Name + Usage
signal2Enable = input.bool(false, 'Signal 2', inline='sig2', group='2ï¸âƒ£ Entry Signals', tooltip='Secondary signal source')
signal2Name = input.string('UTBot', 'Name', inline='sig2', group='2ï¸âƒ£ Entry Signals')
signal2Usage = input.string('All Entries', 'Usage', options=['Long Only', 'Short Only', 'All Entries', 'Trend Exit', 'Observe'], inline='sig2', group='2ï¸âƒ£ Entry Signals')
// Row 2: Long + Short Sources
signal2LongSrc = input.source(close, 'Long', inline='sig2src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: UTBot Long, MACD Long, or any Long signal plot')
signal2ShortSrc = input.source(close, 'Short', inline='sig2src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: UTBot Short, MACD Short, or any Short signal plot')

    
// Signal 3
// Row 1: Enable + Name + Usage
signal3Enable = input.bool(false, 'Signal 3', inline='sig3', group='2ï¸âƒ£ Entry Signals', tooltip='Third signal source')
signal3Name = input.string('RSI', 'Name', inline='sig3', group='2ï¸âƒ£ Entry Signals')
signal3Usage = input.string('All Entries', 'Usage', options=['Long Only', 'Short Only', 'All Entries', 'Trend Exit', 'Observe'], inline='sig3', group='2ï¸âƒ£ Entry Signals')
// Row 2: Long + Short Sources
signal3LongSrc = input.source(close, 'Long', inline='sig3src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: RSI Long, Stoch Long, or any Long signal plot')
signal3ShortSrc = input.source(close, 'Short', inline='sig3src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: RSI Short, Stoch Short, or any Short signal plot')


// Signal 4
// Row 1: Enable + Name + Usage
signal4Enable = input.bool(false, 'Signal 4', inline='sig4', group='2ï¸âƒ£ Entry Signals', tooltip='Fourth signal source')
signal4Name = input.string('MACD', 'Name', inline='sig4', group='2ï¸âƒ£ Entry Signals')
signal4Usage = input.string('All Entries', 'Usage', options=['Long Only', 'Short Only', 'All Entries', 'Trend Exit', 'Observe'], inline='sig4', group='2ï¸âƒ£ Entry Signals')
// Row 2: Long + Short Sources
signal4LongSrc = input.source(close, 'Long', inline='sig4src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: MACD Long, CCI Long, or any Long signal plot')
signal4ShortSrc = input.source(close, 'Short', inline='sig4src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: MACD Short, CCI Short, or any Short signal plot')


// Signal 5
// Row 1: Enable + Name + Usage
signal5Enable = input.bool(false, 'Signal 5', inline='sig5', group='2ï¸âƒ£ Entry Signals', tooltip='Fifth signal source')
signal5Name = input.string('Stoch', 'Name', inline='sig5', group='2ï¸âƒ£ Entry Signals')
signal5Usage = input.string('All Entries', 'Usage', options=['Long Only', 'Short Only', 'All Entries', 'Trend Exit', 'Observe'], inline='sig5', group='2ï¸âƒ£ Entry Signals')
// Row 2: Long + Short Sources
signal5LongSrc = input.source(close, 'Long', inline='sig5src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: Stoch Long, Williams Long, or any Long signal plot')
signal5ShortSrc = input.source(close, 'Short', inline='sig5src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: Stoch Short, Williams Short, or any Short signal plot')


// Signal 6
// Row 1: Enable + Name + Usage
signal6Enable = input.bool(false, 'Signal 6', inline='sig6', group='2ï¸âƒ£ Entry Signals', tooltip='Sixth signal source')
signal6Name = input.string('CCI', 'Name', inline='sig6', group='2ï¸âƒ£ Entry Signals')
signal6Usage = input.string('All Entries', 'Usage', options=['Long Only', 'Short Only', 'All Entries', 'Trend Exit', 'Observe'], inline='sig6', group='2ï¸âƒ£ Entry Signals')
// Row 2: Long + Short Sources
signal6LongSrc = input.source(close, 'Long', inline='sig6src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: CCI Long, Williams Long, or any Long signal plot')
signal6ShortSrc = input.source(close, 'Short', inline='sig6src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: CCI Short, Williams Short, or any Short signal plot')


// Signal 7
// Row 1: Enable + Name + Usage
signal7Enable = input.bool(false, 'Signal 7', inline='sig7', group='2ï¸âƒ£ Entry Signals', tooltip='Seventh signal source')
signal7Name = input.string('ADX', 'Name', inline='sig7', group='2ï¸âƒ£ Entry Signals')
signal7Usage = input.string('All Entries', 'Usage', options=['Long Only', 'Short Only', 'All Entries', 'Trend Exit', 'Observe'], inline='sig7', group='2ï¸âƒ£ Entry Signals')
// Row 2: Long + Short Sources
signal7LongSrc = input.source(close, 'Long', inline='sig7src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: ADX Long, MFI Long, or any Long signal plot')
signal7ShortSrc = input.source(close, 'Short', inline='sig7src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: ADX Short, MFI Short, or any Short signal plot')


// Signal 8
// Row 1: Enable + Name + Usage
signal8Enable = input.bool(false, 'Signal 8', inline='sig8', group='2ï¸âƒ£ Entry Signals', tooltip='Eighth signal source')
signal8Name = input.string('MFI', 'Name', inline='sig8', group='2ï¸âƒ£ Entry Signals')
signal8Usage = input.string('All Entries', 'Usage', options=['Long Only', 'Short Only', 'All Entries', 'Trend Exit', 'Observe'], inline='sig8', group='2ï¸âƒ£ Entry Signals')
// Row 2: Long + Short Sources
signal8LongSrc = input.source(close, 'Long', inline='sig8src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: MFI Long, OBV Long, or any Long signal plot')
signal8ShortSrc = input.source(close, 'Short', inline='sig8src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: MFI Short, OBV Short, or any Short signal plot')


// Signal 9
// Row 1: Enable + Name + Usage
signal9Enable = input.bool(false, 'Signal 9', inline='sig9', group='2ï¸âƒ£ Entry Signals', tooltip='Ninth signal source')
signal9Name = input.string('OBV', 'Name', inline='sig9', group='2ï¸âƒ£ Entry Signals')
signal9Usage = input.string('All Entries', 'Usage', options=['Long Only', 'Short Only', 'All Entries', 'Trend Exit', 'Observe'], inline='sig9', group='2ï¸âƒ£ Entry Signals')
// Row 2: Long + Short Sources
signal9LongSrc = input.source(close, 'Long', inline='sig9src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: OBV Long, Custom Long, or any Long signal plot')
signal9ShortSrc = input.source(close, 'Short', inline='sig9src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: OBV Short, Custom Short, or any Short signal plot')


// Signal 10
// Row 1: Enable + Name + Usage
signal10Enable = input.bool(false, 'Signal 10', inline='sig10', group='2ï¸âƒ£ Entry Signals', tooltip='Tenth signal source')
signal10Name = input.string('Custom', 'Name', inline='sig10', group='2ï¸âƒ£ Entry Signals')
signal10Usage = input.string('All Entries', 'Usage', options=['Long Only', 'Short Only', 'All Entries', 'Trend Exit', 'Observe'], inline='sig10', group='2ï¸âƒ£ Entry Signals')
// Row 2: Long + Short Sources
signal10LongSrc = input.source(close, 'Long', inline='sig10src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: Custom Long, External Long, or any Long signal plot')
signal10ShortSrc = input.source(close, 'Short', inline='sig10src', group='2ï¸âƒ£ Entry Signals', tooltip='Connect to: Custom Short, External Short, or any Short signal plot')

    
// Duplicate SPL settings removed - SPL settings are at lines 69-72

// Duplicate exit system settings removed - all exit settings are at lines 75-84
    
// 4ï¸âƒ£ HYBRID / TREND MODE CONTROLS
// ğŸ¯ PURPOSE:
// automatic Finite State Machine (FSM) that switches the strategy's behavior

// --------------------------------------------------------------------------------------------------
// SECTION: LABELING OPTIONS
// KEYWORDS: Chart Labels, Visualization
// --------------------------------------------------------------------------------------------------
// These settings control the appearance of entry labels. They are on by default for clarity.
displayEntryLabels = true
labelColorLong     = color.green
labelColorShort    = color.red

// --------------------------------------------------------------------------------------------------
// SECTION: SIGNAL SOURCE VALIDATION
// KEYWORDS: Signal Validation, Safety, Bug Fix, False Signal
// --------------------------------------------------------------------------------------------------
// CRITICAL SAFETY FEATURE: Prevents false signals from being generated by unconnected input sources.
// A signal is only considered valid if its source is NOT the default `close`, `open`, `high`, or `low` price.

// Helper function to validate that a signal source is connected to a real indicator plot.
// CRITICAL: Prevents false signals from default 'close' price inputs
isValidSignalSource(src) =>
    not na(src) and src != close and src != open and src != high and src != low

// Stricter validation for external indicators to ensure uniform safety across all signals.
isValidExternalSignal(src) =>
    not na(src) and src != close and src != open and src != high and src != low

// --------------------------------------------------------------------------------------------------
// SECTION: SIGNAL USAGE PROCESSING
// KEYWORDS: Signal Usage, Entry Logic, Exit Logic, Flexible Signals
// --------------------------------------------------------------------------------------------------
// This helper function processes raw signals based on the 'Usage' dropdown selected for each signal.
// It allows each indicator to be flexibly assigned to different roles (e.g., long only, exit only).

processSignalWithUsage(bool rawLongSignal, bool rawShortSignal, string usage) =>
    var bool processedLong = false
    var bool processedShort = false
    var bool isEntrySignal = false
    var bool isExitSignal = false
    
    // Determine the signal's role based on the user-selected usage type.
    isEntrySignal := usage == 'Entry Only' or usage == 'Both' or usage == 'Long Only' or usage == 'Short Only'
    isExitSignal := usage == 'Exit Only' or usage == 'Both'
    
    // Apply the usage logic to the raw signals.
    if usage == 'Entry Only' or usage == 'Both'
        processedLong := rawLongSignal
        processedShort := rawShortSignal
    else if usage == 'Long Only'
        processedLong := rawLongSignal
        processedShort := false  // Block short entries.
    else if usage == 'Short Only'
        processedLong := false   // Block long entries.
        processedShort := rawShortSignal
    else if usage == 'Exit Only'
        // Exit signals are handled by the trend-riding logic, not the primary entry system.
        processedLong := false
        processedShort := false
    else if usage == 'Observe'
        // 'Observe' mode tracks the signal but does not generate trades.
        processedLong := false
        processedShort := false
    else
        // Default to 'Entry Only' behavior if the usage type is unrecognized.
        processedLong := rawLongSignal
        processedShort := rawShortSignal
    
    [processedLong, processedShort, isEntrySignal, isExitSignal]

// --------------------------------------------------------------------------------------------------
// SECTION: CORE SIGNAL PROCESSING LOGIC
// KEYWORDS: Signal Detection, Raw Signals, Core Logic
// --------------------------------------------------------------------------------------------------
// This is the primary signal detection block. It checks if each enabled signal is valid (i.e., connected)
// and if its plot value is active (greater than 0 or true).

// --- WORKING Signal Detection (from BackTester.pine) ---
// CRITICAL FIX: Signals ONLY fire when external indicators are connected
// When source equals close (default), signals are DISABLED - no trading allowed
// When external indicator connected, use proper change detection for pulses
sig1Long = signal1Enable ? (signal1LongSrc != close ? ta.change(signal1LongSrc) > 0 : false) : false
sig1Short = signal1Enable ? (signal1ShortSrc != close ? ta.change(signal1ShortSrc) > 0 : false) : false
sig2Long = signal2Enable ? (signal2LongSrc != close ? ta.change(signal2LongSrc) > 0 : false) : false
sig2Short = signal2Enable ? (signal2ShortSrc != close ? ta.change(signal2ShortSrc) > 0 : false) : false
sig3Long = signal3Enable ? (signal3LongSrc != close ? ta.change(signal3LongSrc) > 0 : false) : false
sig3Short = signal3Enable ? (signal3ShortSrc != close ? ta.change(signal3ShortSrc) > 0 : false) : false
sig4Long = signal4Enable ? (signal4LongSrc != close ? ta.change(signal4LongSrc) > 0 : false) : false
sig4Short = signal4Enable ? (signal4ShortSrc != close ? ta.change(signal4ShortSrc) > 0 : false) : false
sig5Long = signal5Enable ? (signal5LongSrc != close ? ta.change(signal5LongSrc) > 0 : false) : false
sig5Short = signal5Enable ? (signal5ShortSrc != close ? ta.change(signal5ShortSrc) > 0 : false) : false
sig6Long = signal6Enable ? (signal6LongSrc != close ? ta.change(signal6LongSrc) > 0 : false) : false
sig6Short = signal6Enable ? (signal6ShortSrc != close ? ta.change(signal6ShortSrc) > 0 : false) : false
sig7Long = signal7Enable ? (signal7LongSrc != close ? ta.change(signal7LongSrc) > 0 : false) : false
sig7Short = signal7Enable ? (signal7ShortSrc != close ? ta.change(signal7ShortSrc) > 0 : false) : false
sig8Long = signal8Enable ? (signal8LongSrc != close ? ta.change(signal8LongSrc) > 0 : false) : false
sig8Short = signal8Enable ? (signal8ShortSrc != close ? ta.change(signal8ShortSrc) > 0 : false) : false
sig9Long = signal9Enable ? (signal9LongSrc != close ? ta.change(signal9LongSrc) > 0 : false) : false
sig9Short = signal9Enable ? (signal9ShortSrc != close ? ta.change(signal9ShortSrc) > 0 : false) : false
sig10Long = signal10Enable ? (signal10LongSrc != close ? ta.change(signal10LongSrc) > 0 : false) : false
sig10Short = signal10Enable ? (signal10ShortSrc != close ? ta.change(signal10ShortSrc) > 0 : false) : false

// Direct signal processing (simplified like BackTester.pine)
// All signals are treated as entry signals by default - usage filtering removed for clarity

// --- Signal Count Calculations ---
longSignalCount = (sig1Long ? 1 : 0) + (sig2Long ? 1 : 0) + (sig3Long ? 1 : 0) + (sig4Long ? 1 : 0) + (sig5Long ? 1 : 0) + (sig6Long ? 1 : 0) + (sig7Long ? 1 : 0) + (sig8Long ? 1 : 0) + (sig9Long ? 1 : 0) + (sig10Long ? 1 : 0)
shortSignalCount = (sig1Short ? 1 : 0) + (sig2Short ? 1 : 0) + (sig3Short ? 1 : 0) + (sig4Short ? 1 : 0) + (sig5Short ? 1 : 0) + (sig6Short ? 1 : 0) + (sig7Short ? 1 : 0) + (sig8Short ? 1 : 0) + (sig9Short ? 1 : 0) + (sig10Short ? 1 : 0)

// --------------------------------------------------------------------------------------------------
// SECTION: SIGNAL CONFLUENCE & COUNTING
// KEYWORDS: Signal Count, Confluence, Entry Trigger
// --------------------------------------------------------------------------------------------------
// This block counts the total number of active long and short signals that are configured for entry.
// This count is the primary driver for trade execution.

// --- Signal Counting Logic ---
// DO NOT MODIFY. This logic is essential for the strategy's entry decisions.
var int sigCountLong = 0
var int sigCountShort = 0

// Direct signal counting (like BackTester.pine) - all signals are entry signals
sigCountLong := (sig1Long ? 1 : 0) + (sig2Long ? 1 : 0) + (sig3Long ? 1 : 0) + (sig4Long ? 1 : 0) + (sig5Long ? 1 : 0) + (sig6Long ? 1 : 0) + (sig7Long ? 1 : 0) + (sig8Long ? 1 : 0) + (sig9Long ? 1 : 0) + (sig10Long ? 1 : 0)
sigCountShort := (sig1Short ? 1 : 0) + (sig2Short ? 1 : 0) + (sig3Short ? 1 : 0) + (sig4Short ? 1 : 0) + (sig5Short ? 1 : 0) + (sig6Short ? 1 : 0) + (sig7Short ? 1 : 0) + (sig8Short ? 1 : 0) + (sig9Short ? 1 : 0) + (sig10Short ? 1 : 0)


// --------------------------------------------------------------------------------------------------
// SECTION: DIRECTIONAL & REGIME FILTERS
// KEYWORDS: Trend Filter, Regime Filter, Directional Bias
// --------------------------------------------------------------------------------------------------

// --- Step Channel calculation moved to proper section below ---

// --- PHASE 2: Redesigned Step Channel Logic ---
// PRIMARY FUNCTION: Mode detection (always active when Step Channel enabled)
// SECONDARY FUNCTION: Optional directional bias (only when stepChannelDirectionalBias = true)

// Mode detection variables (always calculated when Step Channel enabled)
var bool stepChannelLongOK = true
var bool stepChannelShortOK = true

if stepChannelEnable
    // PHASE 2: Separate the two functions
    if stepChannelDirectionalBias
        // OPTIONAL: Use for directional bias (blocks opposite direction trades)
        stepChannelLongOK := close > stepChannelLower
        stepChannelShortOK := close < stepChannelUpper
    else
        // DEFAULT: No directional bias - allow both directions
        stepChannelLongOK := true
        stepChannelShortOK := true
else
    // Step Channel disabled - allow both directions
    stepChannelLongOK := true
    stepChannelShortOK := true

// --- Master Directional Permissions ---
allowLongs = stepChannelLongOK
allowShorts = stepChannelShortOK


// --------------------------------------------------------------------------------------------------
// SECTION: FINAL ENTRY SIGNAL GENERATION & EXECUTION (REFACTORED)
// KEYWORDS: Entry Signal, Final Check, Filter Application, Continuation, Strategy Execution
// --------------------------------------------------------------------------------------------------

// --- Step 1: Define Base Signal with Directional Filters ---
// This is the raw signal after applying the primary directional filters (e.g., Step Channel).
baseLongSignal = sigCountLong > 0 and allowLongs
baseShortSignal = sigCountShort > 0 and allowShorts

// --- Step 2: BASE LEVEL ENTRY LOGIC (SIMPLIFIED) ---
// Entry signals will be calculated after primaryLongSig is defined (around line 1130)
// Placeholder - actual calculation moved to proper location

// --- Step 3: Entry System Removed ---
// The old entry system has been removed to prevent conflicts with the advanced continuation system
// All entries now handled by the continuation system at lines 2110+

// --- Step 4: Reset Continuation State After Entry ---
// Once a continuation entry is successfully triggered, reset its state to wait for the next signal.
if longEntrySignal and continuationEnable and longContinuationActive
    longContinuationActive := false
    longContinuationLevel := na
    if continuationShowDebug
        debugMessage("CONTINUATION", "âœ… LONG CONTINUATION TRIGGERED: Entry confirmed", color.green, color.white, 0.1)

if shortEntrySignal and continuationEnable and shortContinuationActive
    shortContinuationActive := false
    shortContinuationLevel := na
    if continuationShowDebug
        debugMessage("CONTINUATION", "âœ… SHORT CONTINUATION TRIGGERED: Entry confirmed", color.red, color.white, 0.1)

// --- Simple Exit Logic ---
// Provides a basic mechanism to close all trades.
if (closePosition)
    strategy.close_all(comment='Close All Command')

// --------------------------------------------------------------------------------------------------
// SECTION: ADVANCED EXIT SYSTEM LOGIC
// KEYWORDS: Exit Calculations, Dynamic Stops, Trailing, Profit Protection
// --------------------------------------------------------------------------------------------------
// This block contains the calculations and execution logic for all advanced exit systems.

// --- Exit System Calculations ---
// Calculate the necessary indicators and values for the exit systems.
// (MA calculation moved to inputs section as priceMA)

// --- Position Tracking & Entry Price ---
// We need to know the entry price to calculate fixed SL/TP levels.
var float strategyEntryPrice = na
if (strategy.position_size > 0 and (bar_index == 0 or strategy.position_size[1] <= 0))
    strategyEntryPrice := strategy.opentrades.entry_price(strategy.opentrades - 1)
if (strategy.position_size < 0 and (bar_index == 0 or strategy.position_size[1] >= 0))
    strategyEntryPrice := strategy.opentrades.entry_price(strategy.opentrades - 1)

// --- MA Exit - Extract ta.* calls for Pine Script v6 consistency (MUST be called every bar) ---
longMAExit = ta.crossunder(close, priceMA)
shortMAExit = ta.crossover(close, priceMA)

// --- Fixed SL/TP & MA Exit Logic ---
if (strategy.position_size != 0)
    // Fixed SL/TP
    longStopPrice = strategyEntryPrice - (atrVal * fixedStop)
    longTp1Price = strategyEntryPrice + (atrVal * tp1Size)
    shortStopPrice = strategyEntryPrice + (atrVal * fixedStop)
    shortTp1Price = strategyEntryPrice - (atrVal * tp1Size)

    if (fixedEnable and tradeMode != "TREND")
        strategy.exit('Fixed SL/TP', from_entry='Long', stop=longStopPrice, limit=tp1Enable ? longTp1Price : na, qty_percent=tp1Enable ? tp1Size : 100)
        strategy.exit('Fixed SL/TP', from_entry='Short', stop=shortStopPrice, limit=tp1Enable ? shortTp1Price : na, qty_percent=tp1Enable ? tp1Size : 100)

    // MA Exit Logic (using pre-calculated cross signals) - SCALP MODE ONLY
    if (scalpMAExitOn and longMAExit and tradeMode != "TREND")
        strategy.close('Long', comment='MA Exit')
    if (scalpMAExitOn and shortMAExit and tradeMode != "TREND")
        strategy.close('Short', comment='MA Exit')

// â”€â”€â”€â”€â”€â”€â”€â”€ BROKEN SPL IMPLEMENTATION REMOVED â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// REMOVED: Manual SPL calculation approach (lines 619-651)
// REASON: Wrong methodology - used static stops instead of Pine's built-in trailing system
// REPLACED: With proper SPL implementation below using trail_points and trail_offset

// --- Optional: Debug Validation ---
// If debug mode is active, this will warn the user if a signal is enabled but not properly connected,
// preventing silent failures and making setup easier.
if debugEnabled and signal1Enable and not isValidSignalSource(signal1LongSrc)
    debugMessage("WARNING", "Signal 1 Long blocked: Source equals default price (close/open/high/low). Connect external indicator.", color.orange, color.white, 0.1)
if debugEnabled and signal1Enable and not isValidSignalSource(signal1ShortSrc)
    debugMessage("WARNING", "Signal 1 Short blocked: Source equals default price (close/open/high/low). Connect external indicator.", color.orange, color.white, 0.1)

// --------------------------------------------------------------------------------------------------
// SECTION: SIGNAL ARRAY MANAGEMENT
// KEYWORDS: Signal Array, Memory Management, Performance, Pine Script Array
// --------------------------------------------------------------------------------------------------
// To ensure high performance and prevent memory leaks, we use persistent arrays (`var`).
// These arrays are created only once on the first bar and their values are updated on subsequent bars.

// --- Step 2: Initialize Persistent Signal Arrays ---
var allLongSignals = array.new<bool>(10)
var allShortSignals = array.new<bool>(10)

// --- Step 3: Update Array Values ---
// The state of each processed signal (true or false) is efficiently set in the persistent arrays on every bar.
array.set(allLongSignals, 0, sig1Long)
array.set(allLongSignals, 1, sig2Long)
array.set(allLongSignals, 2, sig3Long)
array.set(allLongSignals, 3, sig4Long)
array.set(allLongSignals, 4, sig5Long)
array.set(allLongSignals, 5, sig6Long)
array.set(allLongSignals, 6, sig7Long)
array.set(allLongSignals, 7, sig8Long)
array.set(allLongSignals, 8, sig9Long)
array.set(allLongSignals, 9, sig10Long)

array.set(allShortSignals, 0, sig1Short)
array.set(allShortSignals, 1, sig2Short)
array.set(allShortSignals, 2, sig3Short)
array.set(allShortSignals, 3, sig4Short)
array.set(allShortSignals, 4, sig5Short)
array.set(allShortSignals, 5, sig6Short)
array.set(allShortSignals, 6, sig7Short)
array.set(allShortSignals, 7, sig8Short)
array.set(allShortSignals, 8, sig9Short)
array.set(allShortSignals, 9, sig10Short)

// --------------------------------------------------------------------------------------------------
// SECTION: CONFLUENCE COUNTING
// KEYWORDS: Signal Count, Confluence, Entry Condition
// --------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------
// SECTION: CONTINUATION ENTRY SYSTEM
// KEYWORDS: Continuation Entry, Price Confirmation, Intrabar Execution, Trade Entry Filter
// --------------------------------------------------------------------------------------------------
// This system acts as a filter, requiring price to move a specified distance after a signal appears
// before an entry is triggered. This helps confirm momentum and avoid false signals.

// --- Step 1: Calculate Continuation Distance ---
// Helper function to determine the required price movement based on the selected type.
calculateContinuationDistance() =>
    float distance = 0.0
    if continuationType == 'ATR'
        distance := continuationValue * atrVal // Distance based on Average True Range
    else if continuationType == 'Points'
        distance := continuationValue // Fixed distance in price points
    else if continuationType == 'Ticks'
        distance := continuationValue * syminfo.mintick // Fixed distance in minimum price increments (ticks)
    distance

// Get the currently configured continuation distance.
continuationDistance = continuationEnable ? calculateContinuationDistance() : 0.0

// --- Step 2: Define Raw Signal State ---
// A raw signal is considered active if at least one of the underlying indicators has fired.
// CRITICAL FIX: Use the correct signal count variables (sigCountLong/Short) that respect the 'Usage' settings.
baseLongSignalWithFilters = sigCountLong > 0 and allowLongs
baseShortSignalWithFilters = sigCountShort > 0 and allowShorts

// --- Step 3: Manage Continuation State ---
// This block handles the activation, cancellation, and timeout of continuation entries.
if continuationEnable
    // --- A) Activate Continuation on New Signal ---
    // When a new signal appears, set the price level that must be crossed (respects TV pyramiding settings).
    if baseLongSignalWithFilters and (bar_index == 0 or not baseLongSignalWithFilters[1]) and not longContinuationActive
        longContinuationLevel := close + continuationDistance // Set the target price for long entry
        longContinuationActive := true
        shortContinuationActive := false // Cancel any opposing continuation
        shortContinuationLevel := na
        continuationStartBar := bar_index
        continuationStartPrice := close
        if continuationShowDebug
            debugMessage("CONTINUATION", " LONG CONTINUATION SET: Level=" + str.tostring(longContinuationLevel) + " Distance=" + str.tostring(continuationDistance), color.blue, color.white, 0.1)
    
        else if baseShortSignalWithFilters and (bar_index == 0 or not baseShortSignalWithFilters[1]) and not shortContinuationActive
            shortContinuationLevel := close - continuationDistance // Set the target price for short entry
            shortContinuationActive := true
            longContinuationActive := false // Cancel any opposing continuation
            longContinuationLevel := na
            continuationStartBar := bar_index
            continuationStartPrice := close
            if continuationShowDebug
                debugMessage("CONTINUATION", " SHORT CONTINUATION SET: Level=" + str.tostring(shortContinuationLevel) + " Distance=" + str.tostring(continuationDistance), color.blue, color.white, 0.1)
    
    // --- C) Cancel Continuation on Timeout ---
    // If price fails to reach the continuation level within a set number of bars, cancel it.
    if continuationTimeoutBars > 0 and (longContinuationActive or shortContinuationActive) and bar_index > continuationStartBar + continuationTimeoutBars
        if longContinuationActive
            longContinuationActive := false
            longContinuationLevel := na
            if continuationShowDebug
                debugMessage("CONTINUATION", " LONG CONTINUATION TIMEOUT: Bar limit exceeded", color.orange, color.white, 0.1)
        if shortContinuationActive
            shortContinuationActive := false
            shortContinuationLevel := na
            if continuationShowDebug
                debugMessage("CONTINUATION", " SHORT CONTINUATION TIMEOUT: Bar limit exceeded", color.orange, color.white, 0.1)

// --------------------------------------------------------------------------------------------------
// SECTION: FINAL ENTRY SIGNAL GENERATION
// KEYWORDS: Entry Signal, Trade Trigger, Final Logic
// --------------------------------------------------------------------------------------------------
// --- Step 4: Determine Final Entry Signal ---


// --------------------------------------------------------------------------------------------------
// SECTION: CONTINUATION ENTRY DEBUG VISUALIZATION
// KEYWORDS: Debug Plot, Visualization, Charting, Plotshape, Bgcolor, Label
// --------------------------------------------------------------------------------------------------
// This section provides a rich visual debugging experience for the continuation entry system.

// A master boolean to control the visibility of all debug visuals in this section.
showContinuationDebug = continuationEnable and continuationShowDebug

// --- A) Plot Continuation Price Levels ---
// Draws a horizontal line at the exact price where an entry will be triggered. The plot only appears if debugging is active.
plot(showContinuationDebug and longContinuationActive ? longContinuationLevel : na, "Long Continuation Level", color=color.new(color.green, 50), style=plot.style_linebr, linewidth=2)
plot(showContinuationDebug and shortContinuationActive ? shortContinuationLevel : na, "Short Continuation Level", color=color.new(color.red, 50), style=plot.style_linebr, linewidth=2)

// --- B) Highlight Active Continuation State ---
// Changes the chart's background color to indicate that the system is actively waiting for a price confirmation.
bgColor = showContinuationDebug and longContinuationActive ? color.new(color.green, 95) : showContinuationDebug and shortContinuationActive ? color.new(color.red, 95) : na
bgcolor(bgColor, title="Continuation Active")
    
// --- C) Display Detailed Status Label on the Last Bar ---
// For real-time monitoring, this creates a detailed label on the most recent bar summarizing the active continuation state.
// Extract ta.highest for Pine Script v6 consistency (must be called every bar)
labelHighPoint = ta.highest(high, 20)

if barstate.islast and (longContinuationActive or shortContinuationActive)
    // Prepare the text content for the label.
    continuationStatus = longContinuationActive ?         "ğŸ¯ LONG CONTINUATION\nLevel: " + str.tostring(longContinuationLevel, '#.#####') + "\nDistance: " + str.tostring(continuationDistance) + " (" + continuationType + ")" :        "ğŸ¯ SHORT CONTINUATION\nLevel: " + str.tostring(shortContinuationLevel, '#.#####') + "\nDistance: " + str.tostring(continuationDistance) + " (" + continuationType + ")"
    
    // Create the label on the chart using pre-calculated high point
    label.new(bar_index, labelHighPoint, continuationStatus, 
      color=longContinuationActive ? color.new(color.green, 20) : color.new(color.red, 20), 
      textcolor=color.white, style=label.style_label_down, yloc=yloc.price, size=size.normal)

// --------------------------------------------------------------------------------------------------
// SECTION: RBW FILTER DEPENDENCY
// KEYWORDS: Import, Library, Dependency, RBW Filter
// --------------------------------------------------------------------------------------------------
// This line imports an external library named 'enhanced_ta'. This library is required for the 
// 'RBW Filter' (Range & Bar-type Width Filter), which is a directional bias filter used later in the script.
import HeWhoMustNotBeNamed/enhanced_ta/14 as eta

// --------------------------------------------------------------------------------------------------
// SECTION: HELPER FUNCTION - BUILD SIGNAL NAME
// KEYWORDS: Helper Function, Debugging, Signal Name, String Concatenation
// --------------------------------------------------------------------------------------------------
// This utility function constructs a string that lists the names of all active signals for a given
// trade direction (long or short). The resulting string (e.g., "S1+S3+S5") is used for chart labels.
// @param isLong (bool) - If true, builds the name for long signals; otherwise, for short signals.
// @return (string) A '+' separated string of active signal names.
buildSignalName(bool isLong) =>
    string names = "" // Initialize an empty string to store the names.
    
    // Check if we are building for long or short signals.
    if isLong
        // Iterate through all 10 long signals.
        if sig1Long
            names := names + (names == "" ? "" : "+") + signal1Name // Append the name, adding a '+' if it's not the first one.
        if sig2Long
            names := names + (names == "" ? "" : "+") + signal2Name
        if sig3Long
            names := names + (names == "" ? "" : "+") + signal3Name
        if sig4Long
            names := names + (names == "" ? "" : "+") + signal4Name
        if sig5Long
            names := names + (names == "" ? "" : "+") + signal5Name
        if sig6Long
            names := names + (names == "" ? "" : "+") + signal6Name
        if sig7Long
            names := names + (names == "" ? "" : "+") + signal7Name
        if sig8Long
            names := names + (names == "" ? "" : "+") + signal8Name
        if sig9Long
            names := names + (names == "" ? "" : "+") + signal9Name
        if sig10Long
            names := names + (names == "" ? "" : "+") + signal10Name
    else
        // Iterate through all 10 short signals.
        if sig1Short
            names := names + (names == "" ? "" : "+") + signal1Name
        if sig2Short
            names := names + (names == "" ? "" : "+") + signal2Name
        if sig3Short
            names := names + (names == "" ? "" : "+") + signal3Name
        if sig4Short
            names := names + (names == "" ? "" : "+") + signal4Name
        if sig5Short
            names := names + (names == "" ? "" : "+") + signal5Name
        if sig6Short
            names := names + (names == "" ? "" : "+") + signal6Name
        if sig7Short
            names := names + (names == "" ? "" : "+") + signal7Name
        if sig8Short
            names := names + (names == "" ? "" : "+") + signal8Name
        if sig9Short
            names := names + (names == "" ? "" : "+") + signal9Name
        if sig10Short
            names := names + (names == "" ? "" : "+") + signal10Name
    
    // Return the final concatenated string.
    names

// --- Call the helper function to generate the signal name strings for the current bar ---
longSignalName = buildSignalName(true) // Generate the signal name for long signals.
shortSignalName = buildSignalName(false) // Generate the signal name for short signals.

// --------------------------------------------------------------------------------------------------
// SECTION: LEGACY SIGNAL PROCESSING SETUP
// KEYWORDS: Legacy, Backward Compatibility, Signal Aggregation
// --------------------------------------------------------------------------------------------------
// These variables are maintained for backward compatibility with older or simpler parts of the strategy
// that may not use the full multi-signal confluence system. They provide a single boolean value
// indicating if ANY long or short signal is active.
primaryLongSig = sig1Long or sig2Long or sig3Long or sig4Long or sig5Long or sig6Long or sig7Long or sig8Long or sig9Long or sig10Long
primaryShortSig = sig1Short or sig2Short or sig3Short or sig4Short or sig5Short or sig6Short or sig7Short or sig8Short or sig9Short or sig10Short



// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1 Â· TRADERSPOST JSON HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€ Pre-built JSON messages (compile-time constants) â”€â”€â”€â”€â”€
// Use TradingView alert placeholders so we avoid any per-bar string operations.
// Placeholders {{close}} and {{timenow}} will be expanded at alert trigger time.
var string _jsonBase = '{"ticker":"' + syminfo.ticker + '","price":{{close}},"time":{{timenow}}'

var string longEntryMsg = _jsonBase + ',"action":"buy","sentiment":"long"}'
var string shortEntryMsg = _jsonBase + ',"action":"sell","sentiment":"short"}'
var string flatExitMsg = _jsonBase + ',"action":"exit","sentiment":"flat"}'
var string longExitMsg = _jsonBase + ',"action":"sell","sentiment":"flat"}' // closes long
var string shortExitMsg = _jsonBase + ',"action":"buy","sentiment":"flat"}' // closes short

// â”€â”€â”€â”€â”€ Volatility Ratio (global) for adaptive stop & debug â”€â”€â”€â”€â”€
// Re-computed every bar (not a "var") so downstream logic can read it.
smaAtr = ta.sma(atrVal, 50)
volatilityRatio = smaAtr > 1e-10 ? atrVal / smaAtr : 1.0




// Initialize debug logging on first bar
if barstate.isfirst
    debugMessage("INIT", "EZAlgoTrader initialized with debug logging", color.blue, color.white, 0.1)


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HELPER CALCULATIONS FOR EXITS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Re-create helpers that were removed with the legacy input block.

// --- Distance Calculator for Fixed SL/TP ---
tpCalc(d) =>
    d * atrVal  // Always use ATR as per BackTester.pine


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• REAL STRATEGY EXIT LOGIC (CRITICAL FIX) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Track entry price for distance-based exits

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• POSITION TRACKING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Position state management

// Position tracking and flag reset logic
if strategy.position_size == 0
    strategyEntryPrice := na
else if strategy.position_size != 0 and na(strategyEntryPrice)
    strategyEntryPrice := strategy.position_avg_price

// Reset all exit flags on new position entry
currentPosition = strategy.position_size != 0
if currentPosition and not inPosition
    // New trade detected - reset all flags
    maExitSent := false
    fixedExitSent := false
    fibExitSent := false
    trailExitSent := false
    customExitSent := false
    exitInProgress := false
    inPosition := true
else if not currentPosition and inPosition
    // Trade closed - update state
    inPosition := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SMART PROFIT LOCKER CALCULATION (FROM BackTester.pine) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Calculate Smart Profit Locker distance and offset for SCALP mode
if (tradeMode == "SCALP" or tradeMode == "HYBRID") and smartProfitEnable and strategy.position_size != 0
    // Calculate Smart Profit Locker distance and offset
    smartDistance := smartProfitType == 'ATR' ? smartProfitVal * atrVal : smartProfitType == 'Points' ? smartProfitVal : strategy.position_avg_price * smartProfitVal / 100.0
    
    // Standard offset calculation
    smartOffset := smartDistance * math.max(smartProfitOffset, 0.01)
    
    // Ensure distances are valid
    if na(smartDistance) or smartDistance <= 0
        smartDistance := 50.0  // Safe default value in points
    if na(smartOffset) or smartOffset <= 0
        smartOffset := 5.0  // Safe default offset

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COORDINATED EXIT SYSTEM (FROM BackTester.pine) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// This implements the proper exit hierarchy with state tracking to prevent conflicts

// 1. Smart Profit Locker (Primary for Scalp Mode)
if smartProfitEnable and strategy.position_size != 0 and not trailExitSent and tradeMode != "TREND"
    if strategy.position_size > 0
        strategy.exit("SPL-Long", "Long", trail_points=smartDistance, trail_offset=smartOffset)
        trailExitSent := true
        if debugEnabled
            debugMessage("SPL", "ğŸ¯ SPL-Long activated - Distance: " + str.tostring(smartDistance, "#.##"), color.green, color.white, 0.1)
    else if strategy.position_size < 0
        strategy.exit("SPL-Short", "Short", trail_points=smartDistance, trail_offset=smartOffset)
        trailExitSent := true
        if debugEnabled
            debugMessage("SPL", "ğŸ¯ SPL-Short activated - Distance: " + str.tostring(smartDistance, "#.##"), color.red, color.white, 0.1)

// 2. Fixed SL/TP (Safety Net)
if fixedEnable and strategy.position_size != 0 and not fixedExitSent
    stopLevel = strategy.position_size > 0 ? strategyEntryPrice - (fixedStop * atrVal) : strategyEntryPrice + (fixedStop * atrVal)
    
    profitLevel = tp1Enable ? 
                  (strategy.position_size > 0 ? 
                   strategyEntryPrice + (tp1Size * atrVal) : 
                   strategyEntryPrice - (tp1Size * atrVal)) : na
    
    strategy.exit("Fixed", strategy.position_size > 0 ? "Long" : "Short", 
                  stop=stopLevel, limit=profitLevel)
    fixedExitSent := true
    if debugEnabled
        debugMessage("FIXED", "ğŸ›¡ï¸ Fixed SL/TP set - Stop: " + str.tostring(stopLevel, "#.##"), color.blue, color.white, 0.1)

// 3. MA Exit (Trend Filter)
if scalpMAExitOn and strategy.position_size != 0 and not maExitSent
    exitCondition = (strategy.position_size > 0 and close < priceMA) or (strategy.position_size < 0 and close > priceMA)
    
    if exitCondition
        strategy.close_all("MA Exit", alert_message=flatExitMsg)
        maExitSent := true
        entryAllowed := true
        if debugEnabled
            debugMessage("MA_EXIT", "ğŸ“ˆ MA Exit triggered - Price crossed MA", color.purple, color.white, 0.1)



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND INDICATOR SECTION (DATA INPUT HUB) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Data Input, External Indicators, Plot Connection, Modularity
// This section is the primary data-inlet for the strategy. Instead of performing heavy calculations
// internally, it is designed to connect to the plot outputs of external, standalone indicators.
// This modular design makes the strategy highly flexible and adaptable, allowing users to easily
// swap different trend-following algorithms without altering the core trading logic.
// NOTE: A few specific indicators, like the MA Crossover for exits, remain internally calculated for
// specific functional requirements or legacy compatibility.

// â”€â”€â”€â”€â”€â”€â”€â”€ TREND STRENGTH (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Trend Strength" indicator.
// This indicator typically identifies strong directional moves, and its signals are used as a potential
// entry trigger or as a vote in the directional bias system.
trendStrengthEnable = input.bool(false, 'ğŸ’ª Trend Strength', group='ğŸ“ˆ Trend Indicators', inline='ts1')
trendStrengthLongSrc = input.source(close, 'Long', group='ğŸ“ˆ Trend Indicators', inline='ts1', tooltip='Connect to Trend Strength Long signal plot')
trendStrengthShortSrc = input.source(close, 'Short', group='ğŸ“ˆ Trend Indicators', inline='ts1', tooltip='Connect to Trend Strength Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ HULL SUITE (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Hull Suite" moving average indicator.
// The Hull Moving Average is known for its smoothness and reduced lag. Its bullish/bearish state
// is a primary component of the directional bias system.
hullEnable = input.bool(true, 'ğŸŒŠ Hull Suite', group='ğŸ“ˆ Trend Indicators', inline='hull1')
hullTrendExit = input.bool(true, 'Use for Trend Exit', group='ğŸ“ˆ Trend Indicators', inline='hull1')
hullLongSrc = input.source(close, 'Long', group='ğŸ“ˆ Trend Indicators', inline='hull1', tooltip='Connect to Hull Suite Long signal plot')
hullShortSrc = input.source(close, 'Short', group='ğŸ“ˆ Trend Indicators', inline='hull1', tooltip='Connect to Hull Suite Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ QUADRANT NW (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Quadrant NW" indicator, which often analyzes price action
// relative to key levels or zones. Its state contributes to the overall directional bias.
quadrantEnable = input.bool(false, 'ğŸ“Š Quadrant NW', group='ğŸ“ˆ Trend Indicators', inline='quad1')
quadrantLongSrc = input.source(close, 'Long', group='ğŸ“ˆ Trend Indicators', inline='quad1', tooltip='Connect to Quadrant NW Long signal plot')
quadrantShortSrc = input.source(close, 'Short', group='ğŸ“ˆ Trend Indicators', inline='quad1', tooltip='Connect to Quadrant NW Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ ADAPTIVE SUPERTREND (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Adaptive SuperTrend" indicator.
// This is a key trend-following component, providing signals for both entries and contributing
// its trend direction to the bias system.
adaptiveSTEnable = input.bool(true, 'ğŸ¤– Adaptive ST', group='ğŸ“ˆ Trend Indicators', inline='ast1')
adaptiveLongSrc = input.source(close, 'Long', group='ğŸ“ˆ Trend Indicators', inline='ast1', tooltip='Connect to Adaptive SuperTrend Long signal plot')
adaptiveShortSrc = input.source(close, 'Short', group='ğŸ“ˆ Trend Indicators', inline='ast1', tooltip='Connect to Adaptive SuperTrend Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ VOLUMATIC VIDYA (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Volumatic VIDYA" (Variable Index Dynamic Average) indicator.
// This is a volume-weighted moving average, providing a trend direction that is sensitive to market participation.
volumaticEnable = input.bool(false, 'ğŸ“Š Volumatic', group='ğŸ“ˆ Trend Indicators', inline='vol1')
volumaticLongSrc = input.source(close, 'Long', group='ğŸ“ˆ Trend Indicators', inline='vol1', tooltip='Connect to Volumatic VIDYA Long signal plot')
volumaticShortSrc = input.source(close, 'Short', group='ğŸ“ˆ Trend Indicators', inline='vol1', tooltip='Connect to Volumatic VIDYA Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ SMOOTH HEIKEN ASHI (EXTERNAL PLOT POINTS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Connects to an external "Smooth Heiken Ashi" indicator.
// Heiken Ashi candles are excellent for visualizing trend direction, and their state is used here
// as another vote for the overall directional bias.
smoothHAEnable = input.bool(false, 'ğŸ•¯ï¸ Smooth HA', group='ğŸ“ˆ Trend Indicators', inline='sha1')
smoothHALongSrc = input.source(close, 'Long', group='ğŸ“ˆ Trend Indicators', inline='sha1', tooltip='Connect to Smooth Heiken Ashi Long signal plot')
smoothHAShortSrc = input.source(close, 'Short', group='ğŸ“ˆ Trend Indicators', inline='sha1', tooltip='Connect to Smooth Heiken Ashi Short signal plot')

// â”€â”€â”€â”€â”€â”€â”€â”€ STEP CHANNEL (INTERNAL CALCULATION - PROTECTED) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CRITICAL: This calculation must remain internal and unchanged
// Note: Step Channel enable toggle and controls are in Step Channel Scalp Zone section



// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INDEPENDENT MODE SELECTION COMPONENTS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Mode Selection, Regime Filter, Scalp Mode, Trend Mode, Step Channel, CVD
// This is one of the most advanced features of the strategy. It intelligently analyzes market
// structure and institutional flow to automatically switch between a fast, aggressive 'Scalp Mode'
// and a patient, profit-maximizing 'Trend Mode'.
//
// It uses two independent components that work well together:
// 1. Step Channel Component: A structural filter that identifies the underlying market regime (trending or ranging).
// 2. CVD Component: An institutional confirmation filter that looks for significant volume delta
//    to validate the trend, preventing false breakouts.

// â”€â”€â”€â”€â”€â”€â”€â”€ STEP CHANNEL COMPONENT SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// These inputs control the sensitivity and visual appearance of the Step Channel, which is the
// primary filter for identifying the market's structural regime and switching exit modes:
// ğŸŸ¡ YELLOW candles (Range) = SCALP MODE â†’ Smart Profit Locker, MA Exit, Fixed SL/TP ACTIVE
// ğŸ”´ RED candles (Momentum Down) = TREND MODE â†’ Trend exits ACTIVE, SPL/MA/Fixed DISABLED  
// ğŸŸ¢ GREEN candles (Momentum Up) = TREND MODE â†’ Trend exits ACTIVE, SPL/MA/Fixed DISABLED
stepChannelLength = input.int(3, "Step Channel Length", minval=1, maxval=50, group="ğŸ¯ Step Channel Scalp Zone", inline="sc1", tooltip="Controls sensitivity - lower = more sensitive")
stepChannelMultiplier = input.float(1.0, "Multiplier", minval=0.1, maxval=5.0, step=0.1, group="ğŸ¯ Step Channel Scalp Zone", inline="sc1", tooltip="Channel width multiplier")

// Step Channel Visual Settings (matching original StepChannel.pine exactly)
stepChannelShowVisuals = input.bool(true, "Show Step Channel Visuals", group="ğŸ¯ Step Channel Scalp Zone", tooltip="Enable/disable all Step Channel visualizations")
stepChannelColorUp = input.color(color.rgb(26, 190, 127), "Momentum Up", inline="SC Colors", group="ğŸ¯ Step Channel Scalp Zone")
stepChannelColorRange = input.color(color.orange, "Range", inline="SC Colors", group="ğŸ¯ Step Channel Scalp Zone")
stepChannelColorDown = input.color(color.rgb(202, 38, 65), "Momentum Down", inline="SC Colors", group="ğŸ¯ Step Channel Scalp Zone")
stepChannelShowPivots = input.bool(true, "Show Pivot Points", group="ğŸ¯ Step Channel Scalp Zone")
stepChannelShowCandles = input.bool(true, "Show Momentum Candles", group="ğŸ¯ Step Channel Scalp Zone")
stepChannelShowLines = input.bool(true, "Show Channel Lines", group="ğŸ¯ Step Channel Scalp Zone")
stepChannelShowLabel = input.bool(true, "Show Market State Label", group="ğŸ¯ Step Channel Scalp Zone")
resumeScalpExitsImmediately = input.bool(true, "Resume Scalp Exits on Mode Switch", group="ğŸ¯ Step Channel Scalp Zone",     tooltip="When switching back from TREND to SCALP mode:\nâ€¢ TRUE: Resume scalp exits (SPL/MA/Fixed) immediately\nâ€¢ FALSE: Wait for trend exit to complete first (more conservative)")

// â”€â”€â”€â”€â”€â”€â”€â”€ CVD COMPONENT: CUMULATIVE VOLUME DELTA FILTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PHASE 3: CVD has NO DIRECTIONAL BIAS - it only determines Trend vs Scalp mode
// These inputs configure the institutional confirmation component. The CVD filter analyzes volume flow
// magnitude (not direction) to confirm whether sufficient institutional activity exists for trend mode.
// High |volume delta| = Trend Mode, Low |volume delta| = Scalp Mode
cvdEnable = input.bool(true, 'ğŸ“ˆ CVD Filter', group='ğŸ“Š Cumulative Volume Delta Filter', tooltip='Enable CVD institutional flow confirmation for trend/scalp mode detection (NO directional bias)')
cvdValueSrc = input.source(close, 'CVD Value', group='ğŸ“Š Cumulative Volume Delta Filter', inline='cvd1', tooltip='Connect to "CVD Strategy Export: CVD Value" - for display only')
cvdTrendSrc = input.source(close, 'CVD Trend Signal', group='ğŸ“Š Cumulative Volume Delta Filter', inline='cvd1', tooltip='Connect to "CVD Strategy Export: Trend Mode Signal" - NON-DIRECTIONAL mode detection only')

// â”€â”€â”€â”€â”€â”€â”€â”€ TREND MODE MASTER CONTROL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PHASE 1: Master switch to enable/disable the entire trend mode system
trendModeEnable = input.bool(true, 'ğŸ¯ Enable Trend Mode System', group='ğŸ“Š Cumulative Volume Delta Filter', tooltip='MASTER SWITCH: Enable/disable entire trend mode system. When OFF, strategy uses scalp mode only.')

// â”€â”€â”€â”€â”€â”€â”€â”€ MODE SELECTION DEBUG & OVERRIDE SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// These settings provide manual control for testing and debugging the mode-switching logic.
scalpOnlyOverride = input.bool(false, 'Force Scalp Mode', group='ğŸ“Š Cumulative Volume Delta Filter', tooltip='Override all filters and force scalp-only mode for testing')
trendModeDebug = input.bool(false, 'Show Debug Info', group='ğŸ“Š Cumulative Volume Delta Filter', tooltip='Display mode selection debug information')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INDEPENDENT MODE SELECTION CALCULATIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Calculation, Regime Detection, Step Channel Logic, CVD Logic
// This section contains the core calculation engine for the mode-switching system. It takes the user's
// configuration settings from the previous section and applies them to determine, on a bar-by-bar
// basis, whether the strategy should be in 'Scalp Mode' or 'Trend Mode'.

// â”€â”€â”€â”€â”€â”€â”€â”€ STEP CHANNEL COMPONENT: MOMENTUM CALCULATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This block is a full, self-contained implementation of the ChartPrime Step Channel Momentum indicator.
// It analyzes price action to determine market structure and automatically switches exit modes:
// ğŸŸ¡ YELLOW candles (Range) = SCALP MODE â†’ Smart Profit Locker, MA Exit, Fixed SL/TP ACTIVE
// ğŸ”´ RED candles (Momentum Down) = TREND MODE â†’ Trend exits ACTIVE, SPL/MA/Fixed DISABLED  
// ğŸŸ¢ GREEN candles (Momentum Up) = TREND MODE â†’ Trend exits ACTIVE, SPL/MA/Fixed DISABLED

// --- State Management Variables ---
// `var` is used to ensure these variables maintain their values across bar calculations.
var string stepChannelState = "Range"       // Holds the current market state text (e.g., "Momentum Up").
var bool stepChannelTrendMode = false   // The final output: `true` if an uptrend is detected.
var float stepChannelPivotHigh = na      // Stores the most recent significant high pivot.
var float stepChannelPivotLow = na       // Stores the most recent significant low pivot.
var color stepChannelCurrentColor = color.orange // Stores the color for the visual elements.

// --- Channel Calculation Variables ---
var float stepChannelAvg = na            // The midpoint of the channel.
var float stepChannelATR = na            // The calculated ATR value used for channel width.

if stepChannelEnable
    // --- Step 1: Identify Significant Pivots ---
    // `ta.pivothigh` and `ta.pivotlow` are used to find recent swing points in the price.
    ph = ta.pivothigh(stepChannelLength, stepChannelLength)
    pl = ta.pivotlow(stepChannelLength, stepChannelLength)
    
    // When a new pivot is found, its value is stored in the corresponding `var` variable.
    if not na(ph)
        stepChannelPivotHigh := ph
        if stepChannelShowPivots and stepChannelShowVisuals
            label.new(math.max(bar_index-stepChannelLength, 0), ph, "â¬¥", style=label.style_label_center, textcolor=chart.fg_color, size=size.normal, color=color(na))
    if not na(pl)
        stepChannelPivotLow := pl
        if stepChannelShowPivots and stepChannelShowVisuals
            label.new(math.max(bar_index-stepChannelLength, 0), pl, "â¬¥", style=label.style_label_center, textcolor=chart.fg_color, size=size.normal, color=color(na))
    
    // --- Step 2: Calculate Channel Boundaries ---
    // The channel width is based on a 200-period ATR, adjusted by a user-defined multiplier.
    stepChannelATR := ta.atr(200) * stepChannelMultiplier
    
    // This handles the script's initialization phase. Before both a high and low pivot are found,
    // it uses a temporary channel centered on the current price.
    if na(stepChannelPivotHigh) or na(stepChannelPivotLow)
        stepChannelAvg := hl2
        stepChannelUpper := stepChannelAvg + stepChannelATR
        stepChannelLower := stepChannelAvg - stepChannelATR
    else
        // Once pivots are established, the channel is centered between them.
        stepChannelAvg := math.avg(stepChannelPivotHigh, stepChannelPivotLow)
        stepChannelUpper := stepChannelAvg + stepChannelATR
        stepChannelLower := stepChannelAvg - stepChannelATR
    
    // --- Step 3: Determine Final Market State & Exit Mode ---
    // STEP CHANNEL CANDLE COLOR â†’ EXIT MODE MAPPING:
    // ğŸŸ¡ YELLOW (Range) = SCALP MODE â†’ Smart Profit Locker, MA Exit, Fixed SL/TP ACTIVE
    // ğŸ”´ RED (Momentum Down) = TREND MODE â†’ Trend exits ACTIVE, SPL/MA/Fixed DISABLED  
    // ğŸŸ¢ GREEN (Momentum Up) = TREND MODE â†’ Trend exits ACTIVE, SPL/MA/Fixed DISABLED
    //
    // The current price (`hl2`) is compared to the channel boundaries to set the final state.
    if hl2 > stepChannelUpper
        stepChannelCurrentColor := stepChannelColorUp
        stepChannelTrendMode := true // ğŸŸ¢ GREEN candles = TREND MODE - use trend exits, SPL/MA/Fixed DISABLED
        stepChannelState := "Momentum Up"
    else if hl2 < stepChannelLower
        stepChannelCurrentColor := stepChannelColorDown
        stepChannelTrendMode := true // ğŸ”´ RED candles = TREND MODE - use trend exits, SPL/MA/Fixed DISABLED
        stepChannelState := "Momentum Down"
    else // Price is inside the channel.
        stepChannelCurrentColor := stepChannelColorRange
        stepChannelTrendMode := false // ğŸŸ¡ YELLOW candles = SCALP MODE - SPL/MA/Fixed exits ACTIVE
        stepChannelState := "Range"
    
    // Note: The actual plotting of visual elements is handled in the global scope to prevent script errors.
else
    // If the Step Channel filter is disabled, it defaults to a non-blocking state.
    stepChannelState := "Disabled"
    stepChannelTrendMode := true  // This effectively bypasses the filter, allowing Trend Mode.

// â”€â”€â”€â”€â”€â”€â”€â”€ CVD COMPONENT: TREND/SCALP MODE FILTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PHASE 3: CVD has NO DIRECTIONAL BIAS - it only determines Trend vs Scalp mode
// This block reads Cumulative Volume Delta (CVD) from an external indicator to act as an
// institutional confirmation filter for trend mode. High volume delta = trend mode, low = scalp mode.

// --- State Management Variables ---
var bool cvdTrendMode = false   // The final output: `true` if institutional flow confirms a trend.
var float cvdValue = na         // Stores the calculated CVD value for potential display or debugging.

// --- CVD Data from External Indicator ---
// PHASE 3: Read CVD data from the connected "CVD Strategy Export" indicator's plot points
if cvdEnable
    // Get CVD value and trend signal from the external indicator
    cvdValue := cvdValueSrc
    // PHASE 3: The trend signal is NON-DIRECTIONAL (1 = trend allowed, 0 = scalp only)
    // This signal is based on |volume delta| > threshold, NOT direction
    cvdTrendMode := cvdTrendSrc > 0.5  // Convert to boolean (handles any minor floating point issues)
else
    // If the CVD filter is disabled, it defaults to a non-blocking state.
    cvdTrendMode := true  // This effectively bypasses the filter, allowing Trend Mode.
    cvdValue := 0

// â”€â”€â”€â”€â”€â”€â”€â”€ INDEPENDENT COMPONENT COMBINATION LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This is the final decision-making block. It combines the results from the Step Channel Component
// and the CVD Component to set the strategy's operational mode.

// --- State Management Variables ---
var bool scalpOnlyMode = true             // `true` if the strategy should use fast, scalping exits.
var bool trendFollowingMode = false       // `true` if the strategy should use trend-following logic.
var string currentTradingMode = "SCALP"   // A text label for the current mode, used in visuals and debug logs.

// --- Manual Override for Testing ---
// Allows the user to force the strategy into Scalp Mode, bypassing the filter logic.
if scalpOnlyOverride
    scalpOnlyMode := true
    trendFollowingMode := false
    currentTradingMode := "SCALP (FORCED)"
else
    // --- PHASE 1: Master Control Logic ---
    // The master switch overrides everything - if trend mode is disabled, force scalp mode
    if not trendModeEnable
        scalpOnlyMode := true
        trendFollowingMode := false
        currentTradingMode := "SCALP (MASTER OFF)"
    else
        // --- Confluence Logic for Trend Mode ---
        // Trend Mode is only activated if ALL enabled filters agree.
        // If a filter is disabled, it defaults to `true`, effectively giving its permission for Trend Mode.
        stepChannelAllows = stepChannelEnable ? stepChannelTrendMode : true
        cvdAllows = cvdEnable ? cvdTrendMode : true
        
        // PHASE 1: Create finalTrendModeActive combining all components
        finalTrendModeActive = trendModeEnable and stepChannelAllows and cvdAllows
        
        // Both must be `true` for trend following to be active.
        trendFollowingMode := finalTrendModeActive
        
        // --- Set Final Mode ---
        // Scalp mode is simply the inverse of trend mode.
        scalpOnlyMode := not trendFollowingMode
        currentTradingMode := trendFollowingMode ? "TREND" : "SCALP"
    
    // Connect to SPL system tradeMode variable
    tradeMode := currentTradingMode

// â”€â”€â”€â”€â”€â”€â”€â”€ MODE SELECTION DEBUG AND VISUALIZATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This section handles the optional visual elements for the mode selection system, providing real-time
// feedback directly on the chart.

// --- On-Chart Debug Table ---
// If enabled, this table provides a detailed, real-time breakdown of the mode selection logic.
// Duplicate debug table removed - debug table already exists elsewhere

// --- PHASE 1: Trend Mode Master Control Panel ---
// Displays comprehensive master control information
if trendModeDebug and barstate.islast
    // Create master control panel table
    var table masterControlTable = table.new(position.top_right, 2, 7, bgcolor=color.new(color.white, 80), border_width=1)
    
    if barstate.islast
        // Header
        table.cell(masterControlTable, 0, 0, "TREND MODE MASTER CONTROL", text_color=color.white, bgcolor=color.new(color.blue, 0), text_size=size.normal)
        table.cell(masterControlTable, 1, 0, "", bgcolor=color.new(color.blue, 0))
        
        // Master Switch Status
        masterSwitchColor = trendModeEnable ? color.new(color.green, 0) : color.new(color.red, 0)
        table.cell(masterControlTable, 0, 1, "Master Switch:", text_color=color.black, text_size=size.normal)
        table.cell(masterControlTable, 1, 1, trendModeEnable ? "âœ… ON" : "âŒ OFF", text_color=color.white, bgcolor=masterSwitchColor, text_size=size.normal)
        
        // Current Trading Mode
        currentModeColor = trendFollowingMode ? color.new(color.orange, 0) : color.new(color.blue, 0)
        table.cell(masterControlTable, 0, 2, "Current Mode:", text_color=color.black, text_size=size.normal)
        table.cell(masterControlTable, 1, 2, currentTradingMode, text_color=color.white, bgcolor=currentModeColor, text_size=size.normal)
        
        // Mode Detection Inputs
        table.cell(masterControlTable, 0, 3, "Step Channel:", text_color=color.black, text_size=size.small)
        stepChannelColor = stepChannelTrendMode ? color.new(color.green, 0) : color.new(color.red, 0)
        stepChannelModeText = stepChannelEnable ? (stepChannelTrendMode ? "TREND âœ…" : "SCALP âŒ") : "DISABLED"
        stepChannelBiasText = stepChannelDirectionalBias ? " +BIAS" : ""
        stepChannelText = stepChannelModeText + stepChannelBiasText
        table.cell(masterControlTable, 1, 3, stepChannelText, text_color=color.white, bgcolor=stepChannelColor, text_size=size.small)
        
        table.cell(masterControlTable, 0, 4, "CVD Filter:", text_color=color.black, text_size=size.small)
        cvdColor = cvdTrendMode ? color.new(color.green, 0) : color.new(color.red, 0)
        cvdText = cvdEnable ? (cvdTrendMode ? "TREND âœ…" : "SCALP âŒ") : "DISABLED"
        table.cell(masterControlTable, 1, 4, cvdText, text_color=color.white, bgcolor=cvdColor, text_size=size.small)
        
        // Final Decision
        table.cell(masterControlTable, 0, 5, "Final Decision:", text_color=color.black, text_size=size.normal)
        finalDecisionText = trendFollowingMode ? "TREND MODE ACTIVE" : "SCALP MODE ACTIVE"
        table.cell(masterControlTable, 1, 5, finalDecisionText, text_color=color.white, bgcolor=currentModeColor, text_size=size.normal)
        
        // Exit Strategy
        table.cell(masterControlTable, 0, 6, "Exit Strategy:", text_color=color.black, text_size=size.small)
        exitStrategyText = trendFollowingMode ? "Bigger Targets, Trailing" : "Quick Profits, Tight Stops"
        table.cell(masterControlTable, 1, 6, exitStrategyText, text_color=color.white, bgcolor=currentModeColor, text_size=size.small)

// --- On-Chart Mode Label ---
// Displays a simple label on the chart showing the current trading mode.
if stepChannelShowLabel and barstate.islast
    label.new(bar_index, high, currentTradingMode, 
              color=trendFollowingMode ? color.new(color.orange, 0) : color.new(color.blue, 0), 
              textcolor=color.white, 
              style=label.style_label_down, 
              size=size.normal,
              tooltip="Current Trading Mode\nStep Channel: " + stepChannelState + "\nCVD: " + str.tostring(math.round(cvdValue)))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HULL SUITE (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Hull Suite trend detection via external plot points - internal calculation removed

var bool hullBullish = false

if hullEnable
    // Use external plot point signals instead of internal calculation
    // CRITICAL: Block signals from default price inputs (close/open/high/low)
    hullLongSignal = isValidSignalSource(hullLongSrc) and hullLongSrc > 0 and (bar_index == 0 or hullLongSrc != hullLongSrc[1])
    hullShortSignal = isValidSignalSource(hullShortSrc) and hullShortSrc > 0 and (bar_index == 0 or hullShortSrc != hullShortSrc[1])
    
    // Determine trend direction from external signals
    if hullLongSignal
        hullBullish := true
    else if hullShortSignal
        hullBullish := false
    // Otherwise maintain previous state
else
    // When disabled, set neutral (allow all trades)
    hullBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND STRENGTH (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Trend Strength trend detection via external plot points - internal calculation removed

var bool trendStrengthBullish = false

if trendStrengthEnable
    // Use external plot point signals instead of internal calculation
    // CRITICAL: Block signals from default price inputs (close/open/high/low)
    trendStrengthLongSignal = isValidSignalSource(trendStrengthLongSrc) and trendStrengthLongSrc > 0 and (bar_index == 0 or trendStrengthLongSrc != trendStrengthLongSrc[1])
    trendStrengthShortSignal = isValidSignalSource(trendStrengthShortSrc) and trendStrengthShortSrc > 0 and (bar_index == 0 or trendStrengthShortSrc != trendStrengthShortSrc[1])
    
    // Determine trend direction from external signals
    if trendStrengthLongSignal
        trendStrengthBullish := true
    else if trendStrengthShortSignal
        trendStrengthBullish := false
    // Otherwise maintain previous state
else
    // When disabled, set neutral (allow all trades)
    trendStrengthBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SUPERTREND (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SuperTrend trend detection via external plot points - internal calculation removed
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• QUADRANT NW (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Quadrant NW trend detection via external plot points - internal calculation removed
var bool quadrantBullish = false

if quadrantEnable
    // Use external plot point signals instead of internal calculation
    // CRITICAL: Block signals from default price inputs (close/open/high/low)
    quadrantLongSignal = isValidSignalSource(quadrantLongSrc) and quadrantLongSrc > 0 and (bar_index == 0 or quadrantLongSrc != quadrantLongSrc[1])
    quadrantShortSignal = isValidSignalSource(quadrantShortSrc) and quadrantShortSrc > 0 and (bar_index == 0 or quadrantShortSrc != quadrantShortSrc[1])
    
    // Determine trend direction from external signals
    if quadrantLongSignal
        quadrantBullish := true
    else if quadrantShortSignal
        quadrantBullish := false
    // Otherwise maintain previous state
else
    // When disabled, set neutral (allow all trades)
    quadrantBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADAPTIVE SUPERTREND (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Adaptive SuperTrend trend detection via external plot points - internal calculation removed

// Preserve existing interface variables for backward compatibility
var bool adaptiveSTBullish = false
var int adaptiveCluster = na
var int adaptiveNumber = na

if adaptiveSTEnable
    // Use external plot point signals for trend direction
    // CRITICAL: Block signals from default price inputs (close/open/high/low)
    adaptiveLongSignal = isValidSignalSource(adaptiveLongSrc) and adaptiveLongSrc > 0 and (bar_index == 0 or adaptiveLongSrc != adaptiveLongSrc[1])
    adaptiveShortSignal = isValidSignalSource(adaptiveShortSrc) and adaptiveShortSrc > 0 and (bar_index == 0 or adaptiveShortSrc != adaptiveShortSrc[1])
    
    // Get volatility regime number from external plot (for exit filter compatibility)
    adaptiveNumber := math.round(adaptiveRegimeInput)  // Get regime number (1, 2, or 3)
    // Validate the regime number is within expected range
    if not na(adaptiveNumber) and adaptiveNumber >= 1 and adaptiveNumber <= 3
        adaptiveCluster := adaptiveNumber == 3 ? 0 : (adaptiveNumber == 2 ? 1 : 2)  // Convert to cluster index
    else
        // Fallback to medium volatility if invalid input
        adaptiveNumber := 2
        adaptiveCluster := 1
    
    // Determine trend direction from external signals
    if adaptiveLongSignal
        adaptiveSTBullish := true
    else if adaptiveShortSignal
        adaptiveSTBullish := false
    // Otherwise maintain previous state
else
    // When disabled, set neutral (allow all trades)
    adaptiveSTBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADAPTIVE SUPERTREND EXIT FILTER SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Revolutionary exit filter using volatility classification numbers (1/2/3)
// Blocks scalp exits during specific volatility regimes for better trend riding

if adaptiveExitFilterEnable and adaptiveSTEnable
    // Determine if current volatility number should block exits
    currentlyBlocked = (adaptiveNumber == 3 and adaptiveHoldOn3) or 
                      (adaptiveNumber == 2 and adaptiveHoldOn2) or 
                      (adaptiveNumber == 1 and adaptiveHoldOn1)
    
    // Update exit blocking status
    adaptiveExitBlocked := currentlyBlocked
    
    // Handle pending exit logic with safety checks
    if adaptiveExitBlocked and (bar_index == 0 or not adaptiveExitBlocked[1])
        // Just entered blocked state - no action needed, just block new exits
        adaptivePendingExit := false
        adaptiveExitReason := na
    
    if not adaptiveExitBlocked and (bar_index > 0 and adaptiveExitBlocked[1])
        // Just exited blocked state - trigger any pending exits immediately
        if adaptivePendingExit
            // Exit will be triggered by normal exit logic since block is now lifted
            adaptivePendingExit := false
else
    // When filter is disabled, never block exits
    adaptiveExitBlocked := false
    adaptivePendingExit := false
    adaptiveExitReason := na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• VOLUMATIC VIDYA (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Volumatic VIDYA trend detection via external plot points - internal calculation removed

var bool volumaticBullish = false

if volumaticEnable
    // Use external plot point signals instead of internal calculation
    // CRITICAL: Block signals from default price inputs (close/open/high/low)
    volumaticLongSignal = isValidSignalSource(volumaticLongSrc) and volumaticLongSrc > 0 and (bar_index == 0 or volumaticLongSrc != volumaticLongSrc[1])
    volumaticShortSignal = isValidSignalSource(volumaticShortSrc) and volumaticShortSrc > 0 and (bar_index == 0 or volumaticShortSrc != volumaticShortSrc[1])
    
    // Determine trend direction from external signals
    if volumaticLongSignal
        volumaticBullish := true
    else if volumaticShortSignal
        volumaticBullish := false
    // Otherwise maintain previous state
else
    volumaticBullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SMOOTHED HEIKEN ASHI (EXTERNAL PLOT POINTS) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Smoothed Heiken Ashi trend detection via external plot points - internal calculation removed

var bool smoothHABullish = false

if smoothHAEnable
    // Use external plot point signals instead of internal calculation
    // CRITICAL: Block signals from default price inputs (close/open/high/low)
    smoothHALongSignal = isValidSignalSource(smoothHALongSrc) and smoothHALongSrc > 0 and (bar_index == 0 or smoothHALongSrc != smoothHALongSrc[1])
    smoothHAShortSignal = isValidSignalSource(smoothHAShortSrc) and smoothHAShortSrc > 0 and (bar_index == 0 or smoothHAShortSrc != smoothHAShortSrc[1])
    
    // Determine trend direction from external signals
    if smoothHALongSignal
        smoothHABullish := true
    else if smoothHAShortSignal
        smoothHABullish := false
    // Otherwise maintain previous state
else
    smoothHABullish := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DIRECTIONAL BIAS INTEGRATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Directional Bias, Trend Filter, Confluence, Signal Filtering
// This section translates the boolean state of each individual trend filter (e.g., `hullBullish`)
// into a standardized bias vote. If a filter is disabled, it defaults to `true`, effectively
// creating a bypass so it doesn't block trades. This prepares the votes for the final confluence logic.

// --- Individual Filter Bias Logic --- 
// Each filter's contribution to the overall directional bias is determined here.

// Individual filter bias logic removed - now handled directly in vote counting below

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND-EXIT/HOLD FILTER CALCULATIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Visually clear, mechanically simple filters to hold trades longer during obvious trends

// 1. ADAPTIVE SUPERTREND VOLATILITY FILTER
// KEYWORDS: Exit Filter, Trend Hold, Volatility, Adaptive SuperTrend
// This filter uses the volatility classification (1-Low, 2-Medium, 3-High) from the advanced
// Adaptive SuperTrend indicator to decide whether to hold a trade through minor pullbacks.
// By holding during specific volatility conditions, it aims to capture more of the primary trend.

// --- Step 1: Extract Volatility Number ---
// The raw volatility cluster (0, 1, or 2) from the external indicator is converted into a more intuitive number (3, 2, or 1).
var int adaptiveSTNumber = na
if adaptiveSTEnable
    // The formula `4 - (adaptiveCluster + 1)` maps the internal cluster index (0, 1, 2) to the user-facing volatility number (3, 2, 1).
    adaptiveSTNumber := not na(adaptiveCluster) ? (4 - (adaptiveCluster + 1)) : na
else
    // If the main indicator is disabled, the volatility number is not applicable.
    adaptiveSTNumber := na

// --- Step 2: Generate Hold Signal ---
// A 'hold' signal is generated if the user has opted to hold trades during the current volatility regime.
var bool adaptiveSTHoldSignal = false
if adaptiveExitFilterEnable and not na(adaptiveSTNumber)
    // The hold signal becomes active if the corresponding toggle (e.g., `adaptiveHoldOn3`) is enabled for the current volatility number.
    adaptiveSTHoldSignal := (adaptiveHoldOn3 and adaptiveSTNumber == 3) or 
                           (adaptiveHoldOn2 and adaptiveSTNumber == 2) or 
                           (adaptiveHoldOn1 and adaptiveSTNumber == 1)
else
    // If the exit filter is disabled or the volatility number is invalid, no hold signal is generated.
    adaptiveSTHoldSignal := false

// 2. MOVING AVERAGE CROSSOVER EXIT
// KEYWORDS: Exit Filter, Trend Hold, MA Cross, SMA, EMA, WMA
// This filter uses a classic moving average crossover strategy to identify the prevailing trend direction.
// When in a trade, it generates a 'hold' signal if the MAs indicate the trend is still intact,
// preventing premature exits and allowing the trade to ride the trend for longer.

// --- Step 1: Calculate Moving Averages ---
// These variables store the calculated MA values and the final hold signal.
var float maCrossoverFast = na
var float maCrossoverSlow = na
var bool maCrossoverHoldSignal = false

if trendMACrossoverExit
    // This block calculates the fast and slow MAs based on the user-selected type (SMA, EMA, or WMA) and length.
    maCrossoverFast := maCrossoverType == 'SMA' ? ta.sma(close, maCrossoverFastLength) :
                       maCrossoverType == 'EMA' ? ta.ema(close, maCrossoverFastLength) :
                       ta.wma(close, maCrossoverFastLength)
    
    // Calculate the slow MA using the same type and length as the fast MA.
    maCrossoverSlow := maCrossoverType == 'SMA' ? ta.sma(close, maCrossoverSlowLength) :
                       maCrossoverType == 'EMA' ? ta.ema(close, maCrossoverSlowLength) :
                       ta.wma(close, maCrossoverSlowLength)
    
    // --- Step 2: Generate Hold Signal based on Position ---
    // The hold logic is context-aware, generating a signal only if the MAs confirm the direction of the current trade.
    if strategy.position_size > 0  // In a long position
        // For a long trade, a hold signal is generated if the fast MA is above the slow MA (a "golden cross" condition).
        maCrossoverHoldSignal := maCrossoverFast > maCrossoverSlow
    else if strategy.position_size < 0  // In a short position
        // For a short trade, a hold signal is generated if the fast MA is below the slow MA (a "death cross" condition), confirming bearish momentum.
        maCrossoverHoldSignal := maCrossoverFast < maCrossoverSlow
    else
        // If there is no open position, a hold signal is irrelevant and is set to false.
        maCrossoverHoldSignal := false
else
    // If the filter is disabled entirely, it can never generate a hold signal.
    maCrossoverHoldSignal := false

// --- MA Crossover Exit Execution (TREND MODE ONLY) ---
// CRITICAL FIX: The MA crossover system was calculating hold signals but never executing exits
// This adds the missing execution logic for when crossover indicates exit should occur
if trendMACrossoverExit and strategy.position_size != 0 and tradeMode == "TREND"
    maCrossoverExitTriggered = false
    if strategy.position_size > 0 and maCrossoverFast < maCrossoverSlow  // Death cross for long
        maCrossoverExitTriggered := true
    else if strategy.position_size < 0 and maCrossoverFast > maCrossoverSlow  // Golden cross for short
        maCrossoverExitTriggered := true
    
    // Execute exit if triggered
    if maCrossoverExitTriggered
        strategy.close_all(comment="Trend MA Crossover Exit")
        if debugEnabled
            debugMessage("MA CROSSOVER EXIT", "ğŸ”„ MA Crossover triggered exit - Fast: " + str.tostring(maCrossoverFast, "#.##") + " Slow: " + str.tostring(maCrossoverSlow, "#.##"), color.orange, color.white, 0.1)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 3. INDIVIDUAL INDICATOR EXIT SIGNAL GENERATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Trend Exit, Indicator Flip, Reversal Signal, Dynamic Exit
// LOGIC:
// - If in a LONG position, an exit signal is generated if the indicator's state is BEARISH.
// - If in a SHORT position, an exit signal is generated if the indicator's state is BULLISH.
//
// INTEGRATION:
// The boolean exit signals generated here (`hullExitSignal`, `supertrendExitSignal`, etc.) are not
// acted upon directly. Instead, they are collected and passed to the 'COMBINE ALL TREND-EXIT/HOLD FILTERS'
// section, where a final confluence logic decides whether to trigger a strategy exit based on
// user-defined rules (e.g., 'Any Filter Triggers' vs. 'All Filters Must Agree'). This layered
// approach provides a robust and highly configurable trend-based exit.

// Initialize boolean flags for each potential exit signal.
var bool hullExitSignal = false
var bool trendStrengthExitSignal = false
var bool quadrantExitSignal = false
var bool adaptiveExitSignal = false
var bool volumaticExitSignal = false
var bool smoothHAExitSignal = false

// For each indicator, the logic is the same:
// If in a LONG position, trigger an exit if the indicator turns BEARISH.
// If in a SHORT position, trigger an exit if the indicator turns BULLISH.

// --- Hull Suite Exit Signal ---
// This logic checks if the Hull Suite indicator has flipped against the current trade direction.
if hullTrendExit and hullEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Hull trend is no longer bullish, set the exit signal to true.
        hullExitSignal := not hullBullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Hull trend has turned bullish, set the exit signal to true.
        hullExitSignal := hullBullish
    else
        // No position, so no exit signal.
        hullExitSignal := false
else
    // If the Hull exit is disabled, the signal is always false.
    hullExitSignal := false

// --- Trend Strength Exit Signal ---
// This logic checks if the Trend Strength indicator has flipped against the current trade direction.
if trendStrengthTrendExit and trendStrengthEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Trend Strength is no longer bullish, set the exit signal to true.
        trendStrengthExitSignal := not trendStrengthBullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Trend Strength has turned bullish, set the exit signal to true.
        trendStrengthExitSignal := trendStrengthBullish
    else
        // No position, so no exit signal.
        trendStrengthExitSignal := false
else
    // If the Trend Strength exit is disabled, the signal is always false.
    trendStrengthExitSignal := false

// --- Quadrant NW Exit Signal ---
// This logic checks if the Quadrant NW indicator has flipped against the current trade direction.
if quadrantTrendExit and quadrantEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Quadrant trend is no longer bullish, set the exit signal to true.
        quadrantExitSignal := not quadrantBullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Quadrant trend has turned bullish, set the exit signal to true.
        quadrantExitSignal := quadrantBullish
    else
        // No position, so no exit signal.
        quadrantExitSignal := false
else
    // If the Quadrant exit is disabled, the signal is always false.
    quadrantExitSignal := false

// --- Adaptive SuperTrend Exit Signal ---
// This logic checks if the Adaptive SuperTrend indicator has flipped against the current trade direction.
if adaptiveTrendExit and adaptiveSTEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Adaptive SuperTrend is no longer bullish, set the exit signal to true.
        adaptiveExitSignal := not adaptiveSTBullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Adaptive SuperTrend has turned bullish, set the exit signal to true.
        adaptiveExitSignal := adaptiveSTBullish
    else
        // No position, so no exit signal.
        adaptiveExitSignal := false
else
    // If the Adaptive SuperTrend exit is disabled, the signal is always false.
    adaptiveExitSignal := false

// --- Volumatic VIDYA Exit Signal ---
// This logic checks if the Volumatic VIDYA indicator has flipped against the current trade direction.
if volumaticTrendExit and volumaticEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Volumatic trend is no longer bullish, set the exit signal to true.
        volumaticExitSignal := not volumaticBullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Volumatic trend has turned bullish, set the exit signal to true.
        volumaticExitSignal := volumaticBullish
    else
        // No position, so no exit signal.
        volumaticExitSignal := false
else
    // If the Volumatic exit is disabled, the signal is always false.
    volumaticExitSignal := false

// --- Smooth Heiken Ashi Exit Signal ---
// This logic checks if the Smoothed Heiken Ashi indicator has flipped against the current trade direction.
if smoothHATrendExit and smoothHAEnable
    if strategy.position_size > 0 // Currently in a long position.
        // If the Heiken Ashi trend is no longer bullish, set the exit signal to true.
        smoothHAExitSignal := not smoothHABullish
    else if strategy.position_size < 0 // Currently in a short position.
        // If the Heiken Ashi trend has turned bullish, set the exit signal to true.
        smoothHAExitSignal := smoothHABullish
    else
        // No position, so no exit signal.
        smoothHAExitSignal := false
else
    // If the Heiken Ashi exit is disabled, the signal is always false.
    smoothHAExitSignal := false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 4. EXTERNAL TREND EXIT SIGNAL (GENERIC) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Custom Exit, External Signal, Universal Trigger, Plot-Based Exit
//
// MECHANISM:
// The logic does not care about the specific value of the connected source (`trendExitSignalSrc`).
// Instead, it triggers an exit signal (`externalTrendExitSignal`) only when the value of the source
// changes from one bar to the next (`source != source[1]`). This is a highly effective way to
// detect a one-time event without needing to know the plot's specific value.
//
// INTEGRATION:
// Just like the other individual indicator exits, this signal is passed to the final confluence
// logic block to be evaluated according to the user's selected trend exit rules.
var bool externalTrendExitSignal = false

// ENHANCED: Process all signals marked as "Trend Exit" usage
// This allows Hull Suite, Smooth HA, and other indicators to be used as trend exit signals
trendExitSignal1 = (signal1Usage == 'Trend Exit' and signal1Enable) ? (signal1LongSrc != signal1LongSrc[1] or signal1ShortSrc != signal1ShortSrc[1]) : false
trendExitSignal2 = (signal2Usage == 'Trend Exit' and signal2Enable) ? (signal2LongSrc != signal2LongSrc[1] or signal2ShortSrc != signal2ShortSrc[1]) : false
trendExitSignal3 = (signal3Usage == 'Trend Exit' and signal3Enable) ? (signal3LongSrc != signal3LongSrc[1] or signal3ShortSrc != signal3ShortSrc[1]) : false
trendExitSignal4 = (signal4Usage == 'Trend Exit' and signal4Enable) ? (signal4LongSrc != signal4LongSrc[1] or signal4ShortSrc != signal4ShortSrc[1]) : false
trendExitSignal5 = (signal5Usage == 'Trend Exit' and signal5Enable) ? (signal5LongSrc != signal5LongSrc[1] or signal5ShortSrc != signal5ShortSrc[1]) : false
trendExitSignal6 = (signal6Usage == 'Trend Exit' and signal6Enable) ? (signal6LongSrc != signal6LongSrc[1] or signal6ShortSrc != signal6ShortSrc[1]) : false
trendExitSignal7 = (signal7Usage == 'Trend Exit' and signal7Enable) ? (signal7LongSrc != signal7LongSrc[1] or signal7ShortSrc != signal7ShortSrc[1]) : false
trendExitSignal8 = (signal8Usage == 'Trend Exit' and signal8Enable) ? (signal8LongSrc != signal8LongSrc[1] or signal8ShortSrc != signal8ShortSrc[1]) : false
trendExitSignal9 = (signal9Usage == 'Trend Exit' and signal9Enable) ? (signal9LongSrc != signal9LongSrc[1] or signal9ShortSrc != signal9ShortSrc[1]) : false
trendExitSignal10 = (signal10Usage == 'Trend Exit' and signal10Enable) ? (signal10LongSrc != signal10LongSrc[1] or signal10ShortSrc != signal10ShortSrc[1]) : false

// Legacy external trend exit signal (still supported)
legacyExternalSignal = trendExitSignalEnable ? (bar_index == 0 or trendExitSignalSrc != trendExitSignalSrc[1]) : false

// Combine all trend exit signals
externalTrendExitSignal := trendExitSignal1 or trendExitSignal2 or trendExitSignal3 or trendExitSignal4 or trendExitSignal5 or 
                          trendExitSignal6 or trendExitSignal7 or trendExitSignal8 or trendExitSignal9 or trendExitSignal10 or 
                          legacyExternalSignal

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• 5. COMBINE ALL TREND-EXIT/HOLD FILTERS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Confluence Logic, Final Exit Decision, Trend Hold, Master Gate
// OUTPUT & INTEGRATION:
// The final output, `allowTrendExit`, is a master gate that controls other, non-trend-based exit systems
// (like the Smart Profit Locker and Fixed SL/TP). 
// - If `allowTrendExit` is TRUE: Standard profit-taking and stop-loss exits are permitted.
// - If `allowTrendExit` is FALSE: A 'hold' condition is active. Standard exits are BLOCKED, forcing the
//   strategy to hold the position to ride the underlying trend for maximum profit potential. This is the
//   core of the trend-riding functionality.

// Initialize variables for the combined hold and exit signals.
var bool trendHoldActive = false
var bool trendExitTriggered = false

// --- Step 1: Combine All 'Hold' Signals ---
// The master 'hold' signal becomes active if ANY of the enabled hold-focused filters (Adaptive ST or MA Cross) are currently signaling a hold.
// The purpose of this signal is to temporarily block standard profit-taking exits, allowing the trade to ride the underlying trend.
trendHoldActive := adaptiveSTHoldSignal or maCrossoverHoldSignal

// --- Step 2: Tally and Evaluate All 'Exit' Signals ---
// All individual trend reversal signals are summed up to get a total count of indicators suggesting an exit.
individualExitCount = (hullExitSignal ? 1 : 0) + (trendStrengthExitSignal ? 1 : 0) + (quadrantExitSignal ? 1 : 0) + (adaptiveExitSignal ? 1 : 0) + (volumaticExitSignal ? 1 : 0) + (smoothHAExitSignal ? 1 : 0) + (externalTrendExitSignal ? 1 : 0)

// The final exit trigger is determined by the user-selected confluence logic.
if trendExitLogic == 'Any Filter Triggers Exit'
    // In 'Any' mode, an exit is triggered if at least one of the enabled indicators signals a trend reversal.
    trendExitTriggered := individualExitCount > 0
else  // 'All Filters Must Agree' mode
    // In 'All' mode, we first count how many exit indicator systems are currently enabled by the user.
    enabledExitFilters = (hullTrendExit ? 1 : 0) + (quadrantTrendExit ? 1 : 0) + (adaptiveTrendExit ? 1 : 0) + (volumaticTrendExit ? 1 : 0) + (smoothHATrendExit ? 1 : 0) + (trendExitSignalEnable ? 1 : 0)
    // An exit is triggered only if the number of indicators signaling an exit is equal to the total number of enabled exit indicators (and at least one is enabled).
    trendExitTriggered := enabledExitFilters > 0 and individualExitCount >= enabledExitFilters

// --- Step 3: Final Decision with Mode Integration ---
// This is the master switch for the entire Trend-Exit/Hold system, integrating the `scalpOnlyMode`.

if scalpOnlyMode
    // --- SCALP MODE OVERRIDE ---
    // In Scalp Only mode, all trend-hold logic is bypassed by forcing `allowTrendExit` to true.
    // This ensures that standard profit-taking and stop-loss exits are never blocked by this system.
    allowTrendExit := true
else
    // --- TREND MODE LOGIC ---
    // In Trend Mode, the system's full logic is applied.
    // An exit is permitted if EITHER of these conditions is met:
    // 1. No hold/exit filters are enabled at all (system is effectively off).
    // 2. A trend exit has been triggered (`trendExitTriggered`) AND is NOT being actively blocked by a hold signal (`trendHoldActive`).
    anyFiltersEnabled = adaptiveExitFilterEnable or trendMACrossoverExit or (trendBreakEnable and (trendStrengthTrendExit or quadrantTrendExit or adaptiveTrendExit or volumaticTrendExit or smoothHATrendExit)) or trendExitSignalEnable
    allowTrendExit := not trendHoldActive and (not anyFiltersEnabled or trendExitTriggered)

// --- Trend Break Exit Execution (TREND MODE ONLY) ---
// CRITICAL FIX: The trend break system was calculating exit signals but never executing exits
// This adds the missing execution logic for when trend indicators flip
if trendBreakEnable and trendExitTriggered and strategy.position_size != 0 and tradeMode == "TREND"
    strategy.close_all(comment="Trend Break Exit")
    if debugEnabled
        exitIndicators = (hullExitSignal ? "Hull " : "") + (trendStrengthExitSignal ? "SuperTrend " : "") + (quadrantExitSignal ? "Quadrant " : "") + (adaptiveExitSignal ? "Adaptive " : "") + (volumaticExitSignal ? "Volumatic " : "") + (smoothHAExitSignal ? "SmoothHA " : "") + (externalTrendExitSignal ? "External " : "")
        debugMessage("TREND BREAK EXIT", "ğŸ“‰ Trend break triggered exit - Indicators: " + exitIndicators, color.red, color.white, 0.1)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DIRECTIONAL BIAS CALCULATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Directional Bias, Confluence, Voting System, Trade Filter
// This is the core logic where all individual trend filter votes are combined to produce a
// final directional bias. This bias acts as the master gatekeeper, determining whether long or
// short trades are permitted based on the user-defined confluence rules.

// --- Step 1: Initialize Bias & Tally Votes ---
// The bias is assumed true (trades allowed) until proven otherwise. The system then counts how many filters are
// enabled and tallies the number of bullish vs. bearish votes from those active filters.
var bool longDirectionalBias = true
var bool shortDirectionalBias = true

// This calculation sums up all directional bias filters that are switched on
enabledFilters = directionalBiasEnable ? (hullBiasEnable ? 1.0 : 0.0) + (trendStrengthBiasEnable ? 1.0 : 0.0) + (quadrantBiasEnable ? 1.0 : 0.0) + (adaptiveBiasEnable ? 1.0 : 0.0) + (volumaticBiasEnable ? 1.0 : 0.0) + (smoothHABiasEnable ? 1.0 : 0.0) : 0.0

// This sums up the votes for a long trade. A vote is only counted if the filter is both enabled AND its state is currently bullish.
bullishVotes = directionalBiasEnable ? (hullBiasEnable and hullBullish ? 1.0 : 0.0) + (trendStrengthBiasEnable and trendStrengthBullish ? 1.0 : 0.0) + (quadrantBiasEnable and quadrantBullish ? 1.0 : 0.0) + (adaptiveBiasEnable and adaptiveSTBullish ? 1.0 : 0.0) + (volumaticBiasEnable and volumaticBullish ? 1.0 : 0.0) + (smoothHABiasEnable and smoothHABullish ? 1.0 : 0.0) : 0.0

// This sums up the votes for a short trade. A vote is counted if the filter is enabled AND its state is currently bearish (i.e., not bullish).
bearishVotes = directionalBiasEnable ? (hullBiasEnable and not hullBullish ? 1.0 : 0.0) + (trendStrengthBiasEnable and not trendStrengthBullish ? 1.0 : 0.0) + (quadrantBiasEnable and not quadrantBullish ? 1.0 : 0.0) + (adaptiveBiasEnable and not adaptiveSTBullish ? 1.0 : 0.0) + (volumaticBiasEnable and not volumaticBullish ? 1.0 : 0.0) + (smoothHABiasEnable and not smoothHABullish ? 1.0 : 0.0) : 0.0

// --- Step 2: Apply Confluence Logic ---
// This block translates the raw vote counts into the final boolean bias signals based on the user's selected confluence rule.
// If directional bias is disabled or no filters are enabled, the bias is permissive (true) by default.
longDirectionalBias := not directionalBiasEnable or enabledFilters == 0 ? true : 
     (biasConfluence == 'Any' and bullishVotes > 0) or                      // 'Any': At least one bullish vote is required.
     (biasConfluence == 'Majority' and bullishVotes > bearishVotes) or          // 'Majority': Bullish votes must outnumber bearish votes.
     (biasConfluence == 'All' and bearishVotes == 0)                          // 'All': No bearish votes are allowed among enabled filters.

shortDirectionalBias := not directionalBiasEnable or enabledFilters == 0 ? true : 
     (biasConfluence == 'Any' and bearishVotes > 0) or                      // 'Any': At least one bearish vote is required.
     (biasConfluence == 'Majority' and bearishVotes > bullishVotes) or          // 'Majority': Bearish votes must outnumber bullish votes.
     (biasConfluence == 'All' and bullishVotes == 0)                          // 'All': No bullish votes are allowed among enabled filters.

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENTRY SIGNAL FINALIZATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// KEYWORDS: Final Signal, Entry Trigger, Gatekeeper
// EXECUTION ORDER FIX: Calculate and assign entry signals immediately after all dependencies are ready

// Calculate bias-applied signals using all required components
baseLongWithBias := primaryLongSig and longDirectionalBias and allowLongs
baseShortWithBias := primaryShortSig and shortDirectionalBias and allowShorts

// Set final entry signals for strategy execution - WITH CONTINUATION INTEGRATION
// CRITICAL FIX: Now properly integrates continuation system
longEntrySignal := continuationEnable ? 
    (longContinuationActive and high >= longContinuationLevel and baseLongWithBias) : 
    baseLongWithBias

shortEntrySignal := continuationEnable ? 
    (shortContinuationActive and low <= shortContinuationLevel and baseShortWithBias) : 
    baseShortWithBias

// Enhanced debug logging for all directional bias filters and systems
// KEYWORDS: Debug, Logging, Filter Status, Confluence
// This section provides a detailed, real-time text output of the strategy's internal state,
// which is invaluable for debugging and understanding its decision-making process.
if debugEnabled
    // --- Filter Status Summary ---
    // This builds a string that summarizes the real-time status of each primary trend filter.
    filterStatusMsg = 'FILTER STATUS:'
    // For each filter, it checks if it's enabled. If so, it reports its bullish/bearish state; otherwise, it reports 'OFF'.
    filterStatusMsg += ' Hull=' + (hullEnable ? (hullBullish ? 'BULL' : 'BEAR') : 'OFF')
    filterStatusMsg += ' TS=' + (trendStrengthEnable ? (trendStrengthBullish ? 'BULL' : 'BEAR') : 'OFF')
    // SuperTrend removed
    filterStatusMsg += ' Quad=' + (quadrantEnable ? (quadrantBullish ? 'BULL' : 'BEAR') : 'OFF')
    // The final status string is then passed to the debug logger.
    debugMessage("FILTER", filterStatusMsg, color.blue, color.white, 0.2)
    
    // --- Confluence Calculation Details ---
    // This provides a comprehensive overview of the entire directional bias confluence system.
    // It reports the active confluence mode, the number of enabled filters, and the raw bullish/bearish vote counts.
    confluenceMsg = 'CONFLUENCE: Mode=' + biasConfluence + ' | Enabled=' + str.tostring(enabledFilters) + ' | BullVotes=' + str.tostring(bullishVotes) + ' | BearVotes=' + str.tostring(bearishVotes)
    // It also shows the final outcome: whether long and short trades are currently being allowed or blocked by the system.
    confluenceMsg += ' | LongBias=' + (longDirectionalBias ? 'ALLOW' : 'BLOCK') + ' | ShortBias=' + (shortDirectionalBias ? 'ALLOW' : 'BLOCK')
    // The final confluence summary is passed to the debug logger.
    debugMessage("CONFLUENCE", confluenceMsg, color.orange, color.white, 0.3)
    
    // --- Individual Filter Votes ---
    // This provides a granular look at the specific vote cast by each filter that is currently active.
    if enabledFilters > 0
        voteDetailMsg = 'FILTER VOTES:'
        // For each enabled filter, its specific 'BULL' or 'BEAR' vote is appended to the message.
        if hullEnable
            voteDetailMsg += ' Hull=' + (hullBullish ? 'BULL' : 'BEAR')
        if trendStrengthEnable
            voteDetailMsg += ' TS=' + (trendStrengthBullish ? 'BULL' : 'BEAR')
        // SuperTrend removed
        if quadrantEnable
            voteDetailMsg += ' Quad=' + (quadrantBullish ? 'BULL' : 'BEAR')
        // The detailed vote string is then passed to the debug logger.
        debugMessage("VOTE", voteDetailMsg, color.yellow, color.black, 0.4)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIGNAL-DRIVEN TREND RIDER: EXIT INTERCEPTION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// REVOLUTIONARY FEATURE: Intercept and ignore standard exits during trend-riding mode
// This is the core of the Signal-Driven Trend Rider system

// â”€â”€â”€â”€â”€â”€â”€â”€ CORE EXIT SYSTEMS (PRESERVED) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Duplicate Smart Profit Locker implementation removed - using original version above

// Duplicate exit system implementations removed - using original versions above
// - Fixed SL/TP System: Already implemented at line ~607
// - MA Exit System: Already implemented at line ~585 
// - Signal-Based exits: Already implemented in main logic above

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TREND-EXIT/HOLD FILTER DEBUG VISUALIZATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Professional badge-style debug display for trend-exit/hold filter system

// This block activates only when debug mode is enabled and a trade is active.
if trendExitDebug and strategy.position_size != 0
    // A persistent string variable is used to build the multi-line text for our debug badge.
    var string trendFilterStatus = ''
    // The string is reset on each bar and initialized with a title.
    trendFilterStatus := 'TREND EXIT FILTERS\n'
    
    // --- Append Status for Each Enabled Filter ---
    // If the Adaptive SuperTrend hold filter is on, its status (HOLD/ALLOW) and volatility number are added.
    if adaptiveExitFilterEnable
        adaptiveStatus = adaptiveSTHoldSignal ? 'HOLD' : 'ALLOW'
        trendFilterStatus += 'Adaptive ST: Vol' + str.tostring(adaptiveSTNumber) + ' [' + adaptiveStatus + ']\n'
    
    // If the MA Crossover hold filter is on, its status (HOLD/ALLOW) and settings are added.
    if trendMACrossoverExit
        maStatus = maCrossoverHoldSignal ? 'HOLD' : 'ALLOW'
        trendFilterStatus += 'MA Cross: ' + str.tostring(maCrossoverFastLength) + '/' + str.tostring(maCrossoverSlowLength) + ' [' + maStatus + ']\n'
    
    // If any individual trend indicator is configured to send an exit signal, the count of triggered exits is shown.
    if hullTrendExit or quadrantTrendExit or adaptiveTrendExit or volumaticTrendExit or smoothHATrendExit or trendExitSignalEnable
        trendFilterStatus += 'Individual Exits: ' + str.tostring(individualExitCount) + ' triggered\n'
        // If the external signal is used, its specific TRIGGERED/WAITING status is also shown.
        if trendExitSignalEnable
            externalStatus = externalTrendExitSignal ? 'TRIGGERED' : 'WAITING'
            trendFilterStatus += 'External Exit: [' + externalStatus + ']\n'
    
    // --- Final Status Summary ---
    // The final, most important decision of the entire system is appended.
    overallStatus = allowTrendExit ? 'EXIT ALLOWED' : 'EXIT BLOCKED'
    trendFilterStatus += '\nSTATUS: ' + overallStatus
    
    // --- Display the Badge ---
    // CRITICAL OPTIMIZATION: The label is only drawn on the very last bar to prevent script lag from drawing thousands of historical labels.
    if barstate.islast
        // The badge color is green if exits are allowed, and red if they are blocked.
        badgeColor = allowTrendExit ? color.new(color.green, 85) : color.new(color.red, 85)
        // A new label is created on the chart to display the complete status string.
        debugLabel = label.new(bar_index, high + atrVal * 0.3, trendFilterStatus, 
                              color=badgeColor, 
                              textcolor=color.white, 
                              style=label.style_label_down, 
                              size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STEP CHANNEL MOMENTUM VISUALS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Complete ChartPrime Step Channel Momentum visualization (moved to global scope)

// Step Channel visual variables (calculated above in independent mode selection components)
stepChannelShowVisualsActive = stepChannelEnable and stepChannelShowVisuals
stepChannelMidLineColor = stepChannelShowVisualsActive and stepChannelShowLines ? stepChannelCurrentColor : na
stepChannelUpperColor = stepChannelShowVisualsActive and stepChannelShowLines ? chart.fg_color : na
stepChannelLowerColor = stepChannelShowVisualsActive and stepChannelShowLines ? chart.fg_color : na
stepChannelCandleColor = stepChannelShowVisualsActive and stepChannelShowCandles ? stepChannelCurrentColor : na

// --- Step Channel Line Plotting ---
// A boolean flag to control the visibility of all channel lines.
stepChannelLinesActive = stepChannelEnable and stepChannelShowLines

// Plots the momentum-colored midline of the channel. Its visibility is controlled by the master flag.
plot(stepChannelLinesActive ? stepChannelAvg : na, 
     "Step Channel MidLine", 
     color=stepChannelLinesActive ? stepChannelCurrentColor : na, 
     linewidth=3)
// Plots the upper boundary of the channel.
plot(stepChannelLinesActive ? stepChannelUpper : na, 
     "Step Channel Upper", 
     color=stepChannelLinesActive ? chart.fg_color : na, 
     style=plot.style_linebr)
// Plots the lower boundary of the channel.
plot(stepChannelLinesActive ? stepChannelLower : na, 
     "Step Channel Lower", 
     color=stepChannelLinesActive ? chart.fg_color : na, 
     style=plot.style_linebr)

// --- Step Channel Momentum Candles ---
// This function overlays colored candles based on the Step Channel's momentum state (Bullish/Bearish/Range).
plotcandle(stepChannelEnable and stepChannelShowCandles ? open : na, 
           stepChannelEnable and stepChannelShowCandles ? high : na, 
           stepChannelEnable and stepChannelShowCandles ? low : na, 
           stepChannelEnable and stepChannelShowCandles ? close : na, 
           title='Momentum Candles', 
           color=stepChannelEnable and stepChannelShowCandles ? stepChannelCurrentColor : na, 
           wickcolor=stepChannelEnable and stepChannelShowCandles ? stepChannelCurrentColor : na, 
           bordercolor=stepChannelEnable and stepChannelShowCandles ? stepChannelCurrentColor : na)

// --- Step Channel Market State Label ---
// Displays the current market state (e.g., "Bull Trend") as a label on the last bar for real-time analysis.
if stepChannelShowVisualsActive and stepChannelShowLabel and barstate.islast
    label.new(bar_index, close, stepChannelState, color=color(na), textcolor=stepChannelCurrentColor, style=label.style_label_left, size=size.large)

// --- PHASE 2: Step Channel Debug Information ---
// Displays detailed Step Channel information when debug is enabled
if trendModeDebug and stepChannelEnable and barstate.islast
    // Create Step Channel debug table
    var table stepChannelDebugTable = table.new(position.bottom_right, 2, 6, bgcolor=color.new(color.white, 80), border_width=1)
    
    if barstate.islast
        // Header
        table.cell(stepChannelDebugTable, 0, 0, "STEP CHANNEL DEBUG", text_color=color.white, bgcolor=color.new(color.purple, 0), text_size=size.normal)
        table.cell(stepChannelDebugTable, 1, 0, "", bgcolor=color.new(color.purple, 0))
        
        // Current State
        stateColor = stepChannelTrendMode ? color.new(color.green, 0) : color.new(color.orange, 0)
        table.cell(stepChannelDebugTable, 0, 1, "Current State:", text_color=color.black, text_size=size.small)
        table.cell(stepChannelDebugTable, 1, 1, stepChannelState, text_color=color.white, bgcolor=stateColor, text_size=size.small)
        
        // Mode Detection
        table.cell(stepChannelDebugTable, 0, 2, "Mode Detection:", text_color=color.black, text_size=size.small)
        modeText = stepChannelTrendMode ? "TREND MODE" : "SCALP MODE"
        table.cell(stepChannelDebugTable, 1, 2, modeText, text_color=color.white, bgcolor=stateColor, text_size=size.small)
        
        // Directional Bias Status
        table.cell(stepChannelDebugTable, 0, 3, "Directional Bias:", text_color=color.black, text_size=size.small)
        biasStatusText = stepChannelDirectionalBias ? "ENABLED" : "DISABLED"
        biasStatusColor = stepChannelDirectionalBias ? color.new(color.blue, 0) : color.new(color.gray, 0)
        table.cell(stepChannelDebugTable, 1, 3, biasStatusText, text_color=color.white, bgcolor=biasStatusColor, text_size=size.small)
        
        // Channel Boundaries
        table.cell(stepChannelDebugTable, 0, 4, "Upper/Lower:", text_color=color.black, text_size=size.small)
        boundariesText = str.tostring(stepChannelUpper, "#.##") + " / " + str.tostring(stepChannelLower, "#.##")
        table.cell(stepChannelDebugTable, 1, 4, boundariesText, text_color=color.black, text_size=size.small)
        
        // Current Price vs Boundaries
        table.cell(stepChannelDebugTable, 0, 5, "Price Position:", text_color=color.black, text_size=size.small)
        positionText = ""
        positionColor = color.new(color.gray, 0)
        if close > stepChannelUpper
            positionText := "ABOVE (Momentum Up)"
            positionColor := color.new(color.green, 0)
        else if close < stepChannelLower
            positionText := "BELOW (Momentum Down)"
            positionColor := color.new(color.red, 0)
        else
            positionText := "INSIDE (Range)"
            positionColor := color.new(color.orange, 0)
        table.cell(stepChannelDebugTable, 1, 5, positionText, text_color=color.white, bgcolor=positionColor, text_size=size.small)

// --- PHASE 3: CVD Debug Information ---
// Displays detailed CVD information when debug is enabled
if trendModeDebug and cvdEnable and barstate.islast
    // Create CVD debug table
    var table cvdDebugTable = table.new(position.bottom_left, 2, 6, bgcolor=color.new(color.white, 80), border_width=1)
    
    if barstate.islast
        // Header
        table.cell(cvdDebugTable, 0, 0, "CVD DEBUG", text_color=color.white, bgcolor=color.new(color.teal, 0), text_size=size.normal)
        table.cell(cvdDebugTable, 1, 0, "", bgcolor=color.new(color.teal, 0))
        
        // Connection Status
        connectionColor = isValidSignalSource(cvdValueSrc) ? color.new(color.green, 0) : color.new(color.red, 0)
        connectionText = isValidSignalSource(cvdValueSrc) ? "âœ… CONNECTED" : "âŒ NOT CONNECTED"
        table.cell(cvdDebugTable, 0, 1, "Connection:", text_color=color.black, text_size=size.small)
        table.cell(cvdDebugTable, 1, 1, connectionText, text_color=color.white, bgcolor=connectionColor, text_size=size.small)
        
        // Current CVD Value
        table.cell(cvdDebugTable, 0, 2, "CVD Value:", text_color=color.black, text_size=size.small)
        cvdValueText = str.tostring(math.round(cvdValue), "#,###")
        table.cell(cvdDebugTable, 1, 2, cvdValueText, text_color=color.black, text_size=size.small)
        
        // Trend Signal Status
        trendSignalColor = cvdTrendMode ? color.new(color.green, 0) : color.new(color.orange, 0)
        trendSignalText = cvdTrendMode ? "TREND ALLOWED" : "SCALP ONLY"
        table.cell(cvdDebugTable, 0, 3, "Trend Signal:", text_color=color.black, text_size=size.small)
        table.cell(cvdDebugTable, 1, 3, trendSignalText, text_color=color.white, bgcolor=trendSignalColor, text_size=size.small)
        
        // Mode Decision
        table.cell(cvdDebugTable, 0, 4, "Mode Decision:", text_color=color.black, text_size=size.small)
        modeDecisionText = cvdTrendMode ? "TREND MODE" : "SCALP MODE"
        table.cell(cvdDebugTable, 1, 4, modeDecisionText, text_color=color.white, bgcolor=trendSignalColor, text_size=size.small)
        
        // PHASE 3: Emphasize no directional bias
        table.cell(cvdDebugTable, 0, 5, "Directional Bias:", text_color=color.black, text_size=size.small)
        table.cell(cvdDebugTable, 1, 5, "NONE (Mode Only)", text_color=color.white, bgcolor=color.new(color.gray, 0), text_size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADAPTIVE SUPERTREND VOLATILITY VISUALIZATION (EXTERNALIZED) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// The visualization logic for displaying the Adaptive SuperTrend's volatility numbers (1, 2, or 3)
// has been moved to the external 'Adaptive.pine' indicator.
// To see these numbers on the chart, you must add the 'Adaptive.pine' indicator to your chart
// and enable the 'Show Volatility Numbers' option within its settings.
// This section is intentionally left blank to prevent code duplication and conflicts.

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONTINUATION & MOMENTUM SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Continuation, Re-entry, Trend Riding, Momentum
// This system allows the strategy to re-enter trades in the direction of an established trend.
// After an initial trade is taken and closed, this logic checks if the underlying momentum
// is still strong, providing opportunities to capitalize further on the same directional move.
// It is a key component of the strategy's ability to maximize profit from strong trends.
// Supports both immediate entries (continuation disabled) and continuation entries (intrabar)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• UNIFIED ENTRY EXECUTION SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYWORDS: Unified Entry, Standard+Continuation, Single System
// This unified system handles both standard and continuation entries seamlessly

// Use unified signals - let TradingView handle pyramiding limits
finalLongEntry = longEntrySignal
finalShortEntry = shortEntrySignal

// UNIFIED ENTRY EXECUTION (Critical for both entry types)
// Note: Both standard and continuation entries use the same execution logic
// POSITION FLIPPING: strategy.entry() automatically closes opposing positions (Long signal while short = close short, open long)
if finalLongEntry
    entryComment = continuationEnable ?         buildSignalName(true) + " [CONT:" + str.tostring(continuationDistance, "#.##") + continuationType + "]" :         buildSignalName(true)
    
    // Enhanced webhook message with continuation info
    continuationInfo = continuationEnable ?         ", \"continuation\": {\"enabled\": true, \"distance\": " + str.tostring(continuationDistance, "#.##") + ", \"type\": \"" + continuationType + "\", \"level\": " + str.tostring(longContinuationLevel, "#.####") + "}" :         ", \"continuation\": {\"enabled\": false}"
    
    enhancedLongEntryMsg = '{"ticker": "{{ticker}}", "action": "buy", "price": "{{close}}", "strategy": "EZ Algo Hedge Fund", "signals": "' + buildSignalName(true) + '"' + continuationInfo + '}'
    
    strategy.entry('Long', strategy.long, qty=1, comment=entryComment, alert_message=enhancedLongEntryMsg)
    strategyEntryPrice := close
    
    // Enhanced debug logging
    entryType = continuationEnable ? "CONTINUATION" : "IMMEDIATE"
    debugMessage("ENTRY", "ğŸš€ LONG " + entryType + " ENTRY: " + buildSignalName(true) + " at " + str.tostring(close), color.green, color.white, 0.1, true)
    if continuationEnable
        debugMessage("ENTRY", "ğŸ¯ Continuation Details: Level=" + str.tostring(longContinuationLevel) + ", Distance=" + str.tostring(continuationDistance) + " " + continuationType, color.blue, color.white, 0.15)
    
    // Reset exit flags for new position
    maExitSent := false
    fixedExitSent := false
    trailExitSent := false
    
    // Reset continuation state after successful entry
    if continuationEnable
        longContinuationActive := false
        longContinuationLevel := na

if finalShortEntry
    entryComment = continuationEnable ?         buildSignalName(false) + " [CONT:" + str.tostring(continuationDistance, "#.##") + continuationType + "]" :         buildSignalName(false)
    
    // Enhanced webhook message with continuation info
    continuationInfo = continuationEnable ?         ", \"continuation\": {\"enabled\": true, \"distance\": " + str.tostring(continuationDistance, "#.##") + ", \"type\": \"" + continuationType + "\", \"level\": " + str.tostring(shortContinuationLevel, "#.####") + "}" :         ", \"continuation\": {\"enabled\": false}"
    
    enhancedShortEntryMsg = '{"ticker": "{{ticker}}", "action": "sell", "price": "{{close}}", "strategy": "EZ Algo Hedge Fund", "signals": "' + buildSignalName(false) + '"' + continuationInfo + '}'
    
    strategy.entry('Short', strategy.short, qty=1, comment=entryComment, alert_message=enhancedShortEntryMsg)
    strategyEntryPrice := close
    
    // Enhanced debug logging
    entryType = continuationEnable ? "CONTINUATION" : "IMMEDIATE"
    debugMessage("ENTRY", "ğŸš€ SHORT " + entryType + " ENTRY: " + buildSignalName(false) + " at " + str.tostring(close), color.red, color.white, 0.1, true)
    if continuationEnable
        debugMessage("ENTRY", "ğŸ¯ Continuation Details: Level=" + str.tostring(shortContinuationLevel) + ", Distance=" + str.tostring(continuationDistance) + " " + continuationType, color.blue, color.white, 0.15)
    
    // Reset exit flags for new position
    maExitSent := false
    fixedExitSent := false
    trailExitSent := false
    
    // Reset continuation state after successful entry
    if continuationEnable
        shortContinuationActive := false
        shortContinuationLevel := na

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INTELLIGENT BLOCKING STATUS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Professional status display for blocked entries

var label blockingLabel = na

// Function to create blocking status label (returns label for assignment)
createBlockingLabel(string reason) =>
    label.new(bar_index, high + atrVal * 0.5, reason, 
              color=color.new(color.red, 80), 
              textcolor=color.white, 
              style=label.style_label_down, 
              size=size.normal)

// Check for blocking conditions and display informative labels
if barstate.islast
    var string blockingReason = na
    
    if sigCountLong > 0 and not longEntrySignal
        if not longDirectionalBias
            blockingReason := 'ğŸš« LONG BLOCKED: DIRECTIONAL BIAS'
        else if stepChannelEnable and stepChannelState == "Range"
            blockingReason := 'ğŸš« LONG BLOCKED: STEP CHANNEL RANGE'
        else if cvdEnable and not cvdTrendMode
            blockingReason := 'ğŸš« LONG BLOCKED: CVD THRESHOLD'
    
    else if sigCountShort > 0 and not shortEntrySignal
        if not shortDirectionalBias
            blockingReason := 'ğŸš« SHORT BLOCKED: DIRECTIONAL BIAS'
        else if stepChannelEnable and stepChannelState == "Range"
            blockingReason := 'ğŸš« SHORT BLOCKED: STEP CHANNEL RANGE'
        else if cvdEnable and not cvdTrendMode
            blockingReason := 'ğŸš« SHORT BLOCKED: CVD THRESHOLD'
    
    // Update the blocking label if there's a reason
    if not na(blockingReason)
        label.delete(blockingLabel)
        blockingLabel := createBlockingLabel(blockingReason)
    
    else if strategy.position_size != 0
        positionType = strategy.position_size > 0 ? "LONG" : "SHORT"
        signalCount = strategy.position_size > 0 ? sigCountLong : sigCountShort
        label.delete(blockingLabel)
        blockingLabel := createBlockingLabel('âœ… IN ' + positionType + ' TRADE: ' + str.tostring(signalCount) + ' SIGNALS')
    
    else if sigCountLong == 0 and sigCountShort == 0
        label.delete(blockingLabel)
        blockingLabel := createBlockingLabel('â³ WAITING FOR SIGNALS')
    
    else
        label.delete(blockingLabel)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PRODUCTION SAFETY CHECKS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Critical safety validations for production deployment

// Position sizing validation removed - using TradingView system defaults
// Pyramid limit removed - using TradingView system defaults

// Validate exit system configuration
if not smartProfitEnable and not fixedEnable and not scalpMAExitOn
    runtime.error("PRODUCTION WARNING: At least one exit system should be enabled")

// Validate signal configuration
signalCount = (signal1Enable ? 1 : 0) + (signal2Enable ? 1 : 0) + (signal3Enable ? 1 : 0) + 
              (signal4Enable ? 1 : 0) + (signal5Enable ? 1 : 0) + (signal6Enable ? 1 : 0) + 
              (signal7Enable ? 1 : 0) + (signal8Enable ? 1 : 0) + (signal9Enable ? 1 : 0) + 
              (signal10Enable ? 1 : 0)

if signalCount == 0
    runtime.error("PRODUCTION WARNING: At least one signal should be enabled for trading")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PERFORMANCE MONITORING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Duplicate performance table removed - performance table already exists elsewhere

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FINAL PRODUCTION NOTES â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸš€ EZ ALGO HEDGE FUND 
// SAFETY FEATURES:
// âœ… Memory-safe debug system (no label leaks)
// âœ… Production safety validations
// âœ… Intelligent blocking status display
// âœ… Comprehensive error handling
// âœ… Performance monitoring dashboard
// âœ… Professional webhook integration

