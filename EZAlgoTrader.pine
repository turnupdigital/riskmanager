// 2025 Andres Garcia â€” EZ Algo Trader (Beta)
//  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Enhanced Multi-Signal Risk Management System
//  â€¢ Professional risk management with multiple exit strategies
//  â€¢ TradersPost webhook integration for automated trading
//  â€¢ Configurable position sizing and stop-loss/take-profit levels
//  â€¢ Integrated debugging logger for development
//  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//@version=6

// DEBUG SYSTEM
// Simple debug system using Pine Script labels - no external libraries

// Debug configuration
bool debugEnabled = input.bool(false, 'ğŸ” Enable Debug Labels', group = 'ğŸ› ï¸ Debug System', tooltip = 'Show debug information as chart labels')

// Combined debug function
debugMessage(string type, string message, color bgColor, color txtColor, float yOffset) =>
    if debugEnabled
        label.new(bar_index, high + (high - low) * yOffset, type + ": " + message, style=label.style_label_down, color=bgColor, textcolor=txtColor, size=size.small)

strategy(title = 'EZ Algo Trader (Beta)', overlay = true, default_qty_type = strategy.fixed, default_qty_value = 1, calc_on_order_fills = true, process_orders_on_close = true, calc_on_every_tick = false)
// User-controllable quantity

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• GLOBAL VARIABLE DECLARATIONS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Declare all variables early to avoid scope issues

// Trend-riding system variables (removed - replaced by Trend Change Exit & Hybrid Exit)

// Exit system variables
var float smartOffset = na
var string exitComment = na
var float smartDistance = na
var string exitReason = na

// Strategy Performance Tracking Variables (expanded to 10 signals)
var array<float> signal_strategy_profits = array.new<float>(10, 0.0)
var array<float> signal_strategy_drawdowns = array.new<float>(10, 0.0)

// Missing variable declarations - restored
var float strategyEntryPrice = na
var bool trailExitSent = false
var bool maExitSent = false
var bool fixedExitSent = false
var bool inPosition = false
var bool currentPosition = false

// Backtesting variables
var array<int> signal_tradeCounts = array.new<int>(10, 0)
var array<int> signal_winCounts = array.new<int>(10, 0)
var array<float> signal_profits = array.new<float>(10, 0.0)
var array<float> signal_entryPrices = array.new<float>(10, na)
var array<string> signal_positions = array.new<string>(10, "none")
var array<float> signal_largestWins = array.new<float>(10, 0.0)
var array<float> signal_grossProfits = array.new<float>(10, 0.0)
var array<float> signal_grossLosses = array.new<float>(10, 0.0)

// Panel control variables
showBacktestTable = input.bool(true, 'ğŸ“Š Individual Signal Backtest', group = 'ğŸ” Backtesting Panels', tooltip = 'Show individual signal performance (existing table)')
futuresMultiplier = input.int(20, 'ğŸ’° Futures Multiplier', minval=1, maxval=100, group = 'ğŸ” Backtesting Panels', tooltip = 'Point value multiplier for futures (NQ=20, ES=50, YM=5, RTY=50)')

// Advanced Trend Exit System Variables (moved here from later in script)
var bool inTrendExitMode = false
var bool inProfitMode = false
var float trendExitPrice = na
var bool waitingForReEntry = false
var int exitDirection = 0  // 1 = was long, -1 = was short
var bool reEntrySignal = false
var bool colorChangeExit = false
var bool useAdvancedTrendExit = false

// Missing hybrid exit variables
var bool hybridExitActive = false
var bool hybridUsingSPL = false
var bool hybridUsingTCE = false
var bool bbLongFilterOK = true
var bool bbShortFilterOK = true
var bool trendChangeExitActive = false
var bool trendChangeDetected = false
var string trendChangeDetails = ""
var array<float> signal_contributions = array.new<float>(10, 0.0)
var float volatilityRatio = na
var float current_trade_entry = na
var float current_trade_peak = na
var float current_trade_trough = na
var array<bool> current_trade_signals = array.new<bool>(10, false)
var array<int> signal_strategy_trades = array.new<int>(10, 0)
var array<int> signal_strategy_wins = array.new<int>(10, 0)
var bool longEntrySignal = false
var bool shortEntrySignal = false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• VIRTUAL SIGNAL ARCHITECTURE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Individual Signal Backtesting System - 10 Parallel Virtual Accounts
// Each signal gets its own isolated "trading account" for perfect attribution

// Virtual Account Structure for Each Signal
type VirtualAccount
    bool inPosition = false
    string direction = "none"  // "long", "short", "none"
    float entryPrice = na
    float currentPnL = 0.0
    float totalPnL = 0.0
    int totalTrades = 0
    int winningTrades = 0
    float maxDrawdown = 0.0
    float peakPnL = 0.0
    float troughPnL = 0.0
    float largestWin = 0.0
    float largestLoss = 0.0
    float grossProfit = 0.0
    float grossLoss = 0.0
    int longTrades = 0
    int shortTrades = 0
    int longWins = 0
    int shortWins = 0
    float longPnL = 0.0
    float shortPnL = 0.0
    float commission = 0.0
    float slippage = 0.0

// Initialize 10 Virtual Accounts (one for each signal)
var VirtualAccount virtualAccount1 = VirtualAccount.new()
var VirtualAccount virtualAccount2 = VirtualAccount.new()
var VirtualAccount virtualAccount3 = VirtualAccount.new()
var VirtualAccount virtualAccount4 = VirtualAccount.new()
var VirtualAccount virtualAccount5 = VirtualAccount.new()
var VirtualAccount virtualAccount6 = VirtualAccount.new()
var VirtualAccount virtualAccount7 = VirtualAccount.new()
var VirtualAccount virtualAccount8 = VirtualAccount.new()
var VirtualAccount virtualAccount9 = VirtualAccount.new()
var VirtualAccount virtualAccount10 = VirtualAccount.new()

// Array of virtual accounts for easy iteration
var array<VirtualAccount> virtualAccounts = array.from(virtualAccount1, virtualAccount2, virtualAccount3, virtualAccount4, virtualAccount5, virtualAccount6, virtualAccount7, virtualAccount8, virtualAccount9, virtualAccount10)

// Commission and Slippage Configuration
commissionPerTrade = input.float(2.50, 'ğŸ’° Commission Per Trade', minval=0.0, step=0.25, group='ğŸ’¼ Virtual Account Settings', tooltip='Commission cost per trade (both entry and exit)')
slippagePerTrade = input.float(0.50, 'ğŸ“‰ Slippage Per Trade', minval=0.0, step=0.25, group='ğŸ’¼ Virtual Account Settings', tooltip='Slippage cost per trade (market impact)')
virtualPositionSize = input.int(1, 'ğŸ“Š Virtual Position Size', minval=1, group='ğŸ’¼ Virtual Account Settings', tooltip='Position size for virtual accounts (contracts/shares)')

// Parameter Change Detection System
var int lastParameterHash = na
var bool parametersChanged = false

// Calculate parameter hash for change detection
calculateParameterHash() =>
    // Hash key parameters that affect backtesting
    hash = 0
    hash += commissionPerTrade * 1000
    hash += slippagePerTrade * 1000
    hash += virtualPositionSize * 100
    hash += signal1Enable ? 1 : 0
    hash += signal2Enable ? 2 : 0
    hash += signal3Enable ? 4 : 0
    hash += signal4Enable ? 8 : 0
    hash += signal5Enable ? 16 : 0
    hash += signal6Enable ? 32 : 0
    hash += signal7Enable ? 64 : 0
    hash += signal8Enable ? 128 : 0
    hash += signal9Enable ? 256 : 0
    hash += signal10Enable ? 512 : 0
    int(hash)

// Reset all virtual accounts when parameters change
resetVirtualAccounts() =>
    for i = 0 to array.size(virtualAccounts) - 1
        account = array.get(virtualAccounts, i)
        account.inPosition := false
        account.direction := "none"
        account.entryPrice := na
        account.currentPnL := 0.0
        account.totalPnL := 0.0
        account.totalTrades := 0
        account.winningTrades := 0
        account.maxDrawdown := 0.0
        account.peakPnL := 0.0
        account.troughPnL := 0.0
        account.largestWin := 0.0
        account.largestLoss := 0.0
        account.grossProfit := 0.0
        account.grossLoss := 0.0
        account.longTrades := 0
        account.shortTrades := 0
        account.longWins := 0
        account.shortWins := 0
        account.longPnL := 0.0
        account.shortPnL := 0.0
        account.commission := 0.0
        account.slippage := 0.0

// Check for parameter changes
currentParameterHash = calculateParameterHash()
if na(lastParameterHash) or lastParameterHash != currentParameterHash
    parametersChanged := true
    resetVirtualAccounts()
    lastParameterHash := currentParameterHash
    if debugEnabled
        debugMessage("SYSTEM", "Parameters changed - Virtual accounts reset", color.orange, color.white, 0.3)
else
    parametersChanged := false

// Virtual Account Trading Functions
processVirtualTrade(VirtualAccount account, bool longSignal, bool shortSignal, string signalName, int signalIndex) =>
    // Calculate point value for accurate P&L
    pointValue = syminfo.pointvalue * futuresMultiplier
    
    // Entry Logic
    if not account.inPosition
        if longSignal
            account.inPosition := true
            account.direction := "long"
            account.entryPrice := close
            account.totalTrades += 1
            account.longTrades += 1
            account.commission += commissionPerTrade
            account.slippage += slippagePerTrade
            if debugEnabled
                debugMessage("VIRTUAL", signalName + " Virtual Long Entry @ " + str.tostring(close), color.lime, color.white, 0.4)
        else if shortSignal
            account.inPosition := true
            account.direction := "short"
            account.entryPrice := close
            account.totalTrades += 1
            account.shortTrades += 1
            account.commission += commissionPerTrade
            account.slippage += slippagePerTrade
            if debugEnabled
                debugMessage("VIRTUAL", signalName + " Virtual Short Entry @ " + str.tostring(close), color.red, color.white, 0.4)
    
    // Update current P&L for open positions
    if account.inPosition
        if account.direction == "long"
            rawPnL = (close - account.entryPrice) * virtualPositionSize * pointValue
            account.currentPnL := rawPnL - account.commission - account.slippage
        else if account.direction == "short"
            rawPnL = (account.entryPrice - close) * virtualPositionSize * pointValue
            account.currentPnL := rawPnL - account.commission - account.slippage
        
        // Update peak and trough for drawdown calculation
        if account.currentPnL > account.peakPnL
            account.peakPnL := account.currentPnL
        if account.currentPnL < account.troughPnL
            account.troughPnL := account.currentPnL
        
        // Calculate current drawdown
        currentDrawdown = account.peakPnL - account.currentPnL
        if currentDrawdown > account.maxDrawdown
            account.maxDrawdown := currentDrawdown

// Exit Logic (simplified - using opposite signal as exit for now)
processVirtualExit(VirtualAccount account, bool exitSignal, string signalName, int signalIndex) =>
    if account.inPosition and exitSignal
        // Calculate final P&L
        pointValue = syminfo.pointvalue * futuresMultiplier
        if account.direction == "long"
            rawPnL = (close - account.entryPrice) * virtualPositionSize * pointValue
            finalPnL = rawPnL - commissionPerTrade - slippagePerTrade - account.commission - account.slippage
            account.longPnL += finalPnL
        else if account.direction == "short"
            rawPnL = (account.entryPrice - close) * virtualPositionSize * pointValue
            finalPnL = rawPnL - commissionPerTrade - slippagePerTrade - account.commission - account.slippage
            account.shortPnL += finalPnL
        
        // Update statistics
        account.totalPnL += finalPnL
        if finalPnL > 0
            account.winningTrades += 1
            account.grossProfit += finalPnL
            if account.direction == "long"
                account.longWins += 1
            else
                account.shortWins += 1
            if finalPnL > account.largestWin
                account.largestWin := finalPnL
        else
            account.grossLoss += math.abs(finalPnL)
            if finalPnL < account.largestLoss
                account.largestLoss := finalPnL
        
        // Reset position
        account.inPosition := false
        account.direction := "none"
        account.entryPrice := na
        account.currentPnL := 0.0
        account.commission := 0.0
        account.slippage := 0.0
        
        if debugEnabled
            debugMessage("VIRTUAL", signalName + " Virtual Exit @ " + str.tostring(close) + " P&L: $" + str.tostring(finalPnL, "#.##"), finalPnL > 0 ? color.lime : color.red, color.white, 0.5)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MULTI-SIGNAL INPUT SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SIGNAL SOURCE INPUTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
signal1Enable = input.bool(true, 'ğŸ“Š Signal 1', inline = 'sig1', group = 'ğŸ”„ Multi-Signals', tooltip = 'Primary signal source')
signal1LongSrc = input.source(close, 'Long', inline = 'sig1', group = 'ğŸ”„ Multi-Signals', tooltip = 'Connect to: LuxAlgo Long, UTBot Long, or any Long signal plot')
signal1ShortSrc = input.source(close, 'Short', inline = 'sig1', group = 'ğŸ”„ Multi-Signals', tooltip = 'Connect to: LuxAlgo Short, UTBot Short, or any Short signal plot')
signal1Name = input.string('LuxAlgo', 'Name', inline = 'sig1name', group = 'ğŸ”„ Multi-Signals')
signal1Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig1name', group = 'ğŸ”„ Multi-Signals')
signal1OnlyMode = input.bool(false, 'Only', inline = 'sig1only', group = 'ğŸ”„ Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')

signal2Enable = input.bool(false, 'ğŸ“Š Signal 2', inline = 'sig2', group = 'ğŸ”„ Multi-Signals')
signal2LongSrc = input.source(close, 'Long', inline = 'sig2', group = 'ğŸ”„ Multi-Signals', tooltip = 'Connect to: UTBot Long, Wonder Long, or any Long signal plot')
signal2ShortSrc = input.source(close, 'Short', inline = 'sig2', group = 'ğŸ”„ Multi-Signals', tooltip = 'Connect to: UTBot Short, Wonder Short, or any Short signal plot')
signal2Name = input.string('UTBot', 'Name', inline = 'sig2name', group = 'ğŸ”„ Multi-Signals')
signal2Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig2name', group = 'ğŸ”„ Multi-Signals')
signal2OnlyMode = input.bool(false, 'Only', inline = 'sig2only', group = 'ğŸ”„ Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')

signal3Enable = input.bool(false, 'ğŸ“Š Signal 3', inline = 'sig3', group = 'ğŸ”„ Multi-Signals')
signal3LongSrc = input.source(close, 'Long', inline = 'sig3', group = 'ğŸ”„ Multi-Signals')
signal3ShortSrc = input.source(close, 'Short', inline = 'sig3', group = 'ğŸ”„ Multi-Signals')
signal3Name = input.string('VIDYA', 'Name', inline = 'sig3name', group = 'ğŸ”„ Multi-Signals')
signal3Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig3name', group = 'ğŸ”„ Multi-Signals')
signal3OnlyMode = input.bool(false, 'Only', inline = 'sig3only', group = 'ğŸ”„ Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')

signal4Enable = input.bool(false, 'ğŸ“Š Signal 4', inline = 'sig4', group = 'ğŸ”„ Multi-Signals')
signal4LongSrc = input.source(close, 'Long', inline = 'sig4', group = 'ğŸ”„ Multi-Signals')
signal4ShortSrc = input.source(close, 'Short', inline = 'sig4', group = 'ğŸ”„ Multi-Signals')
signal4Name = input.string('KyleAlgo', 'Name', inline = 'sig4name', group = 'ğŸ”„ Multi-Signals')
signal4Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig4name', group = 'ğŸ”„ Multi-Signals')
signal4OnlyMode = input.bool(false, 'Only', inline = 'sig4only', group = 'ğŸ”„ Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')

signal5Enable = input.bool(false, 'ğŸ“Š Signal 5', inline = 'sig5', group = 'ğŸ”„ Multi-Signals')
signal5LongSrc = input.source(close, 'Long', inline = 'sig5', group = 'ğŸ”„ Multi-Signals')
signal5ShortSrc = input.source(close, 'Short', inline = 'sig5', group = 'ğŸ”„ Multi-Signals')
signal5Name = input.string('Wonder', 'Name', inline = 'sig5name', group = 'ğŸ”„ Multi-Signals')
signal5Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig5name', group = 'ğŸ”„ Multi-Signals')
signal5OnlyMode = input.bool(false, 'Only', inline = 'sig5only', group = 'ğŸ”„ Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')

signal6Enable = input.bool(false, 'ğŸ“Š Signal 6', inline = 'sig6', group = 'ğŸ”„ Multi-Signals')
signal6LongSrc = input.source(close, 'Long', inline = 'sig6', group = 'ğŸ”„ Multi-Signals')
signal6ShortSrc = input.source(close, 'Short', inline = 'sig6', group = 'ğŸ”„ Multi-Signals')
signal6Name = input.string('Signal 6', 'Name', inline = 'sig6name', group = 'ğŸ”„ Multi-Signals')
signal6Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig6name', group = 'ğŸ”„ Multi-Signals')
signal6OnlyMode = input.bool(false, 'Only', inline = 'sig6only', group = 'ğŸ”„ Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')

signal7Enable = input.bool(false, 'ğŸ“Š Signal 7', inline = 'sig7', group = 'ğŸ”„ Multi-Signals')
signal7LongSrc = input.source(close, 'Long', inline = 'sig7', group = 'ğŸ”„ Multi-Signals')
signal7ShortSrc = input.source(close, 'Short', inline = 'sig7', group = 'ğŸ”„ Multi-Signals')
signal7Name = input.string('Signal 7', 'Name', inline = 'sig7name', group = 'ğŸ”„ Multi-Signals')
signal7Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig7name', group = 'ğŸ”„ Multi-Signals')
signal7OnlyMode = input.bool(false, 'Only', inline = 'sig7only', group = 'ğŸ”„ Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')

signal8Enable = input.bool(false, 'ğŸ“Š Signal 8', inline = 'sig8', group = 'ğŸ”„ Multi-Signals')
signal8LongSrc = input.source(close, 'Long', inline = 'sig8', group = 'ğŸ”„ Multi-Signals')
signal8ShortSrc = input.source(close, 'Short', inline = 'sig8', group = 'ğŸ”„ Multi-Signals')
signal8Name = input.string('Signal 8', 'Name', inline = 'sig8name', group = 'ğŸ”„ Multi-Signals')
signal8Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig8name', group = 'ğŸ”„ Multi-Signals')
signal8OnlyMode = input.bool(false, 'Only', inline = 'sig8only', group = 'ğŸ”„ Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')

signal9Enable = input.bool(false, 'ğŸ“Š Signal 9', inline = 'sig9', group = 'ğŸ”„ Multi-Signals')
signal9LongSrc = input.source(close, 'Long', inline = 'sig9', group = 'ğŸ”„ Multi-Signals')
signal9ShortSrc = input.source(close, 'Short', inline = 'sig9', group = 'ğŸ”„ Multi-Signals')
signal9Name = input.string('Signal 9', 'Name', inline = 'sig9name', group = 'ğŸ”„ Multi-Signals')
signal9Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig9name', group = 'ğŸ”„ Multi-Signals')
signal9OnlyMode = input.bool(false, 'Only', inline = 'sig9only', group = 'ğŸ”„ Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')

signal10Enable = input.bool(false, 'ğŸ“Š Signal 10', inline = 'sig10', group = 'ğŸ”„ Multi-Signals')
signal10LongSrc = input.source(close, 'Long', inline = 'sig10', group = 'ğŸ”„ Multi-Signals')
signal10ShortSrc = input.source(close, 'Short', inline = 'sig10', group = 'ğŸ”„ Multi-Signals')
signal10Name = input.string('Signal 10', 'Name', inline = 'sig10name', group = 'ğŸ”„ Multi-Signals')
signal10Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig10name', group = 'ğŸ”„ Multi-Signals')
signal10OnlyMode = input.bool(false, 'Only', inline = 'sig10only', group = 'ğŸ”„ Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SIGNAL PROCESSING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Process signals directly - most indicators (UTBot, LuxAlgo) output pulse signals
// Handle both boolean and numeric signal types
// IMPORTANT: Only process real signals, not default 'close' values
// Simple direct signal detection - no complex change detection needed
// Check if any "Only Mode" is active (for individual signal testing)
anyOnlyModeActive = signal1OnlyMode or signal2OnlyMode or signal3OnlyMode or signal4OnlyMode or signal5OnlyMode or signal6OnlyMode or signal7OnlyMode or signal8OnlyMode or signal9OnlyMode or signal10OnlyMode

// Process all signals with "Only Mode" logic (FIXED - properly ignore 'close' as signal)
// Only trigger signals if the source is NOT the default 'close' AND the signal condition is met
sig1Long = signal1Enable and signal1LongSrc != close and (signal1LongSrc > 0 or bool(signal1LongSrc) == true)
sig1Short = signal1Enable and signal1ShortSrc != close and (signal1ShortSrc > 0 or bool(signal1ShortSrc) == true)
sig2Long = signal2Enable and signal2LongSrc != close and (signal2LongSrc > 0 or bool(signal2LongSrc) == true)
sig2Short = signal2Enable and signal2ShortSrc != close and (signal2ShortSrc > 0 or bool(signal2ShortSrc) == true)
sig3Long = signal3Enable and signal3LongSrc != close and (signal3LongSrc > 0 or bool(signal3LongSrc) == true)
sig3Short = signal3Enable and signal3ShortSrc != close and (signal3ShortSrc > 0 or bool(signal3ShortSrc) == true)
sig4Long = signal4Enable and signal4LongSrc != close and (signal4LongSrc > 0 or bool(signal4LongSrc) == true)
sig4Short = signal4Enable and signal4ShortSrc != close and (signal4ShortSrc > 0 or bool(signal4ShortSrc) == true)
sig5Long = signal5Enable and signal5LongSrc != close and (signal5LongSrc > 0 or bool(signal5LongSrc) == true)
sig5Short = signal5Enable and signal5ShortSrc != close and (signal5ShortSrc > 0 or bool(signal5ShortSrc) == true)
sig6Long = signal6Enable and signal6LongSrc != close and (signal6LongSrc > 0 or bool(signal6LongSrc) == true)
sig6Short = signal6Enable and signal6ShortSrc != close and (signal6ShortSrc > 0 or bool(signal6ShortSrc) == true)
sig7Long = signal7Enable and signal7LongSrc != close and (signal7LongSrc > 0 or bool(signal7LongSrc) == true)
sig7Short = signal7Enable and signal7ShortSrc != close and (signal7ShortSrc > 0 or bool(signal7ShortSrc) == true)
sig8Long = signal8Enable and signal8LongSrc != close and (signal8LongSrc > 0 or bool(signal8LongSrc) == true)
sig8Short = signal8Enable and signal8ShortSrc != close and (signal8ShortSrc > 0 or bool(signal8ShortSrc) == true)
sig9Long = signal9Enable and signal9LongSrc != close and (signal9LongSrc > 0 or bool(signal9LongSrc) == true)
sig9Short = signal9Enable and signal9ShortSrc != close and (signal9ShortSrc > 0 or bool(signal9ShortSrc) == true)
sig10Long = signal10Enable and signal10LongSrc != close and (signal10LongSrc > 0 or bool(signal10LongSrc) == true)
sig10Short = signal10Enable and signal10ShortSrc != close and (signal10ShortSrc > 0 or bool(signal10ShortSrc) == true)

// Apply "Only Mode" logic - if any "Only" is active, disable all signals except the one in "Only Mode"
if anyOnlyModeActive
    sig1Long := signal1OnlyMode ? sig1Long : false
    sig1Short := signal1OnlyMode ? sig1Short : false
    sig2Long := signal2OnlyMode ? sig2Long : false
    sig2Short := signal2OnlyMode ? sig2Short : false
    sig3Long := signal3OnlyMode ? sig3Long : false
    sig3Short := signal3OnlyMode ? sig3Short : false
    sig4Long := signal4OnlyMode ? sig4Long : false
    sig4Short := signal4OnlyMode ? sig4Short : false
    sig5Long := signal5OnlyMode ? sig5Long : false
    sig5Short := signal5OnlyMode ? sig5Short : false
    sig6Long := signal6OnlyMode ? sig6Long : false
    sig6Short := signal6OnlyMode ? sig6Short : false
    sig7Long := signal7OnlyMode ? sig7Long : false
    sig7Short := signal7OnlyMode ? sig7Short : false
    sig8Long := signal8OnlyMode ? sig8Long : false
    sig8Short := signal8OnlyMode ? sig8Short : false
    sig9Long := signal9OnlyMode ? sig9Long : false
    sig9Short := signal9OnlyMode ? sig9Short : false
    sig10Long := signal10OnlyMode ? sig10Long : false
    sig10Short := signal10OnlyMode ? sig10Short : false

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ SIGNAL ARRAYS FOR PROCESSING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Signal arrays for processing and count tracking (expanded to 10 signals)
allLongSignals = array.new<bool>(10)
allShortSignals = array.new<bool>(10)
array.set(allLongSignals, 0, sig1Long)
array.set(allLongSignals, 1, sig2Long)
array.set(allLongSignals, 2, sig3Long)
array.set(allLongSignals, 3, sig4Long)
array.set(allLongSignals, 4, sig5Long)
array.set(allLongSignals, 5, sig6Long)
array.set(allLongSignals, 6, sig7Long)
array.set(allLongSignals, 7, sig8Long)
array.set(allLongSignals, 8, sig9Long)
array.set(allLongSignals, 9, sig10Long)
array.set(allShortSignals, 0, sig1Short)
array.set(allShortSignals, 1, sig2Short)
array.set(allShortSignals, 2, sig3Short)
array.set(allShortSignals, 3, sig4Short)
array.set(allShortSignals, 4, sig5Short)
array.set(allShortSignals, 5, sig6Short)
array.set(allShortSignals, 6, sig7Short)
array.set(allShortSignals, 7, sig8Short)
array.set(allShortSignals, 8, sig9Short)
array.set(allShortSignals, 9, sig10Short)

// Count active signals (all 10 signals)
var int longSignalCount = 0
var int shortSignalCount = 0
longSignalCount := (sig1Long ? 1 : 0) + (sig2Long ? 1 : 0) + (sig3Long ? 1 : 0) + (sig4Long ? 1 : 0) + (sig5Long ? 1 : 0) + (sig6Long ? 1 : 0) + (sig7Long ? 1 : 0) + (sig8Long ? 1 : 0) + (sig9Long ? 1 : 0) + (sig10Long ? 1 : 0)
shortSignalCount := (sig1Short ? 1 : 0) + (sig2Short ? 1 : 0) + (sig3Short ? 1 : 0) + (sig4Short ? 1 : 0) + (sig5Short ? 1 : 0) + (sig6Short ? 1 : 0) + (sig7Short ? 1 : 0) + (sig8Short ? 1 : 0) + (sig9Short ? 1 : 0) + (sig10Short ? 1 : 0)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• VIRTUAL ACCOUNT PROCESSING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Process each signal through its corresponding virtual account
// This creates perfect signal attribution without interference

// Signal names array for debugging
signalNames = array.from(signal1Name, signal2Name, signal3Name, signal4Name, signal5Name, signal6Name, signal7Name, signal8Name, signal9Name, signal10Name)

// Process virtual trades for each signal
processVirtualTrade(virtualAccount1, sig1Long, sig1Short, signal1Name, 0)
processVirtualTrade(virtualAccount2, sig2Long, sig2Short, signal2Name, 1)
processVirtualTrade(virtualAccount3, sig3Long, sig3Short, signal3Name, 2)
processVirtualTrade(virtualAccount4, sig4Long, sig4Short, signal4Name, 3)
processVirtualTrade(virtualAccount5, sig5Long, sig5Short, signal5Name, 4)
processVirtualTrade(virtualAccount6, sig6Long, sig6Short, signal6Name, 5)
processVirtualTrade(virtualAccount7, sig7Long, sig7Short, signal7Name, 6)
processVirtualTrade(virtualAccount8, sig8Long, sig8Short, signal8Name, 7)
processVirtualTrade(virtualAccount9, sig9Long, sig9Short, signal9Name, 8)
processVirtualTrade(virtualAccount10, sig10Long, sig10Short, signal10Name, 9)

// Process virtual exits (using opposite signals for now - can be enhanced later)
processVirtualExit(virtualAccount1, sig1Short, signal1Name, 0)  // Long exit on short signal
processVirtualExit(virtualAccount2, sig2Short, signal2Name, 1)
processVirtualExit(virtualAccount3, sig3Short, signal3Name, 2)
processVirtualExit(virtualAccount4, sig4Short, signal4Name, 3)
processVirtualExit(virtualAccount5, sig5Short, signal5Name, 4)
processVirtualExit(virtualAccount6, sig6Short, signal6Name, 5)
processVirtualExit(virtualAccount7, sig7Short, signal7Name, 6)
processVirtualExit(virtualAccount8, sig8Short, signal8Name, 7)
processVirtualExit(virtualAccount9, sig9Short, signal9Name, 8)
processVirtualExit(virtualAccount10, sig10Short, signal10Name, 9)

// Also process short exits on long signals
if virtualAccount1.direction == "short" and sig1Long
    processVirtualExit(virtualAccount1, sig1Long, signal1Name, 0)
if virtualAccount2.direction == "short" and sig2Long
    processVirtualExit(virtualAccount2, sig2Long, signal2Name, 1)
if virtualAccount3.direction == "short" and sig3Long
    processVirtualExit(virtualAccount3, sig3Long, signal3Name, 2)
if virtualAccount4.direction == "short" and sig4Long
    processVirtualExit(virtualAccount4, sig4Long, signal4Name, 3)
if virtualAccount5.direction == "short" and sig5Long
    processVirtualExit(virtualAccount5, sig5Long, signal5Name, 4)
if virtualAccount6.direction == "short" and sig6Long
    processVirtualExit(virtualAccount6, sig6Long, signal6Name, 5)
if virtualAccount7.direction == "short" and sig7Long
    processVirtualExit(virtualAccount7, sig7Long, signal7Name, 6)
if virtualAccount8.direction == "short" and sig8Long
    processVirtualExit(virtualAccount8, sig8Long, signal8Name, 7)
if virtualAccount9.direction == "short" and sig9Long
    processVirtualExit(virtualAccount9, sig9Long, signal9Name, 8)
if virtualAccount10.direction == "short" and sig10Long
    processVirtualExit(virtualAccount10, sig10Long, signal10Name, 9)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PRIMARY SIGNAL COMBINATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Note: Primary signals are defined below after imports (line 126-127)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RBW FILTER IMPORT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Import enhanced_ta library for existing RBW filter (defined later)
import HeWhoMustNotBeNamed/enhanced_ta/14 as eta

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIGNAL PROCESSING SETUP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Legacy compatibility - combine all signals (expanded to 10 signals)
primaryLongSig = sig1Long or sig2Long or sig3Long or sig4Long or sig5Long or sig6Long or sig7Long or sig8Long or sig9Long or sig10Long
primaryShortSig = sig1Short or sig2Short or sig3Short or sig4Short or sig5Short or sig6Short or sig7Short or sig8Short or sig9Short or sig10Short

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 1 Â· TRADERSPOST JSON HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€ Pre-built JSON messages (compile-time constants) â”€â”€â”€â”€â”€
// Use TradingView alert placeholders so we avoid any per-bar string operations.
// Placeholders {{close}} and {{timenow}} will be expanded at alert trigger time.
var string _jsonBase = '{"ticker":"' + syminfo.ticker + '","price":{{close}},"time":{{timenow}}'

var string longEntryMsg = _jsonBase + ',"action":"buy","sentiment":"long"}'
var string shortEntryMsg = _jsonBase + ',"action":"sell","sentiment":"short"}'
var string flatExitMsg = _jsonBase + ',"action":"exit","sentiment":"flat"}'
var string longExitMsg = _jsonBase + ',"action":"sell","sentiment":"flat"}' // closes long
var string shortExitMsg = _jsonBase + ',"action":"buy","sentiment":"flat"}' // closes short

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 2 Â· ATR SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
atrLen = input.int(14, 'ATR Length', minval = 1, group = 'ATR Settings')
atrVal = ta.atr(atrLen)
// Extract ta.sma calculation for volatility alert (fixes compilation warning)
atrAvg = ta.sma(atrVal, 20)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 3 Â· EXIT PARAMETERS (ASCII SAFE) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
maExitOn = input.bool(false, 'Enable MA Exit', group = 'ğŸ“ˆ MA Exit')
maLen = input.int(21, 'MA Length', minval = 1, group = 'ğŸ“ˆ MA Exit')
maType = input.string('EMA', 'MA Type', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA'], group = 'ğŸ“ˆ MA Exit')
// Intrabar exits removed - exits only trigger once per bar on close

priceMA = maType == 'SMA' ? ta.sma(close, maLen) : maType == 'EMA' ? ta.ema(close, maLen) : maType == 'WMA' ? ta.wma(close, maLen) : maType == 'VWMA' ? ta.vwma(close, maLen) : ta.rma(close, maLen)

fixedEnable = input.bool(false, 'Enable Fixed SL/TP', group = 'ğŸ¯ Fixed SL/TP')
fixedUnit = input.string('ATR', 'Unit', options = ['ATR', 'Points'], group = 'ğŸ¯ Fixed SL/TP')
fixedStop = input.float(1.0, 'Stop Size', step = 0.1, minval = 0.0, group = 'ğŸ¯ Fixed SL/TP')

tpCalc(d) =>
    fixedUnit == 'ATR' ? d * atrVal : d

tp1Enable = input.bool(false, 'TP1', inline = 'tp1', group = 'ğŸ¯ Fixed SL/TP')
tp1Size = input.float(1.5, '', inline = 'tp1', group = 'ğŸ¯ Fixed SL/TP')
tp2Enable = input.bool(false, 'TP2', inline = 'tp2', group = 'ğŸ¯ Fixed SL/TP')
tp2Size = input.float(3.0, '', inline = 'tp2', group = 'ğŸ¯ Fixed SL/TP')
tp3Enable = input.bool(false, 'TP3', inline = 'tp3', group = 'ğŸ¯ Fixed SL/TP')
tp3Size = input.float(4.0, '', inline = 'tp3', group = 'ğŸ¯ Fixed SL/TP')

// Smart Profit Locker (Aggressive Profit Protection)
smartProfitEnable = input.bool(true, 'ğŸ¯ Enable Smart Profit Locker', group = 'Smart Profit Locker', tooltip = 'Aggressive profit-taking with adjustable pullback sensitivity')
smartProfitType = input.string('ATR', 'Type', options = ['ATR', 'Points', 'Percent'], group = 'Smart Profit Locker')
smartProfitVal = input.float(3.1, 'Value', step = 0.1, group = 'Smart Profit Locker')
smartProfitOffset = input.float(0.10, 'Pullback %', step = 0.05, minval = 0.01, maxval = 1.0, group = 'Smart Profit Locker', tooltip = 'Pullback percentage to trigger exit (0.10 = 10%)')

// TREND CHANGE EXIT SYSTEM
// Simple and effective: exit when any enabled trend indicator gives opposite signal
trendChangeExitEnable = input.bool(false, 'ğŸ“ˆ Enable Trend Change Exit', group = 'EXIT STRATEGY: Trend Change Exit', tooltip = 'Exit when any enabled trend signal gives opposite direction. Uses the 5 Trend Signals configured below.')

// HYBRID EXIT SYSTEM
// Automatically switch between Smart Profit Locker and Trend Change Exit based on position size
hybridExitEnable = input.bool(false, 'ğŸ”„ Enable Hybrid Exit', group = 'ğŸ”„ Hybrid Exit System', tooltip = 'Automatically use Smart Profit Locker for small positions, Trend Change Exit for larger positions (confluence-based)')
hybridSwitchThreshold = input.int(2, 'Switch at Contracts', minval=1, maxval=10, group = 'ğŸ”„ Hybrid Exit System', tooltip='Number of contracts to switch from Smart Profit Locker to Trend Change Exit (default: 2 = confluence detected)')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADVANCED TREND EXIT SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Linear Regression Candle-based exit with trailing stop protection and re-entry logic

// Enable Trend Exit Modes
trendExitEnable = input.bool(false, 'ğŸ¯ Enable Advanced Trend Exit', group = 'ğŸ¯ Advanced Trend Exit', tooltip = 'Advanced exit system based on Linear Regression Candles with trailing stop protection')
hybridModeEnable = input.bool(false, 'ğŸ”„ Activate Hybrid Mode', group = 'ğŸ¯ Advanced Trend Exit', tooltip = 'Use this exit system in Hybrid mode (switches based on position size)')

// Phase 1: Initial Trailing Stop Protection
initialTrailingStop = input.float(3.5, 'Initial Trailing Stop (ATR)', step=0.1, minval=1.0, maxval=10.0, group = 'ğŸ¯ Advanced Trend Exit', tooltip = 'ATR multiplier for initial trailing stop protection before switching to candle exit mode')

// Phase 2: Exit Mode Selection  
exitMode = input.string('Color Change', 'Exit Signal Type', options=['Color Change', 'MA Cross'], group = 'ğŸ¯ Advanced Trend Exit', tooltip = 'Color Change = Exit on Linear Regression candle color change | MA Cross = Exit on Bull/Bear MA crosses')

// Phase 3: Re-Entry System
reEntryEnable = input.bool(false, 'ğŸ”„ Enable Re-Entry', group = 'ğŸ¯ Advanced Trend Exit', tooltip = 'After color change exit, re-enter when color changes back (if trend indicators confirm)')
reEntryConfirmation = input.string('Majority', 'Re-Entry Confirmation', options=['All', 'Majority'], group = 'ğŸ¯ Advanced Trend Exit', tooltip = 'Require All (3/3) or Majority (2/3) trend indicators to confirm re-entry direction')

// Linear Regression Candle Inputs (Primary Exit Signal)
lrcBullColorChange = input.source(close, 'ğŸŸ¢ Bull Color Change', group = 'ğŸ“Š Linear Regression Candles', tooltip = 'Connect to Linear Regression Candles Bull Color Change plot')
lrcBearColorChange = input.source(close, 'ğŸ”´ Bear Color Change', group = 'ğŸ“Š Linear Regression Candles', tooltip = 'Connect to Linear Regression Candles Bear Color Change plot')
lrcBullMAXross = input.source(close, 'ğŸ“ˆ Bull MA Cross', group = 'ğŸ“Š Linear Regression Candles', tooltip = 'Connect to Linear Regression Candles Bull MA Cross plot')
lrcBearMACross = input.source(close, 'ğŸ“‰ Bear MA Cross', group = 'ğŸ“Š Linear Regression Candles', tooltip = 'Connect to Linear Regression Candles Bear MA Cross plot')

// Supporting Trend Indicators (Reduced from 5 to 3)
trend1Enable = input.bool(false, 'ğŸ“ˆ Trend 1: Adaptive SuperTrend', inline = 'trend1', group = 'ğŸ¯ Supporting Trend Indicators', tooltip = 'Adaptive SuperTrend for trend confirmation')
trend1LongSrc = input.source(close, 'Long', inline = 'trend1', group = 'ğŸ¯ Supporting Trend Indicators')
trend1ShortSrc = input.source(close, 'Short', inline = 'trend1', group = 'ğŸ¯ Supporting Trend Indicators')

trend2Enable = input.bool(false, 'ğŸ“ˆ Trend 2: Custom', inline = 'trend2', group = 'ğŸ¯ Supporting Trend Indicators', tooltip = 'Custom trend indicator for additional confirmation')
trend2LongSrc = input.source(close, 'Long', inline = 'trend2', group = 'ğŸ¯ Supporting Trend Indicators')
trend2ShortSrc = input.source(close, 'Short', inline = 'trend2', group = 'ğŸ¯ Supporting Trend Indicators')

trend3Enable = input.bool(false, 'ğŸ“ˆ Trend 3: Custom', inline = 'trend3', group = 'ğŸ¯ Supporting Trend Indicators', tooltip = 'Custom trend indicator for additional confirmation')
trend3LongSrc = input.source(close, 'Long', inline = 'trend3', group = 'ğŸ¯ Supporting Trend Indicators')
trend3ShortSrc = input.source(close, 'Short', inline = 'trend3', group = 'ğŸ¯ Supporting Trend Indicators')

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 4. SMART PROFIT LOCKER (Aggressive Profit Protection) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HYBRID EXIT INTEGRATION: Switch between Smart Profit Locker and Trend Change Exit

// SMART PROFIT LOCKER - SIMPLIFIED  
// Smart Profit Locker: Original logic + Hybrid Exit integration
shouldRunSPL = smartProfitEnable and strategy.position_size != 0
if hybridExitActive
    shouldRunSPL := hybridUsingSPL  // Hybrid system overrides SPL decision
    
if shouldRunSPL
    // Calculate Smart Profit Locker distance and offset
    smartDistance := smartProfitType == 'ATR' ? smartProfitVal * atrVal : smartProfitType == 'Points' ? smartProfitVal : strategyEntryPrice * smartProfitVal / 100.0
    smartOffset := smartDistance * math.max(smartProfitOffset, 0.01)
    
    // Ensure distances are valid
    if na(smartDistance) or smartDistance <= 0
        smartDistance := 50.0  // Safe default value in points
    if na(smartOffset) or smartOffset <= 0
        smartOffset := 5.0  // Safe default offset
    
    if strategy.position_size > 0  // Long position
        strategy.exit('Smart-Long', from_entry='Long', trail_points=math.max(smartDistance, 0.01), trail_offset=math.max(smartOffset, 0.01), comment='Smart Profit Locker')
        if not trailExitSent
            trailExitSent := true
            debugMessage("INFO", "ğŸ¯ Smart Profit Locker activated - Distance: " + str.tostring(smartDistance, "#.##") + " pts", color.green, color.white, 0.05)
    else if strategy.position_size < 0  // Short position
        strategy.exit('Smart-Short', from_entry='Short', trail_points=math.max(smartDistance, 0.01), trail_offset=math.max(smartOffset, 0.01), comment='Smart Profit Locker')
        if not trailExitSent
            trailExitSent := true
            debugMessage("INFO", "ğŸ¯ Smart Profit Locker activated - Distance: " + str.tostring(smartDistance, "#.##") + " pts", color.green, color.white, 0.05)

// OLD TREND CHANGE EXIT SYSTEM - REMOVED
// This old system was interfering with the new Advanced Trend Exit System
// All trend change exit logic is now handled by the Advanced Trend Exit System below

// RBW DIRECTIONAL FILTER
// Compact multi-column panel for volatility-based directional bias
rbwEnable = input.bool(false, 'ğŸ“Š Enable RBW Filter', group='ğŸ“Š Relative Bandwidth Filter', inline='rbw0')

// Band Type Selection (Row 1)
rbwBandType = input.string("KC", "Band Type", group='ğŸ“Š Relative Bandwidth Filter', options=["BB", "KC", "DC"], inline='rbw1')
rbwSource = input.source(close, "Source", group='ğŸ“Š Relative Bandwidth Filter', inline='rbw1')

// Band Parameters (Row 2) 
rbwLength = input.int(100, "Length", group='ğŸ“Š Relative Bandwidth Filter', inline='rbw2')
rbwMultiplier = input.float(2.0, "Mult", step=0.5, group='ğŸ“Š Relative Bandwidth Filter', inline='rbw2')

// Additional Options (Row 3)
rbwUseTR = input.bool(true, "Use TR", group='ğŸ“Š Relative Bandwidth Filter', inline='rbw3')
rbwUseAltSrc = input.bool(false, "Alt Src", group='ğŸ“Š Relative Bandwidth Filter', inline='rbw3')

// Signal Configuration (Row 4)
rbwDesiredCond = input.string("Higher Bandwidth", "Condition", group='ğŸ“Š Relative Bandwidth Filter', options=["Higher Bandwidth", "Lower Bandwidth"], inline='rbw4')
rbwRefBand = input.string("Middle", "Reference", group='ğŸ“Š Relative Bandwidth Filter', options=["Upper", "Lower", "Middle"], inline='rbw4')

// ATR and Filter Settings (Row 5)
rbwATRLength = input.int(20, "ATR Len", group='ğŸ“Š Relative Bandwidth Filter', inline='rbw5')
rbwBBType = input.string("sma", "BB Type", group='ğŸ“Š Relative Bandwidth Filter', options=["sma", "ema", "hma", "rma", "wma", "vwma", "linreg", "median"], inline='rbw5')

// OLD TREND SIGNAL SYSTEM - REPLACED BY ADVANCED TREND EXIT SYSTEM
// This section is kept for compatibility with existing exit logic but will be phased out

// Trend logic simplified: ALL enabled filters must agree (no more voting system)

// BOLLINGER BAND RISK MANAGEMENT
// Critical risk management: Never take signals outside Bollinger Bands

// Bollinger Band Entry Filter (Row 1) - RISK MANAGEMENT
bbEntryFilterEnable = input.bool(false, 'ğŸš« BB Entry Filter', group='ğŸ¯ Bollinger Band Risk Management', inline='bb1', tooltip='Ignore buy signals above upper BB and sell signals below lower BB. Prevents gap-open disasters.')
bbLength = input.int(20, 'BB Length', minval=5, maxval=50, group='ğŸ¯ Bollinger Band Risk Management', inline='bb1', tooltip='Bollinger Band period for entry filtering. Standard is 20.')
bbMultiplier = input.float(3.0, 'BB Mult', minval=1.0, maxval=5.0, step=0.1, group='ğŸ¯ Bollinger Band Risk Management', inline='bb1', tooltip='Bollinger Band standard deviation multiplier. Default is 3.0.')

// Bollinger Band Exit Logic (Row 2) - OPTIONAL TESTING FEATURE
bbExitEnable = input.bool(false, 'âš¡ BB Exit Logic', group='ğŸ¯ Bollinger Band Risk Management', inline='bb2', tooltip='OPTIONAL: When price hits BB extreme during trade, flip to tight Smart Profit Locker. OFF by default - for testing only.')
bbExitTightness = input.float(0.5, 'Tight Multiplier', minval=0.1, maxval=1.0, step=0.1, group='ğŸ¯ Bollinger Band Risk Management', inline='bb2', tooltip='Smart Profit Locker multiplier when BB exit triggers. 0.5 = half normal distance (tighter). Lower = more aggressive profit taking.')

// RBW Calculation Logic - Variable Declarations
var float rbwUpper = na
var float rbwLower = na
var float rbwMiddle = na
var float rbwRelativeBandwidth = na
var int rbwSignal = 0
var float rbwBBMiddle = na
var float rbwBBUpper = na
var float rbwBBLower = na
var float rbwRef = na
var float rbwStdDev = na
var float rbwATR = na

if rbwEnable
    // Bollinger Bands
    if rbwBandType == "BB"
        rbwMiddle := ta.sma(rbwSource, rbwLength)
        rbwStdDev := ta.stdev(rbwSource, rbwLength)
        rbwUpper := rbwMiddle + rbwStdDev * rbwMultiplier
        rbwLower := rbwMiddle - rbwStdDev * rbwMultiplier
    
    // Keltner Channels  
    else if rbwBandType == "KC"
        rbwMiddle := ta.sma(rbwSource, rbwLength)
        rbwATR := rbwUseTR ? ta.atr(rbwLength) : ta.rma(high - low, rbwLength)
        rbwUpper := rbwMiddle + rbwATR * rbwMultiplier
        rbwLower := rbwMiddle - rbwATR * rbwMultiplier
    
    // Donchian Channels
    else if rbwBandType == "DC"
        rbwUpper := ta.highest(rbwUseAltSrc ? high : rbwSource, rbwLength)
        rbwLower := ta.lowest(rbwUseAltSrc ? low : rbwSource, rbwLength)
        rbwMiddle := (rbwUpper + rbwLower) / 2
        rbwATR := ta.atr(rbwATRLength)

    // Relative Bandwidth calculation
    if not na(rbwUpper) and not na(rbwLower)
        // Use pre-calculated ATR
        if not na(rbwATR) and rbwATR > 0
            rbwRelativeBandwidth := (rbwUpper - rbwLower) / rbwATR
            
            // Calculate reference bands for signal (use extracted TA functions)
            rbwBBMiddle := ta.sma(rbwRelativeBandwidth, 100)
            rbwBBUpper := rbwBBMiddle + ta.stdev(rbwRelativeBandwidth, 100) * 1.0
            rbwBBLower := rbwBBMiddle - ta.stdev(rbwRelativeBandwidth, 100) * 1.0
            
            rbwRef := rbwRefBand == "Middle" ? rbwBBMiddle : rbwRefBand == "Upper" ? rbwBBUpper : rbwBBLower
            rbwSignal := rbwRelativeBandwidth > rbwRef ? 2 : 0
            rbwSignal := rbwDesiredCond == "Lower Bandwidth" ? math.abs(rbwSignal-2) : rbwSignal

// BOLLINGER BAND RISK MANAGEMENT CALCULATION
// Critical entry filtering: Never take signals outside Bollinger Bands

// Bollinger Band Variables
var float bbUpper = na
var float bbLower = na
var float bbMiddle = na
var bool bbEntryFilterOK = true
var bool bbExitTriggered = false

if bbEntryFilterEnable
    // Calculate standard Bollinger Bands for entry filtering
    bbMiddle := ta.sma(close, bbLength)
    bbStdDev = ta.stdev(close, bbLength)
    bbUpper := bbMiddle + bbStdDev * bbMultiplier
    bbLower := bbMiddle - bbStdDev * bbMultiplier
    
    // Entry filter logic: Block signals outside bands
    bbLongFilterOK := close <= bbUpper  // Allow long entries only when price is NOT above upper band
    bbShortFilterOK := close >= bbLower  // Allow short entries only when price is NOT below lower band
    
    // Debug output for BB entry filter
    if debugEnabled
        if not bbLongFilterOK
            debugMessage("WARN", "ğŸš« BB ENTRY FILTER: Long signal blocked - Price $" + str.tostring(close, "#.##") + " above upper BB $" + str.tostring(bbUpper, "#.##") + " - Gap/spike protection active", color.orange, color.white, 0.15)
        if not bbShortFilterOK
            debugMessage("WARN", "ğŸš« BB ENTRY FILTER: Short signal blocked - Price $" + str.tostring(close, "#.##") + " below lower BB $" + str.tostring(bbLower, "#.##") + " - Gap/spike protection active", color.orange, color.white, 0.15)
else
    // When disabled, allow all entries
    bbLongFilterOK := true
    bbShortFilterOK := true

// Optional BB Exit Logic (for testing)
if bbExitEnable and strategy.position_size != 0
    // Check if price hits BB extreme during trade
    longAtUpperBB = strategy.position_size > 0 and close >= bbUpper
    shortAtLowerBB = strategy.position_size < 0 and close <= bbLower
    
    if longAtUpperBB or shortAtLowerBB
        bbExitTriggered := true
        if debugEnabled
            exitType = longAtUpperBB ? "Long at Upper BB" : "Short at Lower BB"
            debugMessage("INFO", "âš¡ BB EXIT TRIGGER: " + exitType + " - Switching to tight Smart Profit Locker", color.green, color.white, 0.05)
else
    bbExitTriggered := false

// OLD TREND SIGNAL PROCESSING - REPLACED BY ADVANCED TREND EXIT SYSTEM
// Keeping minimal compatibility variables
var bool trend1Long = false
var bool trend1Short = false
var bool trend2Long = false  
var bool trend2Short = false
var bool trend3Long = false
var bool trend3Short = false
var int trend1Signal = 0
var int trend2Signal = 0
var int trend3Signal = 0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LINEAR REGRESSION CANDLE PROCESSING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Process Linear Regression Candle signals for advanced trend exit

// Process LRC signals (ignore default 'close' values)
lrcBullColor = lrcBullColorChange != close and (lrcBullColorChange > 0 or bool(lrcBullColorChange) == true)
lrcBearColor = lrcBearColorChange != close and (lrcBearColorChange > 0 or bool(lrcBearColorChange) == true)
lrcBullMA = lrcBullMAXross != close and (lrcBullMAXross > 0 or bool(lrcBullMAXross) == true)
lrcBearMA = lrcBearMACross != close and (lrcBearMACross > 0 or bool(lrcBearMACross) == true)

// Supporting trend indicators (reduced to 3)
supportTrend1Long = trend1Enable and trend1Long
supportTrend1Short = trend1Enable and trend1Short
supportTrend2Long = trend2Enable and trend2Long  
supportTrend2Short = trend2Enable and trend2Short
supportTrend3Long = trend3Enable and trend3Long
supportTrend3Short = trend3Enable and trend3Short

// Count supporting trend indicators for re-entry confirmation
enabledTrendCount = (trend1Enable ? 1 : 0) + (trend2Enable ? 1 : 0) + (trend3Enable ? 1 : 0)
bullishTrendCount = (supportTrend1Long ? 1 : 0) + (supportTrend2Long ? 1 : 0) + (supportTrend3Long ? 1 : 0)
bearishTrendCount = (supportTrend1Short ? 1 : 0) + (supportTrend2Short ? 1 : 0) + (supportTrend3Short ? 1 : 0)

// Determine trend confirmation for re-entry
trendConfirmsLong = enabledTrendCount == 0 ? true : reEntryConfirmation == 'All' ? bullishTrendCount == enabledTrendCount : bullishTrendCount >= math.ceil(enabledTrendCount / 2.0)

trendConfirmsShort = enabledTrendCount == 0 ? true : reEntryConfirmation == 'All' ? bearishTrendCount == enabledTrendCount : bearishTrendCount >= math.ceil(enabledTrendCount / 2.0)

// HYBRID EXIT SYSTEM LOGIC
// Automatically choose exit strategy based on position size (confluence indicator)
hybridExitActive := hybridExitEnable and strategy.position_size != 0
currentPositionSize = math.abs(strategy.position_size)

if hybridExitActive
    // Determine which exit strategy to use based on position size
    if currentPositionSize >= hybridSwitchThreshold
        // Large position (confluence detected) = Trend Change Exit
        hybridUsingSPL := false
        hybridUsingTCE := true
    else
        // Small position (single signal) = Smart Profit Locker  
        hybridUsingSPL := true
        hybridUsingTCE := false
else
    // Reset hybrid flags when not active
    hybridUsingSPL := false
    hybridUsingTCE := false

// SIMPLIFIED BIAS LOGIC - ONLY RBW FILTER
// Removed complex trend signal consensus - using position size for confluence instead
// Only RBW (Relative Bandwidth) provides directional bias filtering

longDirectionalBias = rbwEnable ? (rbwSignal == 2) : true    // RBW bullish or disabled (permissive)  
shortDirectionalBias = rbwEnable ? (rbwSignal == 0) : true   // RBW bearish or disabled (permissive)

// TEMPORARY TEST OVERRIDE (recommended by AI analysis) - Set to false after confirming signals work
testModeOverride = input.bool(true, "ğŸ§ª Test Mode Override", group="ğŸ› ï¸ Debug System", tooltip="Temporarily override all filters to allow trades for testing")
if testModeOverride
    longDirectionalBias := true
    shortDirectionalBias := true

// TREND-RIDING OVERLAY LOGIC
// Advanced exit system to "let winners run" in strong trending conditions

// Define final entry signals with directional bias and Bollinger Band Filter applied
longEntrySignal := primaryLongSig and longDirectionalBias and bbLongFilterOK
shortEntrySignal := primaryShortSig and shortDirectionalBias and bbShortFilterOK

// Add re-entry signals to entry logic
if reEntrySignal and exitDirection == 1  // Re-entering long
    longEntrySignal := true
else if reEntrySignal and exitDirection == -1  // Re-entering short  
    shortEntrySignal := true

// Visual indicators for Advanced Trend Exit System
plotchar(inTrendExitMode, title='ğŸ¯ Trend Exit Mode', char='ğŸ¯', location=location.top, color=color.new(color.blue, 0), size=size.small)
plotchar(inProfitMode, title='ğŸ’° Profit Mode', char='ğŸ’°', location=location.top, color=color.new(color.green, 0), size=size.small)
plotchar(waitingForReEntry, title='â³ Waiting Re-Entry', char='â³', location=location.top, color=color.new(color.orange, 0), size=size.small)
plotchar(colorChangeExit, title='ğŸ”„ Color Change Exit', char='ğŸ”„', location=location.top, color=color.new(color.red, 0), size=size.small)
plotchar(reEntrySignal, title='ğŸš€ Re-Entry Signal', char='ğŸš€', location=location.top, color=color.new(color.purple, 0), size=size.small)

// Plot Linear Regression Candle signals for visibility
plotchar(lrcBullColor, title='ğŸŸ¢ LRC Bull Color', char='ğŸŸ¢', location=location.bottom, color=color.new(color.lime, 0), size=size.tiny)
plotchar(lrcBearColor, title='ğŸ”´ LRC Bear Color', char='ğŸ”´', location=location.bottom, color=color.new(color.red, 0), size=size.tiny)
plotchar(lrcBullMA, title='ğŸ“ˆ LRC Bull MA', char='ğŸ“ˆ', location=location.bottom, color=color.new(color.blue, 0), size=size.tiny)
plotchar(lrcBearMA, title='ğŸ“‰ LRC Bear MA', char='ğŸ“‰', location=location.bottom, color=color.new(color.maroon, 0), size=size.tiny)

// TEMPORARY DEBUG PLOTS (recommended by AI analysis) - Remove after confirming signals work
plotchar(sig1Long, title="Sig1Long", char='1', location=location.bottom, color=color.yellow, size=size.tiny)
plotchar(primaryLongSig, title="PrimaryLong", char='â—', location=location.bottom, color=color.orange, size=size.tiny)
plotchar(longDirectionalBias, title="LongBias", char='B', location=location.bottom, color=color.blue, size=size.tiny)
plotchar(longEntrySignal, title="LongFinal", char='â†‘', location=location.bottom, color=color.lime, size=size.small)

// Debug warnings when Bollinger Band filter blocks trades (critical risk management)
if debugEnabled and bbEntryFilterEnable
    if primaryLongSig and longDirectionalBias and not bbLongFilterOK
        debugMessage("WARN", "ğŸš« BB FILTER BLOCKED LONG: Price " + str.tostring(close, "#.##") + " above upper BB " + str.tostring(bbUpper, "#.##") + " - Gap/spike protection active", color.orange, color.white, 0.15)
    if primaryShortSig and shortDirectionalBias and not bbShortFilterOK
        debugMessage("WARN", "ğŸš« BB FILTER BLOCKED SHORT: Price " + str.tostring(close, "#.##") + " below lower BB " + str.tostring(bbLower, "#.##") + " - Gap/spike protection active", color.orange, color.white, 0.15)

// Enhanced debug logging for all directional bias filters and systems  
if debugEnabled
    // Debug entry signals
    if primaryLongSig or primaryShortSig
        entryMsg = 'ENTRY SIGNALS: Long=' + str.tostring(primaryLongSig) + ' Short=' + str.tostring(primaryShortSig)
        entryMsg += ' | LongBias=' + str.tostring(longDirectionalBias) + ' ShortBias=' + str.tostring(shortDirectionalBias)
        entryMsg += ' | BBFilter: L=' + str.tostring(bbLongFilterOK) + ' S=' + str.tostring(bbShortFilterOK)
        entryMsg += ' | Final: L=' + str.tostring(longEntrySignal) + ' S=' + str.tostring(shortEntrySignal)
        debugMessage("INFO", entryMsg, color.blue, color.white, 0.05)
    
    // Debug Advanced Trend Exit System
    if useAdvancedTrendExit
        trendExitMsg = 'ADVANCED TREND EXIT:'
        trendExitMsg += ' Mode=' + (inTrendExitMode ? 'ACTIVE' : 'OFF')
        trendExitMsg += ' Phase=' + (not inTrendExitMode ? 'NONE' : inProfitMode ? 'PROFIT' : 'PROTECTION')
        trendExitMsg += ' Exit=' + exitMode
        if waitingForReEntry
            trendExitMsg += ' | WAITING_RE-ENTRY (Dir=' + str.tostring(exitDirection) + ')'
        debugMessage("INFO", trendExitMsg, color.purple, color.white, 0.05)
        
        // Debug LRC signals
        if lrcBullColor or lrcBearColor or lrcBullMA or lrcBearMA
            lrcMsg = 'LRC SIGNALS:'
            lrcMsg += ' BullColor=' + str.tostring(lrcBullColor)
            lrcMsg += ' BearColor=' + str.tostring(lrcBearColor) 
            lrcMsg += ' BullMA=' + str.tostring(lrcBullMA)
            lrcMsg += ' BearMA=' + str.tostring(lrcBearMA)
            debugMessage("INFO", lrcMsg, color.yellow, color.black, 0.05)
        
        // Debug trend confirmation
        if enabledTrendCount > 0
            confirmMsg = 'TREND CONFIRMATION:'
            confirmMsg += ' Enabled=' + str.tostring(enabledTrendCount)
            confirmMsg += ' Bull=' + str.tostring(bullishTrendCount) + '/' + str.tostring(enabledTrendCount)
            confirmMsg += ' Bear=' + str.tostring(bearishTrendCount) + '/' + str.tostring(enabledTrendCount)
            confirmMsg += ' ConfirmLong=' + str.tostring(trendConfirmsLong)
            confirmMsg += ' ConfirmShort=' + str.tostring(trendConfirmsShort)
            debugMessage("INFO", confirmMsg, color.orange, color.white, 0.05)
    
    // Show new trend signal system status
    trendStatusMsg = 'TREND SIGNALS:'
    trendStatusMsg += ' T1=' + (trend1Enable ? (trend1Signal == 1 ? 'BULL' : trend1Signal == -1 ? 'BEAR' : 'NEUT') : 'OFF')
    trendStatusMsg += ' T2=' + (trend2Enable ? (trend2Signal == 1 ? 'BULL' : trend2Signal == -1 ? 'BEAR' : 'NEUT') : 'OFF')  
    trendStatusMsg += ' T3=' + (trend3Enable ? (trend3Signal == 1 ? 'BULL' : trend3Signal == -1 ? 'BEAR' : 'NEUT') : 'OFF')
    trendStatusMsg += ' RBW=' + (rbwEnable ? (rbwSignal == 2 ? 'BULL' : rbwSignal == 0 ? 'BEAR' : 'NEUT') : 'OFF')
    trendStatusMsg += ' BB=' + (bbEntryFilterEnable ? ('L:' + (bbLongFilterOK ? 'OK' : 'BLOCK') + ' S:' + (bbShortFilterOK ? 'OK' : 'BLOCK')) : 'OFF')
    debugMessage("INFO", trendStatusMsg, color.green, color.white, 0.05)
    
    // Show simplified bias status (RBW only now)
    consensusMsg = 'BIAS STATUS: RBW-Only Filter | RBW=' + (rbwEnable ? (rbwSignal == 2 ? 'BULL' : rbwSignal == 0 ? 'BEAR' : 'NEUT') : 'OFF')
    consensusMsg += ' | Final: Long=' + (longDirectionalBias ? 'ALLOW' : 'BLOCK') + ' Short=' + (shortDirectionalBias ? 'ALLOW' : 'BLOCK')
    debugMessage("INFO", consensusMsg, color.green, color.white, 0.05)
    
    // Show trend change exit system status
    if trendChangeExitEnable
        trendChangeMsg = 'TREND CHANGE EXIT: Status=' + (trendChangeExitEnable ? 'ENABLED' : 'DISABLED')
        trendChangeMsg += ' | Active=' + (trendChangeExitActive ? 'YES' : 'NO')  
        if trendChangeDetected
            trendChangeMsg += ' | CHANGE DETECTED: ' + trendChangeDetails
        debugMessage("INFO", trendChangeMsg, color.purple, color.white, 0.05)
    
    // Show hybrid exit system status
    if hybridExitEnable
        hybridMsg = 'HYBRID EXIT: Active=' + (hybridExitActive ? 'YES' : 'NO')
        hybridMsg += ' | Position=' + str.tostring(currentPositionSize) + '/' + str.tostring(hybridSwitchThreshold)
        if hybridExitActive
            hybridMsg += ' | Mode=' + (hybridUsingSPL ? 'SMART_PROFIT_LOCKER' : hybridUsingTCE ? 'TREND_CHANGE_EXIT' : 'NONE')
        hybridMsg += ' | shouldRunSPL=' + str.tostring(shouldRunSPL)
        debugMessage("INFO", hybridMsg, color.yellow, color.black, 0.05)

// Debug logging for exit systems (trend-riding system removed)
if debugEnabled and strategy.position_size != 0
    systemMsg = 'EXIT SYSTEMS:'
    systemMsg += ' SPL=' + (shouldRunSPL ? 'ON' : 'OFF')
    systemMsg += ' TCE=' + (trendChangeExitActive ? 'ON' : 'OFF')
    systemMsg += ' HYB=' + (hybridExitActive ? 'ON' : 'OFF')
    debugMessage("INFO", systemMsg, color.blue, color.white, 0.25)

// Enhanced visual indicators for exit systems  
plotchar(shouldRunSPL, title='Smart Profit Locker', char='ğŸ”’', location=location.top, color=color.blue, size=size.small)
plotchar(trendChangeExitEnable and strategy.position_size != 0, title='Trend Change Exit Active', char='ğŸ“ˆ', location=location.top, color=color.green, size=size.small)




// â”€â”€â”€â”€â”€â”€â”€â”€ REMOVED: CUSTOM EXIT SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This old custom exit logic was interfering with the trend/hybrid exit system
// All custom exit functionality has been removed to prevent conflicts

// Visual aids for active levels
plot(strategy.position_size > 0 and fixedEnable ? strategyEntryPrice - tpCalc(fixedStop) : na, 'Fixed SL', color.red, style=plot.style_linebr)
plot(strategy.position_size > 0 and fixedEnable and tp1Enable ? strategyEntryPrice + tpCalc(tp1Size) : na, 'Fixed TP', color.green, style=plot.style_linebr)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 8 Â· ENHANCED CHART VISUALS WITH BACKTESTING INTEGRATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Entry signals - simple visualization
// Removed: Static BUY/SELL arrows - replaced with dynamic signal naming above

// Signal count indicators (for visual reference only - position size determines strategy)
// Removed confluence plots - using position size for trade management instead

// â”€â”€â”€â”€â”€â”€â”€â”€ OPTIMIZED SIGNAL PLOTTING (Consolidated) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Removed consolidated signal markers - redundant with main BUY/SELL triangles
// This reduces visual clutter and eliminates duplicate signal indicators

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COMPREHENSIVE INDICATOR VISUALIZATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Beautiful, human-readable plotting of all strategy components
// â”€â”€â”€â”€â”€â”€â”€â”€ CORE STRATEGY INDICATORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Moving Average Exit Line (Thick, Color-Coded)
maExitMA = ta.ema(close, 21)  // Using EMA-21 as the primary MA exit
plot(maExitMA, title="ğŸ“ˆ MA Exit Line", color=color.new(color.blue, 0), linewidth=3, display=display.all)

// Stop Loss and Profit Lines (Dynamic based on position)
stopLossLine = strategy.position_size > 0 ? strategyEntryPrice - (atrVal * 3.1) : 
               strategy.position_size < 0 ? strategyEntryPrice + (atrVal * 3.1) : na
profitLockerLine = strategy.position_size > 0 ? high - (atrVal * smartProfitVal * smartProfitOffset) :
                   strategy.position_size < 0 ? low + (atrVal * smartProfitVal * smartProfitOffset) : na

plot(stopLossLine, title="ğŸ›‘ Stop Loss", color=color.new(color.red, 20), linewidth=2, style=plot.style_linebr)
plot(profitLockerLine, title="ğŸ’° Profit Locker", color=color.new(color.green, 20), linewidth=2, style=plot.style_linebr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ENHANCED VIRTUAL SIGNAL ANALYTICS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Professional Individual Signal Backtesting with Virtual Account System
// Real-time performance tracking with commission/slippage integration

if showBacktestTable and barstate.islast
    // Enhanced Virtual Account Table with Long/Short Separation
    var table virtualSignalTable = table.new(
        position.bottom_left, 
        columns=11, rows=12,
        bgcolor=color.new(color.black, 85),
        border_width=2,
        border_color=color.new(color.white, 70)
    )
    
    // Professional Headers with Icons and Color Hierarchy
    table.cell(virtualSignalTable, 0, 0, 'ğŸ“Š SIGNAL', text_color=color.white, text_size=size.normal, bgcolor=color.new(color.blue, 80))
    table.cell(virtualSignalTable, 1, 0, 'L.TRADES', text_color=color.white, text_size=size.small, bgcolor=color.new(color.green, 80))
    table.cell(virtualSignalTable, 2, 0, 'L.WIN%', text_color=color.white, text_size=size.small, bgcolor=color.new(color.green, 80))
    table.cell(virtualSignalTable, 3, 0, 'L.P&L($)', text_color=color.white, text_size=size.small, bgcolor=color.new(color.green, 80))
    table.cell(virtualSignalTable, 4, 0, 'S.TRADES', text_color=color.white, text_size=size.small, bgcolor=color.new(color.red, 80))
    table.cell(virtualSignalTable, 5, 0, 'S.WIN%', text_color=color.white, text_size=size.small, bgcolor=color.new(color.red, 80))
    table.cell(virtualSignalTable, 6, 0, 'S.P&L($)', text_color=color.white, text_size=size.small, bgcolor=color.new(color.red, 80))
    table.cell(virtualSignalTable, 7, 0, 'MAX DD($)', text_color=color.white, text_size=size.small, bgcolor=color.new(color.orange, 80))
    table.cell(virtualSignalTable, 8, 0, 'PF', text_color=color.white, text_size=size.small, bgcolor=color.new(color.purple, 80))
    table.cell(virtualSignalTable, 9, 0, 'STATUS', text_color=color.white, text_size=size.small, bgcolor=color.new(color.blue, 80))
    table.cell(virtualSignalTable, 10, 0, 'ACTION', text_color=color.white, text_size=size.small, bgcolor=color.new(color.blue, 80))
    
    // Process each virtual account for display
    signalEnables = array.from(signal1Enable, signal2Enable, signal3Enable, signal4Enable, signal5Enable, signal6Enable, signal7Enable, signal8Enable, signal9Enable, signal10Enable)
    signalNamesArray = array.from(signal1Name, signal2Name, signal3Name, signal4Name, signal5Name, signal6Name, signal7Name, signal8Name, signal9Name, signal10Name)
    
    currentRow = 1
    for i = 0 to 9
        if array.get(signalEnables, i)
            account = array.get(virtualAccounts, i)
            signalName = array.get(signalNamesArray, i)
            
            // Calculate metrics
            longWinRate = account.longTrades > 0 ? account.longWins / account.longTrades * 100 : 0
            shortWinRate = account.shortTrades > 0 ? account.shortWins / account.shortTrades * 100 : 0
            totalPnL = account.totalPnL
            profitFactor = account.grossLoss > 0 ? account.grossProfit / account.grossLoss : account.grossProfit > 0 ? 999 : 0
            
            // Performance Status Indicators
            overallWinRate = account.totalTrades > 0 ? account.winningTrades / account.totalTrades * 100 : 0
            statusEmoji = overallWinRate >= 70 and profitFactor >= 2.0 and totalPnL > 0 ? 'ğŸŸ¢' : overallWinRate >= 50 and profitFactor >= 1.5 and totalPnL > 0 ? 'ğŸŸ¡' : overallWinRate >= 40 and profitFactor >= 1.0 ? 'ğŸŸ ' : 'ğŸ”´'
            
            statusColor = overallWinRate >= 70 and profitFactor >= 2.0 and totalPnL > 0 ? color.new(color.lime, 20) : overallWinRate >= 50 and profitFactor >= 1.5 and totalPnL > 0 ? color.new(color.yellow, 20) : overallWinRate >= 40 and profitFactor >= 1.0 ? color.new(color.orange, 20) : color.new(color.red, 20)
            
            // Action Recommendation
            actionText = totalPnL > 100 and overallWinRate > 60 and profitFactor > 1.5 ? 'KEEP âœ…' : totalPnL < -100 or overallWinRate < 40 or profitFactor < 1.0 ? 'CUT âŒ' : 'TEST âš ï¸'
            
            actionColor = totalPnL > 100 and overallWinRate > 60 and profitFactor > 1.5 ? color.lime : totalPnL < -100 or overallWinRate < 40 or profitFactor < 1.0 ? color.red : color.orange
            
            // Truncate signal name for display
            displayName = str.length(signalName) > 8 ? str.substring(signalName, 0, 8) : signalName
            
            // Populate table row
            table.cell(virtualSignalTable, 0, currentRow, displayName, text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 80))
            table.cell(virtualSignalTable, 1, currentRow, str.tostring(account.longTrades), text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 2, currentRow, str.tostring(longWinRate, '#.#') + '%', text_color=longWinRate >= 60 ? color.lime : longWinRate >= 40 ? color.yellow : color.red, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 3, currentRow, '$' + str.tostring(account.longPnL, '#.##'), text_color=account.longPnL > 0 ? color.lime : color.red, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 4, currentRow, str.tostring(account.shortTrades), text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 5, currentRow, str.tostring(shortWinRate, '#.#') + '%', text_color=shortWinRate >= 60 ? color.lime : shortWinRate >= 40 ? color.yellow : color.red, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 6, currentRow, '$' + str.tostring(account.shortPnL, '#.##'), text_color=account.shortPnL > 0 ? color.lime : color.red, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 7, currentRow, '$' + str.tostring(account.maxDrawdown, '#.##'), text_color=color.white, text_size=size.small, bgcolor=color.new(color.red, 80))
            table.cell(virtualSignalTable, 8, currentRow, str.tostring(profitFactor, '#.##'), text_color=profitFactor >= 2.0 ? color.lime : profitFactor >= 1.5 ? color.yellow : profitFactor >= 1.0 ? color.orange : color.red, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 9, currentRow, statusEmoji, text_color=color.white, text_size=size.small, bgcolor=statusColor)
            table.cell(virtualSignalTable, 10, currentRow, actionText, text_color=actionColor, text_size=size.small, bgcolor=color.new(color.gray, 90))
            
            currentRow += 1
    
    // Summary Row with System Status
    if currentRow <= 11
        table.cell(virtualSignalTable, 0, 11, 'ğŸš€ SYSTEM', text_color=color.white, text_size=size.small, bgcolor=color.new(color.blue, 25))
        table.cell(virtualSignalTable, 1, 11, 'Comm: $' + str.tostring(commissionPerTrade, '#.##'), text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 2, 11, 'Slip: $' + str.tostring(slippagePerTrade, '#.##'), text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 3, 11, 'Size: ' + str.tostring(virtualPositionSize), text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 4, 11, 'Point: $' + str.tostring(syminfo.pointvalue * futuresMultiplier, '#.##'), text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 5, 11, parametersChanged ? 'RESET âš¡' : 'STABLE âœ“', text_color=parametersChanged ? color.orange : color.lime, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 6, 11, 'Virtual Accounts Active', text_color=color.lime, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 7, 11, 'Real-Time P&L', text_color=color.lime, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 8, 11, 'Perfect Attribution', text_color=color.lime, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 9, 11, 'Commission Adjusted', text_color=color.lime, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 10, 11, 'Phase 1 ACTIVE âœ…', text_color=color.lime, text_size=size.tiny, bgcolor=color.new(color.green, 35))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INTRABAR EXIT DEBUG SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Visual monitoring and validation system for robust exit logic

debugOn = input.bool(false, 'ğŸ” Enable Exit Debug Labels', group = 'ğŸ› ï¸ Debug System', tooltip = 'Show visual labels when exits trigger to validate anti-spam logic')

if debugOn and barstate.isconfirmed
    // Determine which exit method was triggered (if any)
    exitType = 
      maExitSent ? 'MA' :
      fixedExitSent ? 'Fixed' :
      trailExitSent ? 'Trail' :
      // Removed: customExitSent ? 'Custom' : - old custom exit system
      'None'
    
    // Color coding for different exit types
    labelColor = 
      maExitSent ? color.red : 
      fixedExitSent ? color.orange : 
      trailExitSent ? color.blue : 
      // Removed: customExitSent ? color.teal : - old custom exit system
      color.gray
    
    // Show debug label when an exit is triggered
    if exitType != 'None'
        label.new(bar_index, high * 1.02, 'EXIT: ' + exitType + '\nBar: ' + str.tostring(bar_index) + '\nPrice: ' + str.tostring(close, '#.####') + '\nPos: ' + (strategy.position_size > 0 ? 'Long' : strategy.position_size < 0 ? 'Short' : 'Flat'), color=labelColor, textcolor=color.white, style=label.style_label_down, yloc=yloc.abovebar, size=size.small)
    
    // Show position state changes
    if currentPosition != currentPosition[1]
        stateColor = currentPosition ? color.green : color.red
        stateText = currentPosition ? 'ENTRY' : 'EXIT'
        label.new(bar_index, low * 0.98, stateText + '\nFlags Reset: ' + (currentPosition ? 'YES' : 'NO'), color=stateColor, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, size=size.tiny)

// â”€â”€â”€â”€â”€â”€â”€â”€ STATUS/SETTINGS PANEL (Optional) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
showStatusPanel = input.bool(false, 'âš™ï¸ Status/Settings Panel', group = 'ğŸ› ï¸ Debug System', tooltip = 'Show comprehensive status and settings for all enabled features')

if showStatusPanel and barstate.isconfirmed
    // Create fixed-size table (3 columns, 8 rows max)  
    var table statusTable = table.new(position.bottom_right, 3, 8, bgcolor = color.new(color.black, 20), border_width = 1)
    
    // Headers
    table.cell(statusTable, 0, 0, 'âš™ï¸ FEATURE', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 40))
    table.cell(statusTable, 1, 0, 'STATUS', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 40))
    table.cell(statusTable, 2, 0, 'SETTINGS', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 40))
    
    // Dynamic row counter
    var int currentRow = 1
    currentRow := 1
    
    // MA Exit
    if maExitOn
        maStatus = inPosition and (strategy.position_size > 0 and close < priceMA) or (strategy.position_size < 0 and close > priceMA) ? 'ğŸ”´ TRIGGERED' : inPosition ? 'ğŸŸ¡ MONITORING' : 'âšª STANDBY'
        maStatusColor = inPosition and ((strategy.position_size > 0 and close < priceMA) or (strategy.position_size < 0 and close > priceMA)) ? color.red : inPosition ? color.yellow : color.gray
        maSettings = maType + '-' + str.tostring(maLen)
        
        table.cell(statusTable, 0, currentRow, 'ğŸ“ˆ MA Exit', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(statusTable, 1, currentRow, maStatus, text_color = maStatusColor, text_size = size.small, bgcolor = color.new(color.gray, 90))
        table.cell(statusTable, 2, currentRow, maSettings, text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 90))
        currentRow += 1
    
    // Fixed SL/TP
    if fixedEnable
        fixedStatus = inPosition ? 'ğŸŸ¡ ACTIVE' : 'âšª STANDBY'
        fixedStatusColor = inPosition ? color.yellow : color.gray
        fixedSettings = 'SL:' + str.tostring(fixedStop, '#.1') + ' ' + fixedUnit + ' TP:' + (tp1Enable ? str.tostring(tp1Size, '#.1') : 'OFF')
        
        table.cell(statusTable, 0, currentRow, 'ğŸ¯ Fixed SL/TP', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(statusTable, 1, currentRow, fixedStatus, text_color = fixedStatusColor, text_size = size.small, bgcolor = color.new(color.gray, 90))
        table.cell(statusTable, 2, currentRow, fixedSettings, text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 90))
        currentRow += 1
    
    // Smart Profit Locker
    if smartProfitEnable
        smartStatus = inPosition ? 'ğŸŸ¢ ACTIVE' : 'âšª STANDBY'
        smartStatusColor = inPosition ? color.lime : color.gray
        smartSettings = str.tostring(smartProfitVal, '#.1') + ' ' + smartProfitType + ', ' + str.tostring(smartProfitOffset * 100, '#.1') + '% PB'
        
        table.cell(statusTable, 0, currentRow, 'ğŸ”’ Smart Locker', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(statusTable, 1, currentRow, smartStatus, text_color = smartStatusColor, text_size = size.small, bgcolor = color.new(color.gray, 90))
        table.cell(statusTable, 2, currentRow, smartSettings, text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 90))
        currentRow += 1
    
    // Trend Change Exit
    if trendChangeExitEnable
        trendChangeStatus = trendChangeExitActive ? 'ğŸŸ¢ ACTIVE' : inPosition ? 'ğŸŸ¡ MONITORING' : 'âšª STANDBY'
        trendChangeColor = trendChangeExitActive ? color.lime : inPosition ? color.yellow : color.gray
        trendChangeSettings = 'Any trend signal direction change'
        
        table.cell(statusTable, 0, currentRow, 'ğŸ“ˆ Trend Exit', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(statusTable, 1, currentRow, trendChangeStatus, text_color = trendChangeColor, text_size = size.small, bgcolor = color.new(color.gray, 90))
        table.cell(statusTable, 2, currentRow, trendChangeSettings, text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 90))
        currentRow += 1
    
    // Hybrid Exit System
    if hybridExitEnable
        hybridStatus = hybridExitActive ? (hybridUsingSPL ? 'ğŸ”µ SPL MODE' : hybridUsingTCE ? 'ğŸŸ¢ TCE MODE' : 'ğŸŸ¡ ACTIVE') : 'âšª STANDBY'
        hybridColor = hybridExitActive ? (hybridUsingSPL ? color.blue : hybridUsingTCE ? color.green : color.yellow) : color.gray
        hybridSettings = 'Switch at ' + str.tostring(hybridSwitchThreshold) + ' contracts'
        
        table.cell(statusTable, 0, currentRow, 'âš¡ Hybrid Exit', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(statusTable, 1, currentRow, hybridStatus, text_color = hybridColor, text_size = size.small, bgcolor = color.new(color.gray, 90))
        table.cell(statusTable, 2, currentRow, hybridSettings, text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 90))
        currentRow += 1
    
    // System Status Row  
    table.cell(statusTable, 0, currentRow, 'ğŸ“Š Position', text_color = color.white, text_size = size.small, bgcolor = color.new(color.purple, 60))
    table.cell(statusTable, 1, currentRow, inPosition ? 'ğŸŸ¢ IN TRADE' : 'âšª NO POSITION', text_color = inPosition ? color.lime : color.gray, text_size = size.small, bgcolor = color.new(color.purple, 70))
    table.cell(statusTable, 2, currentRow, 'Size: ' + str.tostring(strategy.position_size), text_color = color.white, text_size = size.small, bgcolor = color.new(color.purple, 70))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MASTER PANEL SYSTEM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Real-time strategy status panel for enhanced transparency

// Master Panel Enable Toggle
masterPanelEnable = input.bool(true, 'ğŸ“Š Master Panel', group='ğŸ›ï¸ Master Panel', tooltip='Show real-time strategy status panel with key metrics')
bigPositionDisplay = input.bool(true, 'ğŸ’¯ Big Position Display', group='ğŸ›ï¸ Master Panel', tooltip='Show large, bold position indicator for instant recognition')

// Big Bold Position Display (Optimized for immediate loading)
if bigPositionDisplay and barstate.isconfirmed
    var label bigPositionLabel = na
    
    // Delete previous label
    if not na(bigPositionLabel)
        label.delete(bigPositionLabel)
    
    // Create new position label
    if strategy.position_size != 0
        positionText = strategy.position_size > 0 ? 'LONG' : 'SHORT'
        positionColor = strategy.position_size > 0 ? color.new(color.lime, 20) : color.new(color.red, 20)
        textColor = strategy.position_size > 0 ? color.lime : color.red
        
        bigPositionLabel := label.new(x = bar_index + 5, y = high + (high - low) * 0.3, text = positionText, style = label.style_label_left, color = positionColor, textcolor = textColor, size = size.huge)

// Session Stats Tracking
var float sessionStartEquity = na
var int sessionTrades = 0
var int sessionWins = 0

// Initialize session stats at start of day
if na(sessionStartEquity) or dayofweek != dayofweek[1]
    sessionStartEquity := strategy.equity
    sessionTrades := 0
    sessionWins := 0

// Track session trades
if strategy.closedtrades > strategy.closedtrades[1]
    sessionTrades := sessionTrades + 1
    if strategy.wintrades > strategy.wintrades[1]
        sessionWins := sessionWins + 1

// Simplified bias calculation (RBW only)
// Removed complex trend consensus logic - using position size for strategy control

// Master Panel Display (Optimized for immediate loading)
if masterPanelEnable and barstate.isconfirmed
    var table masterPanel = table.new(position.top_right, 2, 15, bgcolor = color.new(color.black, 15), border_width = 1)
    
    // Header
    table.cell(masterPanel, 0, 0, 'ğŸ›ï¸ MASTER PANEL', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 30))
    table.cell(masterPanel, 1, 0, 'STATUS', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 30))
    

    
    // Bias Filter Status (Simplified - RBW Only)
    biasText = rbwEnable ? 
      (longDirectionalBias ? 'BULLISH' : shortDirectionalBias ? 'BEARISH' : 'NEUTRAL') : 'DISABLED'
    biasColor = longDirectionalBias ? color.lime : shortDirectionalBias ? color.red : color.gray
    table.cell(masterPanel, 0, 2, 'ğŸ“ˆ RBW Bias', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
    table.cell(masterPanel, 1, 2, biasText, text_color = biasColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Signal Strength Meter Row (expanded to 10 signals)
    activeSignals = (signal1Enable ? 1 : 0) + (signal2Enable ? 1 : 0) + (signal3Enable ? 1 : 0) + (signal4Enable ? 1 : 0) + (signal5Enable ? 1 : 0) + (signal6Enable ? 1 : 0) + (signal7Enable ? 1 : 0) + (signal8Enable ? 1 : 0) + (signal9Enable ? 1 : 0) + (signal10Enable ? 1 : 0)
    longSignalCount := (signal1Enable and sig1Long ? 1 : 0) + (signal2Enable and sig2Long ? 1 : 0) + (signal3Enable and sig3Long ? 1 : 0) + (signal4Enable and sig4Long ? 1 : 0) + (signal5Enable and sig5Long ? 1 : 0) + (signal6Enable and sig6Long ? 1 : 0) + (signal7Enable and sig7Long ? 1 : 0) + (signal8Enable and sig8Long ? 1 : 0) + (signal9Enable and sig9Long ? 1 : 0) + (signal10Enable and sig10Long ? 1 : 0)
    shortSignalCount := (signal1Enable and sig1Short ? 1 : 0) + (signal2Enable and sig2Short ? 1 : 0) + (signal3Enable and sig3Short ? 1 : 0) + (signal4Enable and sig4Short ? 1 : 0) + (signal5Enable and sig5Short ? 1 : 0) + (signal6Enable and sig6Short ? 1 : 0) + (signal7Enable and sig7Short ? 1 : 0) + (signal8Enable and sig8Short ? 1 : 0) + (signal9Enable and sig9Short ? 1 : 0) + (signal10Enable and sig10Short ? 1 : 0)
    
    if activeSignals > 0
        maxSignals = math.max(longSignalCount, shortSignalCount)
        signalStrength = maxSignals / activeSignals * 100
        strengthText = str.tostring(signalStrength, '#') + '% (' + str.tostring(maxSignals) + '/' + str.tostring(activeSignals) + ')'
        strengthColor = signalStrength >= 80 ? color.lime : signalStrength >= 60 ? color.yellow : signalStrength >= 40 ? color.orange : color.red
        table.cell(masterPanel, 0, 3, 'ğŸ“Š Signal Power', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 3, strengthText, text_color = strengthColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Volatility Alert Row
    atrCurrent = atrVal
    // Use pre-calculated atrAvg instead of inline ta.sma calculation
    volatilityRatio := atrCurrent / atrAvg
    
    if volatilityRatio > 1.5  // Show alert when ATR is 50% above average
        volText = 'HIGH (' + str.tostring(volatilityRatio, '#.##') + 'x)'
        volColor = volatilityRatio > 2.0 ? color.red : color.orange
        table.cell(masterPanel, 0, 4, 'âš¡ Volatility', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 4, volText, text_color = volColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Mode Status Row
    if hybridExitEnable
        modeText = ''
        modeColor = color.gray
        
        if hybridExitEnable and hybridExitActive
            modeText := 'HYBRID'
            modeColor := color.orange
        else
            modeText := 'NORMAL'
            modeColor := color.gray
            
        table.cell(masterPanel, 0, 5, 'ğŸš€ Mode', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 5, modeText, text_color = modeColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    

    
    // Exit System Status Row - NEW COMPREHENSIVE TRACKING
    if strategy.position_size != 0
        exitSystemText = ''
        exitSystemColor = color.gray
        
        // Determine which exit system is currently active
        if bbExitTriggered
            // BB EXIT MODE: Tight profit locker from BB extreme
            exitSystemText := 'BB TIGHT'
            exitSystemColor := color.yellow
        else if smartProfitEnable and shouldRunSPL
            // NORMAL MODE: Smart profit locker active
            exitSystemText := 'SMART LOCKER'
            exitSystemColor := color.lime
        else if maExitOn
            // MA EXIT MODE: Moving average exit active
            exitSystemText := 'MA EXIT'
            exitSystemColor := color.purple
        else if fixedEnable
            // FIXED MODE: Fixed SL/TP active
            exitSystemText := 'FIXED SL/TP'
            exitSystemColor := color.blue
        else
            // NO EXIT SYSTEM: This shouldn't happen but safety check
            exitSystemText := 'NO EXIT!'
            exitSystemColor := color.red
        
        table.cell(masterPanel, 0, 7, 'ğŸ¯ Exit System', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 7, exitSystemText, text_color = exitSystemColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Position Status Row
    positionText = strategy.position_size == 0 ? 'FLAT' : strategy.position_size > 0 ? 'LONG' : 'SHORT'
    positionColor = strategy.position_size == 0 ? color.gray : strategy.position_size > 0 ? color.lime : color.red
    table.cell(masterPanel, 0, 8, 'ğŸ“ˆ Position', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
    table.cell(masterPanel, 1, 8, positionText, text_color = positionColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // P&L Row (only when in position)
    if strategy.position_size != 0
        unrealizedPnL = strategy.openprofit
        pnlText = (unrealizedPnL >= 0 ? '+$' : '-$') + str.tostring(math.abs(unrealizedPnL), '#.##')
        pnlColor = unrealizedPnL > 0 ? color.lime : unrealizedPnL < 0 ? color.red : color.gray
        table.cell(masterPanel, 0, 9, 'ğŸ’° P&L', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 9, pnlText, text_color = pnlColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Trade Duration Row (only when in position)
    if strategy.position_size != 0
        barsInTrade = bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1)
        durationText = str.tostring(barsInTrade) + ' bars'
        durationColor = barsInTrade > 50 ? color.orange : color.white
        table.cell(masterPanel, 0, 10, 'â±ï¸ Duration', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 10, durationText, text_color = durationColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Entry Price Row (only when in position)
    if strategy.position_size != 0
        float entryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)
        priceText = '$' + str.tostring(entryPrice, '#.##')
        priceDiff = close - entryPrice
        diffText = (priceDiff >= 0 ? '+' : '') + str.tostring(priceDiff, '#.##')
        table.cell(masterPanel, 0, 11, 'ğŸ¯ Entry Price', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 11, priceText + ' (' + diffText + ')', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Risk/Reward Calculator Row (only when in position)
    if strategy.position_size != 0 and smartProfitEnable
        float entryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)
        stopDistance = smartProfitVal * atrVal  // Assuming ATR-based stop
        currentDistance = math.abs(close - entryPrice)
        riskRewardRatio = currentDistance / stopDistance
        rrText = str.tostring(riskRewardRatio, '#.##') + ':1'
        rrColor = riskRewardRatio >= 2.0 ? color.lime : riskRewardRatio >= 1.0 ? color.yellow : color.red
        table.cell(masterPanel, 0, 12, 'ğŸ² R:R Ratio', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 12, rrText, text_color = rrColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Session Stats Row
    if sessionTrades > 0
        sessionPnL = strategy.equity - sessionStartEquity
        sessionWinRate = sessionWins / sessionTrades * 100
        sessionText = str.tostring(sessionWinRate, '#') + '% (' + str.tostring(sessionWins) + '/' + str.tostring(sessionTrades) + ')'
        sessionColor = sessionWinRate >= 70 ? color.lime : sessionWinRate >= 50 ? color.yellow : color.red
        table.cell(masterPanel, 0, 12, 'ğŸŒ… Today', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 12, sessionText, text_color = sessionColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Next Signal Countdown Row (only when flat)
    if strategy.position_size == 0
        // Simple countdown based on bars since last signal
        barsWithoutSignal = 0
        if not (sig1Long or sig1Short or sig2Long or sig2Short or sig3Long or sig3Short or sig4Long or sig4Short or sig5Long or sig5Short)
            barsWithoutSignal := 1
        
        countdownText = ''
        countdownColor = color.gray
        
        if barsWithoutSignal > 0
            countdownText := 'Waiting...'
            countdownColor := color.gray
        else
            countdownText := 'Signal Active!'
            countdownColor := color.yellow
        
        table.cell(masterPanel, 0, 13, 'â³ Next Signal', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 13, countdownText, text_color = countdownColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Win Rate Row
    if strategy.closedtrades > 0
        winRate = strategy.wintrades / strategy.closedtrades * 100
        winText = str.tostring(winRate, '#.1') + '% (' + str.tostring(strategy.wintrades) + '/' + str.tostring(strategy.closedtrades) + ')'
        winColor = winRate >= 70 ? color.lime : winRate >= 50 ? color.yellow : color.red
        table.cell(masterPanel, 0, 14, 'ğŸ† Win Rate', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 14, winText, text_color = winColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STRATEGY PERFORMANCE TRACKING UPDATES â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Update signal performance arrays when trades close

// Track peak/trough during open trades for drawdown calculation
if strategy.position_size != 0 and not na(current_trade_entry)
    if strategy.position_size > 0  // Long position
        current_trade_peak := math.max(current_trade_peak, close)
        current_trade_trough := math.min(current_trade_trough, close)
    else  // Short position
        current_trade_peak := math.max(current_trade_peak, current_trade_entry - close)
        current_trade_trough := math.min(current_trade_trough, current_trade_entry - close)

// Update performance arrays when trades close
if strategy.closedtrades > strategy.closedtrades[1]
    // Calculate trade P&L
    trade_pnl = strategy.position_size[1] > 0 ? (close - current_trade_entry) / current_trade_entry * 100 : (current_trade_entry - close) / current_trade_entry * 100
    trade_won = trade_pnl > 0
    
    // Calculate drawdown during this trade
    trade_drawdown = strategy.position_size[1] > 0 ? (current_trade_peak - current_trade_trough) / current_trade_entry * 100 : current_trade_peak
    
    // Update performance for each signal that contributed to this trade (expanded to 10 signals)
    for i = 0 to 9
        if array.get(current_trade_signals, i)
            // Update trade count
            current_trades = array.get(signal_strategy_trades, i)
            array.set(signal_strategy_trades, i, current_trades + 1)
            
            // Update win count
            if trade_won
                current_wins = array.get(signal_strategy_wins, i)
                array.set(signal_strategy_wins, i, current_wins + 1)
            
            // Update cumulative P&L
            current_profit = array.get(signal_strategy_profits, i)
            array.set(signal_strategy_profits, i, current_profit + trade_pnl)
            
            // Update max drawdown (track worst drawdown per signal)
            current_dd = array.get(signal_strategy_drawdowns, i)
            array.set(signal_strategy_drawdowns, i, math.max(current_dd, trade_drawdown))
            
            // Update contribution score (weighted by trade P&L)
            current_contrib = array.get(signal_contributions, i)
            array.set(signal_contributions, i, current_contrib + (trade_pnl * 0.1))  // Weighted contribution
    
    // Reset tracking variables (expanded to 10 signals)
    current_trade_entry := na
    current_trade_peak := na
    current_trade_trough := na
    for i = 0 to 9
        array.set(current_trade_signals, i, false)

// TREND SIGNAL-BASED EXIT DETECTION
// Check for opposite signals from the 5 Trend Signals (correct approach)

// Reset trend change detection each bar
trendChangeDetected := false
trendChangeDetails := ""

// OLD TREND CHANGE EXIT LOGIC - KEPT FOR BASIC COMPATIBILITY
// This is overridden by the Advanced Trend Exit System when enabled
if trendChangeExitEnable and strategy.position_size != 0 and not useAdvancedTrendExit
    // Basic fallback logic (simplified)
    if strategy.position_size > 0 and (trend1Short or trend2Short or trend3Short)
        trendChangeDetected := true
        trendChangeDetails := "Basic Trend Exit: Opposite signal detected"
    else if strategy.position_size < 0 and (trend1Long or trend2Long or trend3Long)
        trendChangeDetected := true
        trendChangeDetails := "Basic Trend Exit: Opposite signal detected"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ADVANCED TREND EXIT LOGIC â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3-Phase Exit System: Trailing Stop â†’ Color Change Exit â†’ Re-Entry

// State variables for advanced trend exit (declared in global section)

// Determine if we should use advanced trend exit
useAdvancedTrendExit := (trendExitEnable and not hybridModeEnable) or (hybridModeEnable and hybridExitActive and hybridUsingTCE)

// Reset state when no position
if strategy.position_size == 0
    inTrendExitMode := false
    inProfitMode := false
    trendExitPrice := na
    if not reEntryEnable
        waitingForReEntry := false
        exitDirection := 0

// Initialize trend exit mode on new position
if strategy.position_size != 0 and not inTrendExitMode and useAdvancedTrendExit
    inTrendExitMode := true
    inProfitMode := false
    trendExitPrice := strategy.position_avg_price
    waitingForReEntry := false
    exitDirection := 0

// Phase 1: Check if we should switch from trailing stop to profit mode
if inTrendExitMode and not inProfitMode and strategy.position_size != 0
    trailingStopDistance = initialTrailingStop * atrVal
    
    if strategy.position_size > 0
        // Long position: switch to profit mode when price is above entry + trailing stop distance
        if close >= trendExitPrice + trailingStopDistance
            inProfitMode := true
    else
        // Short position: switch to profit mode when price is below entry - trailing stop distance  
        if close <= trendExitPrice - trailingStopDistance
            inProfitMode := true

// Phase 2: Color Change Exit (when in profit mode)
colorChangeExit := false

if inTrendExitMode and inProfitMode and strategy.position_size != 0
    if exitMode == 'Color Change'
        if strategy.position_size > 0 and lrcBearColor  // Long position exits on bear color
            colorChangeExit := true
            exitDirection := 1
        else if strategy.position_size < 0 and lrcBullColor  // Short position exits on bull color
            colorChangeExit := true
            exitDirection := -1
    else if exitMode == 'MA Cross'
        if strategy.position_size > 0 and lrcBearMA  // Long position exits on bear MA cross
            colorChangeExit := true
            exitDirection := 1
        else if strategy.position_size < 0 and lrcBullMA  // Short position exits on bull MA cross
            colorChangeExit := true
            exitDirection := -1

// Phase 3: Re-Entry Logic
reEntrySignal := false

if reEntryEnable and waitingForReEntry and strategy.position_size == 0
    if exitDirection == 1  // Was long, look for bull signal to re-enter long
        if exitMode == 'Color Change' and lrcBullColor and trendConfirmsLong
            reEntrySignal := true
            waitingForReEntry := false
            exitDirection := 0
        else if exitMode == 'MA Cross' and lrcBullMA and trendConfirmsLong
            reEntrySignal := true
            waitingForReEntry := false
            exitDirection := 0
    else if exitDirection == -1  // Was short, look for bear signal to re-enter short
        if exitMode == 'Color Change' and lrcBearColor and trendConfirmsShort
            reEntrySignal := true
            waitingForReEntry := false
            exitDirection := 0
        else if exitMode == 'MA Cross' and lrcBearMA and trendConfirmsShort
            reEntrySignal := true
            waitingForReEntry := false
            exitDirection := 0

// Set waiting for re-entry when color change exit occurs
if colorChangeExit and reEntryEnable
    waitingForReEntry := true

// Set final trend change detection for compatibility with existing exit logic
if colorChangeExit
    trendChangeDetected := true
    trendChangeDetails := "LRC " + exitMode + " Exit"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DYNAMIC SIGNAL NAMING FOR ARROWS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Create meaningful arrow labels showing which signal(s) triggered the entry

// Build dynamic signal names for long entries
longSignalName = ""
var int dynamicLongCount = 0
dynamicLongCount := 0
if longEntrySignal
    if sig1Long and signal1Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal1Name
        dynamicLongCount := dynamicLongCount + 1
    if sig2Long and signal2Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal2Name
        dynamicLongCount := dynamicLongCount + 1
    if sig3Long and signal3Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal3Name
        dynamicLongCount := dynamicLongCount + 1
    if sig4Long and signal4Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal4Name
        dynamicLongCount := dynamicLongCount + 1
    if sig5Long and signal5Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal5Name
        dynamicLongCount := dynamicLongCount + 1
    if sig6Long and signal6Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal6Name
        dynamicLongCount := dynamicLongCount + 1
    if sig7Long and signal7Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal7Name
        dynamicLongCount := dynamicLongCount + 1
    if sig8Long and signal8Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal8Name
        dynamicLongCount := dynamicLongCount + 1
    if sig9Long and signal9Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal9Name
        dynamicLongCount := dynamicLongCount + 1
    if sig10Long and signal10Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal10Name
        dynamicLongCount := dynamicLongCount + 1

// Build dynamic signal names for short entries
shortSignalName = ""
var int dynamicShortCount = 0
dynamicShortCount := 0
if shortEntrySignal
    if sig1Short and signal1Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal1Name
        dynamicShortCount := dynamicShortCount + 1
    if sig2Short and signal2Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal2Name
        dynamicShortCount := dynamicShortCount + 1
    if sig3Short and signal3Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal3Name
        dynamicShortCount := dynamicShortCount + 1
    if sig4Short and signal4Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal4Name
        dynamicShortCount := dynamicShortCount + 1
    if sig5Short and signal5Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal5Name
        dynamicShortCount := dynamicShortCount + 1
    if sig6Short and signal6Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal6Name
        dynamicShortCount := dynamicShortCount + 1
    if sig7Short and signal7Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal7Name
        dynamicShortCount := dynamicShortCount + 1
    if sig8Short and signal8Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal8Name
        dynamicShortCount := dynamicShortCount + 1
    if sig9Short and signal9Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal9Name
        dynamicShortCount := dynamicShortCount + 1
    if sig10Short and signal10Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal10Name
        dynamicShortCount := dynamicShortCount + 1

// Create final arrow titles with signal names
dynamicLongText = longSignalName != "" ? longSignalName : "MULTI"
dynamicShortText = shortSignalName != "" ? shortSignalName : "MULTI"

// Plot arrows with static titles and use labels for dynamic signal names
plotshape(longEntrySignal, title = "BUY Signal", style = shape.triangleup, location = location.belowbar, color = color.lime, size = size.small)
plotshape(shortEntrySignal, title = "SELL Signal", style = shape.triangledown, location = location.abovebar, color = color.red, size = size.small)

// Add dynamic labels showing which signal(s) triggered the entry
if longEntrySignal
    label.new(bar_index, low - (atrVal * 0.5), dynamicLongText, color = color.new(color.lime, 20), style = label.style_label_up, textcolor = color.white, size = size.small)

if shortEntrySignal
    label.new(bar_index, high + (atrVal * 0.5), dynamicShortText, color = color.new(color.red, 20), style = label.style_label_down, textcolor = color.white, size = size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• STRATEGY EXECUTION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ POSITION SIZE CONTROL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
positionQty = input.int(1, 'Number of Contracts', minval = 1, maxval = 1000, group = 'ğŸ’¼ Position Size', tooltip = 'Set the number of contracts/shares to trade per signal')

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENTRY LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Only enter a new trade if currently flat (strategy.position_size == 0)
if longEntrySignal and strategy.position_size == 0
    strategy.entry("Long", strategy.long, qty=positionQty, alert_message=longEntryMsg, comment=dynamicLongText)

if shortEntrySignal and strategy.position_size == 0
    strategy.entry("Short", strategy.short, qty=positionQty, alert_message=shortEntryMsg, comment=dynamicShortText)

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ EXIT LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// MA EXIT LOGIC
if maExitOn and strategy.position_size != 0
    longExitCondition = strategy.position_size > 0 and close < priceMA
    shortExitCondition = strategy.position_size < 0 and close > priceMA
    
    if longExitCondition
        strategy.close("Long", comment="MA Exit", alert_message=longExitMsg)
        
    if shortExitCondition
        strategy.close("Short", comment="MA Exit", alert_message=shortExitMsg)

// FIXED SL/TP LOGIC
if fixedEnable and strategy.position_size != 0
    if strategy.position_size > 0  // Long position
        stopLevel = strategy.position_avg_price - tpCalc(fixedStop)
        profitLevel = tp1Enable ? strategy.position_avg_price + tpCalc(tp1Size) : na
        strategy.exit("Fixed-Long", from_entry="Long", stop=stopLevel, limit=profitLevel, comment="Fixed SL/TP")
    
    if strategy.position_size < 0  // Short position
        stopLevel = strategy.position_avg_price + tpCalc(fixedStop)
        profitLevel = tp1Enable ? strategy.position_avg_price - tpCalc(tp1Size) : na
        strategy.exit("Fixed-Short", from_entry="Short", stop=stopLevel, limit=profitLevel, comment="Fixed SL/TP")

// ADVANCED TREND EXIT EXECUTION
if colorChangeExit and strategy.position_size != 0
    if strategy.position_size > 0
        strategy.close("Long", comment="LRC Exit", alert_message=longExitMsg)
        
    if strategy.position_size < 0
        strategy.close("Short", comment="LRC Exit", alert_message=shortExitMsg)

// BASIC TREND CHANGE EXIT EXECUTION
if trendChangeDetected and trendChangeExitEnable and strategy.position_size != 0 and not useAdvancedTrendExit
    if strategy.position_size > 0
        strategy.close("Long", comment="Trend Change Exit", alert_message=longExitMsg)
        
    if strategy.position_size < 0
        strategy.close("Short", comment="Trend Change Exit", alert_message=shortExitMsg)