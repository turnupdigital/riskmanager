// 2025 Andres Garcia — EZ Algo Trader (Beta)
//  ────────────────────────────────────────────────────────────────
//  Enhanced Multi-Signal Risk Management System
//  • Professional risk management with multiple exit strategies
//  • TradersPost webhook integration for automated trading
//  • Configurable position sizing and stop-loss/take-profit levels
//  • Integrated debugging logger for development
//  ────────────────────────────────────────────────────────────────
//@version=6

// DEBUG SYSTEM
// Simple debug system using Pine Script labels - no external libraries

// Debug configuration
bool debugEnabled = input.bool(false, '🔍 Enable Debug Labels', group = '🛠️ Debug System', tooltip = 'Show debug information as chart labels')

// Combined debug function
debugMessage(string type, string message, color bgColor, color txtColor, float yOffset) =>
    if debugEnabled
        label.new(bar_index, high + (high - low) * yOffset, type + ": " + message, style=label.style_label_down, color=bgColor, textcolor=txtColor, size=size.small)

// ─────────────────── POSITION SIZE CONTROL (declared early for strategy function) ───────────────────
positionQty = input.int(1, 'Contracts per Signal', minval = 1, maxval = 1000, group = '💼 Position Size', inline='pos1', tooltip = 'Set the number of contracts/shares to trade per signal')
// NOTE: Pyramiding must be set to maximum expected value (Pine Script limitation - can't use input variable)
// Users control actual limit through position sizing logic rather than strategy parameter

strategy(title = 'EZ Algo Trader (Beta)', overlay = true, default_qty_type = strategy.fixed, default_qty_value = 1, calc_on_order_fills = true, process_orders_on_close = false, calc_on_every_tick = true, pyramiding = 10)
// User-controllable quantity

// ═══════════════════ GLOBAL VARIABLE DECLARATIONS ═══════════════════
// Declare all variables early to avoid scope issues

// Trend-riding system variables (removed - replaced by Trend Change Exit & Hybrid Exit)

// Exit system variables
var float smartOffset = na
var string exitComment = na
var float smartDistance = na
var string exitReason = na

// Strategy Performance Tracking Variables (expanded to 10 signals)
var array<float> signal_strategy_profits = array.new<float>(10, 0.0)
var array<float> signal_strategy_drawdowns = array.new<float>(10, 0.0)

// Missing variable declarations - restored
var float strategyEntryPrice = na
var bool trailExitSent = false
var bool maExitSent = false
var bool fixedExitSent = false
var bool inPosition = false
var bool currentPosition = false

// Backtesting variables
var array<int> signal_tradeCounts = array.new<int>(10, 0)
var array<int> signal_winCounts = array.new<int>(10, 0)
var array<float> signal_profits = array.new<float>(10, 0.0)
var array<float> signal_entryPrices = array.new<float>(10, na)
var array<string> signal_positions = array.new<string>(10, "none")
var array<float> signal_largestWins = array.new<float>(10, 0.0)
var array<float> signal_grossProfits = array.new<float>(10, 0.0)
var array<float> signal_grossLosses = array.new<float>(10, 0.0)

// Panel control variables
showBacktestTable = input.bool(true, '📊 Individual Signal Backtest', group = '🔍 Backtesting Panels', tooltip = 'Show individual signal performance (existing table)')
futuresMultiplier = input.int(20, '💰 Futures Multiplier', minval=1, maxval=100, group = '🔍 Backtesting Panels', tooltip = 'Point value multiplier for futures (NQ=20, ES=50, YM=5, RTY=50)')

// Advanced Trend Exit System Variables (moved here from later in script)
var bool inTrendExitMode = false
var bool inProfitMode = false
var float trendExitPrice = na
var bool waitingForReEntry = false
var int exitDirection = 0  // 1 = was long, -1 = was short
var bool reEntrySignal = false
var bool colorChangeExit = false
var bool useAdvancedTrendExit = false

// Fluid Hybrid System Variables
var bool shouldUseTrendMode = false  // Controls when to use Advanced Trend Exit
var bool shouldUseSPL = false        // Controls when to use Smart Profit Locker
// REMOVED: hybridExitActive - no longer used since stand-alone hybrid system was removed
// REMOVED: Stand-alone hybrid flags - functionality moved to Advanced Trend Exit's internal hybrid mode
var bool bbLongFilterOK = true
var bool bbShortFilterOK = true
var bool trendChangeExitActive = false
var bool trendChangeDetected = false
var string trendChangeDetails = ""
var array<float> signal_contributions = array.new<float>(10, 0.0)
var float volatilityRatio = na
var float current_trade_entry = na
var float current_trade_peak = na
var float current_trade_trough = na
var array<bool> current_trade_signals = array.new<bool>(10, false)
var array<int> signal_strategy_trades = array.new<int>(10, 0)
var array<int> signal_strategy_wins = array.new<int>(10, 0)
var bool longEntrySignal = false
var bool shortEntrySignal = false

// ═══════════════════ VIRTUAL SIGNAL ARCHITECTURE ═══════════════════
// Individual Signal Backtesting System - 10 Parallel Virtual Accounts
// Each signal gets its own isolated "trading account" for perfect attribution

// Virtual Account Structure for Each Signal
type VirtualAccount
    bool inPosition = false
    string direction = "none"  // "long", "short", "none"
    float entryPrice = na
    float currentPnL = 0.0
    float totalPnL = 0.0
    int totalTrades = 0
    int winningTrades = 0
    float maxDrawdown = 0.0
    float peakPnL = 0.0
    float troughPnL = 0.0
    float largestWin = 0.0
    float largestLoss = 0.0
    float grossProfit = 0.0
    float grossLoss = 0.0
    int longTrades = 0
    int shortTrades = 0
    int longWins = 0
    int shortWins = 0
    float longPnL = 0.0
    float shortPnL = 0.0
    float commission = 0.0
    float slippage = 0.0

// Initialize 10 Virtual Accounts (one for each signal)
var VirtualAccount virtualAccount1 = VirtualAccount.new()
var VirtualAccount virtualAccount2 = VirtualAccount.new()
var VirtualAccount virtualAccount3 = VirtualAccount.new()
var VirtualAccount virtualAccount4 = VirtualAccount.new()
var VirtualAccount virtualAccount5 = VirtualAccount.new()
var VirtualAccount virtualAccount6 = VirtualAccount.new()
var VirtualAccount virtualAccount7 = VirtualAccount.new()
var VirtualAccount virtualAccount8 = VirtualAccount.new()
var VirtualAccount virtualAccount9 = VirtualAccount.new()
var VirtualAccount virtualAccount10 = VirtualAccount.new()

// Array of virtual accounts for easy iteration
var array<VirtualAccount> virtualAccounts = array.from(virtualAccount1, virtualAccount2, virtualAccount3, virtualAccount4, virtualAccount5, virtualAccount6, virtualAccount7, virtualAccount8, virtualAccount9, virtualAccount10)

// Commission and Slippage Configuration
commissionPerTrade = input.float(2.50, '💰 Commission Per Trade', minval=0.0, step=0.25, group='💼 Virtual Account Settings', tooltip='Commission cost per trade (both entry and exit)')
slippagePerTrade = input.float(0.50, '📉 Slippage Per Trade', minval=0.0, step=0.25, group='💼 Virtual Account Settings', tooltip='Slippage cost per trade (market impact)')
virtualPositionSize = input.int(1, '📊 Virtual Position Size', minval=1, group='💼 Virtual Account Settings', tooltip='Position size for virtual accounts (contracts/shares)')

// Parameter Change Detection System
var int lastParameterHash = na
var bool parametersChanged = false

// Calculate parameter hash for change detection (will be called after inputs are declared)
calculateParameterHash() =>
    // Hash key parameters that affect backtesting
    hashFloat = 0.0
    hashFloat += commissionPerTrade * 1000
    hashFloat += slippagePerTrade * 1000
    hashFloat += virtualPositionSize * 100
    // Signal enables will be added later after they're declared
    int(hashFloat)

// Reset all virtual accounts when parameters change
resetVirtualAccounts() =>
    for i = 0 to array.size(virtualAccounts) - 1
        account = array.get(virtualAccounts, i)
        account.inPosition := false
        account.direction := "none"
        account.entryPrice := na
        account.currentPnL := 0.0
        account.totalPnL := 0.0
        account.totalTrades := 0
        account.winningTrades := 0
        account.maxDrawdown := 0.0
        account.peakPnL := 0.0
        account.troughPnL := 0.0
        account.largestWin := 0.0
        account.largestLoss := 0.0
        account.grossProfit := 0.0
        account.grossLoss := 0.0
        account.longTrades := 0
        account.shortTrades := 0
        account.longWins := 0
        account.shortWins := 0
        account.longPnL := 0.0
        account.shortPnL := 0.0
        account.commission := 0.0
        account.slippage := 0.0

// Virtual Account Trading Functions
processVirtualTrade(VirtualAccount account, bool longSignal, bool shortSignal, string signalName, int signalIndex) =>
    // Calculate point value for accurate P&L
    pointValue = syminfo.pointvalue * futuresMultiplier
    
    // Entry Logic
    if not account.inPosition
        if longSignal
            account.inPosition := true
            account.direction := "long"
            account.entryPrice := close
            account.totalTrades += 1
            account.longTrades += 1
            account.commission += commissionPerTrade
            account.slippage += slippagePerTrade
            if debugEnabled
                debugMessage("VIRTUAL", signalName + " Virtual Long Entry @ " + str.tostring(close), color.lime, color.white, 0.4)
        else if shortSignal
            account.inPosition := true
            account.direction := "short"
            account.entryPrice := close
            account.totalTrades += 1
            account.shortTrades += 1
            account.commission += commissionPerTrade
            account.slippage += slippagePerTrade
            if debugEnabled
                debugMessage("VIRTUAL", signalName + " Virtual Short Entry @ " + str.tostring(close), color.red, color.white, 0.4)
    
    // Update current P&L for open positions
    if account.inPosition
        if account.direction == "long"
            rawPnL = (close - account.entryPrice) * virtualPositionSize * pointValue
            account.currentPnL := rawPnL - account.commission - account.slippage
        else if account.direction == "short"
            rawPnL = (account.entryPrice - close) * virtualPositionSize * pointValue
            account.currentPnL := rawPnL - account.commission - account.slippage
        
        // Update peak and trough for drawdown calculation
        if account.currentPnL > account.peakPnL
            account.peakPnL := account.currentPnL
        if account.currentPnL < account.troughPnL
            account.troughPnL := account.currentPnL
        
        // Calculate current drawdown
        currentDrawdown = account.peakPnL - account.currentPnL
        if currentDrawdown > account.maxDrawdown
            account.maxDrawdown := currentDrawdown

// Exit Logic (simplified - using opposite signal as exit for now)
processVirtualExit(VirtualAccount account, bool exitSignal, string signalName, int signalIndex) =>
    if account.inPosition and exitSignal
        // Calculate final P&L
        pointValue = syminfo.pointvalue * futuresMultiplier
        finalPnL = 0.0  // Declare at function scope
        if account.direction == "long"
            rawPnL = (close - account.entryPrice) * virtualPositionSize * pointValue
            finalPnL := rawPnL - account.commission - account.slippage
            account.longPnL += finalPnL
        else if account.direction == "short"
            rawPnL = (account.entryPrice - close) * virtualPositionSize * pointValue
            finalPnL := rawPnL - account.commission - account.slippage
            account.shortPnL += finalPnL
        
        // Update statistics
        account.totalPnL += finalPnL
        if finalPnL > 0
            account.winningTrades += 1
            account.grossProfit += finalPnL
            if account.direction == "long"
                account.longWins += 1
            else
                account.shortWins += 1
            if finalPnL > account.largestWin
                account.largestWin := finalPnL
        else
            account.grossLoss += math.abs(finalPnL)
            if finalPnL < account.largestLoss
                account.largestLoss := finalPnL
        
        // Reset position
        account.inPosition := false
        account.direction := "none"
        account.entryPrice := na
        account.currentPnL := 0.0
        account.commission := 0.0
        account.slippage := 0.0
        
        if debugEnabled
            debugMessage("VIRTUAL", signalName + " Virtual Exit @ " + str.tostring(close) + " P&L: $" + str.tostring(finalPnL, "#.##"), finalPnL > 0 ? color.lime : color.red, color.white, 0.5)

// ═══════════════════ MULTI-SIGNAL INPUT SYSTEM ═══════════════════
// ─────────────────── SIGNAL SOURCE INPUTS ───────────────────
signal1Enable = input.bool(true, '📊 Signal 1', inline = 'sig1', group = '🔄 Multi-Signals', tooltip = 'Primary signal source')
signal1LongSrc = input.source(close, 'Long', inline = 'sig1', group = '🔄 Multi-Signals', tooltip = 'Connect to: LuxAlgo Long, UTBot Long, or any Long signal plot')
signal1ShortSrc = input.source(close, 'Short', inline = 'sig1', group = '🔄 Multi-Signals', tooltip = 'Connect to: LuxAlgo Short, UTBot Short, or any Short signal plot')
signal1Name = input.string('LuxAlgo', 'Name', inline = 'sig1name', group = '🔄 Multi-Signals')
signal1Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig1name', group = '🔄 Multi-Signals')
signal1OnlyMode = input.bool(false, 'Only', inline = 'sig1only', group = '🔄 Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')
signal1TrendEnable = input.bool(false, '   └─ Use as Trend Indicator', group = '🔄 Multi-Signals', tooltip = 'Include this signal in trend majority calculation')

signal2Enable = input.bool(false, '📊 Signal 2', inline = 'sig2', group = '🔄 Multi-Signals')
signal2LongSrc = input.source(close, 'Long', inline = 'sig2', group = '🔄 Multi-Signals', tooltip = 'Connect to: UTBot Long, Wonder Long, or any Long signal plot')
signal2ShortSrc = input.source(close, 'Short', inline = 'sig2', group = '🔄 Multi-Signals', tooltip = 'Connect to: UTBot Short, Wonder Short, or any Short signal plot')
signal2Name = input.string('UTBot', 'Name', inline = 'sig2name', group = '🔄 Multi-Signals')
signal2Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig2name', group = '🔄 Multi-Signals')
signal2OnlyMode = input.bool(false, 'Only', inline = 'sig2only', group = '🔄 Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')
signal2TrendEnable = input.bool(false, '   └─ Use as Trend Indicator', group = '🔄 Multi-Signals', tooltip = 'Include this signal in trend majority calculation')

signal3Enable = input.bool(false, '📊 Signal 3', inline = 'sig3', group = '🔄 Multi-Signals')
signal3LongSrc = input.source(close, 'Long', inline = 'sig3', group = '🔄 Multi-Signals')
signal3ShortSrc = input.source(close, 'Short', inline = 'sig3', group = '🔄 Multi-Signals')
signal3Name = input.string('VIDYA', 'Name', inline = 'sig3name', group = '🔄 Multi-Signals')
signal3Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig3name', group = '🔄 Multi-Signals')
signal3OnlyMode = input.bool(false, 'Only', inline = 'sig3only', group = '🔄 Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')
signal3TrendEnable = input.bool(false, '   └─ Use as Trend Indicator', group = '🔄 Multi-Signals', tooltip = 'Include this signal in trend majority calculation')

signal4Enable = input.bool(false, '📊 Signal 4', inline = 'sig4', group = '🔄 Multi-Signals')
signal4LongSrc = input.source(close, 'Long', inline = 'sig4', group = '🔄 Multi-Signals')
signal4ShortSrc = input.source(close, 'Short', inline = 'sig4', group = '🔄 Multi-Signals')
signal4Name = input.string('KyleAlgo', 'Name', inline = 'sig4name', group = '🔄 Multi-Signals')
signal4Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig4name', group = '🔄 Multi-Signals')
signal4OnlyMode = input.bool(false, 'Only', inline = 'sig4only', group = '🔄 Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')
signal4TrendEnable = input.bool(false, '   └─ Use as Trend Indicator', group = '🔄 Multi-Signals', tooltip = 'Include this signal in trend majority calculation')

signal5Enable = input.bool(false, '📊 Signal 5', inline = 'sig5', group = '🔄 Multi-Signals')
signal5LongSrc = input.source(close, 'Long', inline = 'sig5', group = '🔄 Multi-Signals')
signal5ShortSrc = input.source(close, 'Short', inline = 'sig5', group = '🔄 Multi-Signals')
signal5Name = input.string('Wonder', 'Name', inline = 'sig5name', group = '🔄 Multi-Signals')
signal5Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig5name', group = '🔄 Multi-Signals')
signal5OnlyMode = input.bool(false, 'Only', inline = 'sig5only', group = '🔄 Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')
signal5TrendEnable = input.bool(false, '   └─ Use as Trend Indicator', group = '🔄 Multi-Signals', tooltip = 'Include this signal in trend majority calculation')

signal6Enable = input.bool(false, '📊 Signal 6', inline = 'sig6', group = '🔄 Multi-Signals')
signal6LongSrc = input.source(close, 'Long', inline = 'sig6', group = '🔄 Multi-Signals')
signal6ShortSrc = input.source(close, 'Short', inline = 'sig6', group = '🔄 Multi-Signals')
signal6Name = input.string('Signal 6', 'Name', inline = 'sig6name', group = '🔄 Multi-Signals')
signal6Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig6name', group = '🔄 Multi-Signals')
signal6OnlyMode = input.bool(false, 'Only', inline = 'sig6only', group = '🔄 Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')
signal6TrendEnable = input.bool(false, '   └─ Use as Trend Indicator', group = '🔄 Multi-Signals', tooltip = 'Include this signal in trend majority calculation')

signal7Enable = input.bool(false, '📊 Signal 7', inline = 'sig7', group = '🔄 Multi-Signals')
signal7LongSrc = input.source(close, 'Long', inline = 'sig7', group = '🔄 Multi-Signals')
signal7ShortSrc = input.source(close, 'Short', inline = 'sig7', group = '🔄 Multi-Signals')
signal7Name = input.string('Signal 7', 'Name', inline = 'sig7name', group = '🔄 Multi-Signals')
signal7Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig7name', group = '🔄 Multi-Signals')
signal7OnlyMode = input.bool(false, 'Only', inline = 'sig7only', group = '🔄 Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')
signal7TrendEnable = input.bool(false, '   └─ Use as Trend Indicator', group = '🔄 Multi-Signals', tooltip = 'Include this signal in trend majority calculation')

signal8Enable = input.bool(false, '📊 Signal 8', inline = 'sig8', group = '🔄 Multi-Signals')
signal8LongSrc = input.source(close, 'Long', inline = 'sig8', group = '🔄 Multi-Signals')
signal8ShortSrc = input.source(close, 'Short', inline = 'sig8', group = '🔄 Multi-Signals')
signal8Name = input.string('Signal 8', 'Name', inline = 'sig8name', group = '🔄 Multi-Signals')
signal8Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig8name', group = '🔄 Multi-Signals')
signal8OnlyMode = input.bool(false, 'Only', inline = 'sig8only', group = '🔄 Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')
signal8TrendEnable = input.bool(false, '   └─ Use as Trend Indicator', group = '🔄 Multi-Signals', tooltip = 'Include this signal in trend majority calculation')

signal9Enable = input.bool(false, '📊 Signal 9', inline = 'sig9', group = '🔄 Multi-Signals')
signal9LongSrc = input.source(close, 'Long', inline = 'sig9', group = '🔄 Multi-Signals')
signal9ShortSrc = input.source(close, 'Short', inline = 'sig9', group = '🔄 Multi-Signals')
signal9Name = input.string('Signal 9', 'Name', inline = 'sig9name', group = '🔄 Multi-Signals')
signal9Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig9name', group = '🔄 Multi-Signals')
signal9OnlyMode = input.bool(false, 'Only', inline = 'sig9only', group = '🔄 Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')
signal9TrendEnable = input.bool(false, '   └─ Use as Trend Indicator', group = '🔄 Multi-Signals', tooltip = 'Include this signal in trend majority calculation')

signal10Enable = input.bool(false, '📊 Signal 10', inline = 'sig10', group = '🔄 Multi-Signals')
signal10LongSrc = input.source(close, 'Long', inline = 'sig10', group = '🔄 Multi-Signals')
signal10ShortSrc = input.source(close, 'Short', inline = 'sig10', group = '🔄 Multi-Signals')
signal10Name = input.string('Signal 10', 'Name', inline = 'sig10name', group = '🔄 Multi-Signals')
signal10Usage = input.string('Entry All', 'Usage', options = ['Entry All', 'Entry Long Only', 'Entry Short Only', 'Exit All', 'Exit Long Only', 'Exit Short Only', 'Observe'], inline = 'sig10name', group = '🔄 Multi-Signals')
signal10OnlyMode = input.bool(false, 'Only', inline = 'sig10only', group = '🔄 Multi-Signals', tooltip = 'Make this the ONLY active signal (for individual testing)')
signal10TrendEnable = input.bool(false, '   └─ Use as Trend Indicator', group = '🔄 Multi-Signals', tooltip = 'Include this signal in trend majority calculation')

// ─────────────────── SIGNAL PROCESSING ───────────────────
// Process signals directly - most indicators (UTBot, LuxAlgo) output pulse signals
// Handle both boolean and numeric signal types
// IMPORTANT: Only process real signals, not default 'close' values
// Simple direct signal detection - no complex change detection needed
// Check if any "Only Mode" is active (for individual signal testing)
anyOnlyModeActive = signal1OnlyMode or signal2OnlyMode or signal3OnlyMode or signal4OnlyMode or signal5OnlyMode or signal6OnlyMode or signal7OnlyMode or signal8OnlyMode or signal9OnlyMode or signal10OnlyMode

// Process all signals with "Only Mode" logic (FIXED - properly ignore 'close' as signal)
// Only trigger signals if the source is NOT the default 'close' AND the signal condition is met
sig1Long = signal1Enable and signal1LongSrc != close and (signal1LongSrc > 0 or bool(signal1LongSrc) == true)
sig1Short = signal1Enable and signal1ShortSrc != close and (signal1ShortSrc > 0 or bool(signal1ShortSrc) == true)
sig2Long = signal2Enable and signal2LongSrc != close and (signal2LongSrc > 0 or bool(signal2LongSrc) == true)
sig2Short = signal2Enable and signal2ShortSrc != close and (signal2ShortSrc > 0 or bool(signal2ShortSrc) == true)
sig3Long = signal3Enable and signal3LongSrc != close and (signal3LongSrc > 0 or bool(signal3LongSrc) == true)
sig3Short = signal3Enable and signal3ShortSrc != close and (signal3ShortSrc > 0 or bool(signal3ShortSrc) == true)
sig4Long = signal4Enable and signal4LongSrc != close and (signal4LongSrc > 0 or bool(signal4LongSrc) == true)
sig4Short = signal4Enable and signal4ShortSrc != close and (signal4ShortSrc > 0 or bool(signal4ShortSrc) == true)
sig5Long = signal5Enable and signal5LongSrc != close and (signal5LongSrc > 0 or bool(signal5LongSrc) == true)
sig5Short = signal5Enable and signal5ShortSrc != close and (signal5ShortSrc > 0 or bool(signal5ShortSrc) == true)
sig6Long = signal6Enable and signal6LongSrc != close and (signal6LongSrc > 0 or bool(signal6LongSrc) == true)
sig6Short = signal6Enable and signal6ShortSrc != close and (signal6ShortSrc > 0 or bool(signal6ShortSrc) == true)
sig7Long = signal7Enable and signal7LongSrc != close and (signal7LongSrc > 0 or bool(signal7LongSrc) == true)
sig7Short = signal7Enable and signal7ShortSrc != close and (signal7ShortSrc > 0 or bool(signal7ShortSrc) == true)
sig8Long = signal8Enable and signal8LongSrc != close and (signal8LongSrc > 0 or bool(signal8LongSrc) == true)
sig8Short = signal8Enable and signal8ShortSrc != close and (signal8ShortSrc > 0 or bool(signal8ShortSrc) == true)
sig9Long = signal9Enable and signal9LongSrc != close and (signal9LongSrc > 0 or bool(signal9LongSrc) == true)
sig9Short = signal9Enable and signal9ShortSrc != close and (signal9ShortSrc > 0 or bool(signal9ShortSrc) == true)
sig10Long = signal10Enable and signal10LongSrc != close and (signal10LongSrc > 0 or bool(signal10LongSrc) == true)
sig10Short = signal10Enable and signal10ShortSrc != close and (signal10ShortSrc > 0 or bool(signal10ShortSrc) == true)

// Apply "Only Mode" logic - if any "Only" is active, disable all signals except the one in "Only Mode"
if anyOnlyModeActive
    sig1Long := signal1OnlyMode ? sig1Long : false
    sig1Short := signal1OnlyMode ? sig1Short : false
    sig2Long := signal2OnlyMode ? sig2Long : false
    sig2Short := signal2OnlyMode ? sig2Short : false
    sig3Long := signal3OnlyMode ? sig3Long : false
    sig3Short := signal3OnlyMode ? sig3Short : false
    sig4Long := signal4OnlyMode ? sig4Long : false
    sig4Short := signal4OnlyMode ? sig4Short : false
    sig5Long := signal5OnlyMode ? sig5Long : false
    sig5Short := signal5OnlyMode ? sig5Short : false
    sig6Long := signal6OnlyMode ? sig6Long : false
    sig6Short := signal6OnlyMode ? sig6Short : false
    sig7Long := signal7OnlyMode ? sig7Long : false
    sig7Short := signal7OnlyMode ? sig7Short : false
    sig8Long := signal8OnlyMode ? sig8Long : false
    sig8Short := signal8OnlyMode ? sig8Short : false
    sig9Long := signal9OnlyMode ? sig9Long : false
    sig9Short := signal9OnlyMode ? sig9Short : false
    sig10Long := signal10OnlyMode ? sig10Long : false
    sig10Short := signal10OnlyMode ? sig10Short : false

// ─────────────────── SIGNAL ARRAYS FOR PROCESSING ───────────────────
// Signal arrays for processing and count tracking (expanded to 10 signals)
allLongSignals = array.new<bool>(10)
allShortSignals = array.new<bool>(10)
array.set(allLongSignals, 0, sig1Long)
array.set(allLongSignals, 1, sig2Long)
array.set(allLongSignals, 2, sig3Long)
array.set(allLongSignals, 3, sig4Long)
array.set(allLongSignals, 4, sig5Long)
array.set(allLongSignals, 5, sig6Long)
array.set(allLongSignals, 6, sig7Long)
array.set(allLongSignals, 7, sig8Long)
array.set(allLongSignals, 8, sig9Long)
array.set(allLongSignals, 9, sig10Long)
array.set(allShortSignals, 0, sig1Short)
array.set(allShortSignals, 1, sig2Short)
array.set(allShortSignals, 2, sig3Short)
array.set(allShortSignals, 3, sig4Short)
array.set(allShortSignals, 4, sig5Short)
array.set(allShortSignals, 5, sig6Short)
array.set(allShortSignals, 6, sig7Short)
array.set(allShortSignals, 7, sig8Short)
array.set(allShortSignals, 8, sig9Short)
array.set(allShortSignals, 9, sig10Short)

// Count active signals (all 10 signals)
var int longSignalCount = 0
var int shortSignalCount = 0
longSignalCount := (sig1Long ? 1 : 0) + (sig2Long ? 1 : 0) + (sig3Long ? 1 : 0) + (sig4Long ? 1 : 0) + (sig5Long ? 1 : 0) + (sig6Long ? 1 : 0) + (sig7Long ? 1 : 0) + (sig8Long ? 1 : 0) + (sig9Long ? 1 : 0) + (sig10Long ? 1 : 0)
shortSignalCount := (sig1Short ? 1 : 0) + (sig2Short ? 1 : 0) + (sig3Short ? 1 : 0) + (sig4Short ? 1 : 0) + (sig5Short ? 1 : 0) + (sig6Short ? 1 : 0) + (sig7Short ? 1 : 0) + (sig8Short ? 1 : 0) + (sig9Short ? 1 : 0) + (sig10Short ? 1 : 0)

// ═══════════════════ PARAMETER CHANGE DETECTION ═══════════════════
// Enhanced hash calculation with all signal enables
calculateParameterHashWithSignals() =>
    hashFloat = 0.0
    hashFloat += commissionPerTrade * 1000
    hashFloat += slippagePerTrade * 1000
    hashFloat += virtualPositionSize * 100
    hashFloat += signal1Enable ? 1 : 0
    hashFloat += signal2Enable ? 2 : 0
    hashFloat += signal3Enable ? 4 : 0
    hashFloat += signal4Enable ? 8 : 0
    hashFloat += signal5Enable ? 16 : 0
    hashFloat += signal6Enable ? 32 : 0
    hashFloat += signal7Enable ? 64 : 0
    hashFloat += signal8Enable ? 128 : 0
    hashFloat += signal9Enable ? 256 : 0
    hashFloat += signal10Enable ? 512 : 0
    int(hashFloat)

// Check for parameter changes
currentParameterHash = calculateParameterHashWithSignals()
if na(lastParameterHash) or lastParameterHash != currentParameterHash
    parametersChanged := true
    resetVirtualAccounts()
    lastParameterHash := currentParameterHash
    if debugEnabled
        debugMessage("SYSTEM", "Parameters changed - Virtual accounts reset", color.orange, color.white, 0.3)
else
    parametersChanged := false

// ═══════════════════ VIRTUAL ACCOUNT PROCESSING ═══════════════════
// MOVED TO AFTER BIAS CALCULATIONS (after line 869)

// ═══════════════════ PRIMARY SIGNAL COMBINATION ═══════════════════
// Note: Primary signals are defined below after imports (line 126-127)

// ═══════════════════ RBW FILTER IMPORT ═══════════════════
// Import enhanced_ta library for existing RBW filter (defined later)
import HeWhoMustNotBeNamed/enhanced_ta/14 as eta

// ═══════════════════ SIGNAL PROCESSING SETUP ═══════════════════
// Legacy compatibility - combine all signals (expanded to 10 signals)
primaryLongSig = sig1Long or sig2Long or sig3Long or sig4Long or sig5Long or sig6Long or sig7Long or sig8Long or sig9Long or sig10Long
primaryShortSig = sig1Short or sig2Short or sig3Short or sig4Short or sig5Short or sig6Short or sig7Short or sig8Short or sig9Short or sig10Short

// ─────────────────── 1 · TRADERSPOST JSON HELPERS ───────────────

// ───── Pre-built JSON messages (compile-time constants) ─────
// Use TradingView alert placeholders so we avoid any per-bar string operations.
// Placeholders {{close}} and {{timenow}} will be expanded at alert trigger time.
var string _jsonBase = '{"ticker":"' + syminfo.ticker + '","price":{{close}},"time":{{timenow}}'

var string longEntryMsg = _jsonBase + ',"action":"buy","sentiment":"long"}'
var string shortEntryMsg = _jsonBase + ',"action":"sell","sentiment":"short"}'
var string flatExitMsg = _jsonBase + ',"action":"exit","sentiment":"flat"}'
var string longExitMsg = _jsonBase + ',"action":"sell","sentiment":"flat"}' // closes long
var string shortExitMsg = _jsonBase + ',"action":"buy","sentiment":"flat"}' // closes short

// ─────────────────── 2 · ATR SETTINGS ───────────────────────────
atrLen = input.int(14, 'ATR Length', minval = 1, group = 'ATR Settings')
atrVal = ta.atr(atrLen)
// Extract ta.sma calculation for volatility alert (fixes compilation warning)
atrAvg = ta.sma(atrVal, 20)

// ─────────────────── 3 · EXIT PARAMETERS (ASCII SAFE) ───────────
maExitOn = input.bool(false, 'Enable MA Exit', group = '📈 MA Exit')
maLen = input.int(21, 'MA Length', minval = 1, group = '📈 MA Exit')
maType = input.string('EMA', 'MA Type', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA'], group = '📈 MA Exit')
// INTRABAR EXITS RESTORED - exits now trigger immediately when conditions are met

priceMA = maType == 'SMA' ? ta.sma(close, maLen) : maType == 'EMA' ? ta.ema(close, maLen) : maType == 'WMA' ? ta.wma(close, maLen) : maType == 'VWMA' ? ta.vwma(close, maLen) : ta.rma(close, maLen)

fixedEnable = input.bool(false, 'Enable Fixed SL/TP', group = '🎯 Fixed SL/TP')
fixedUnit = input.string('ATR', 'Unit', options = ['ATR', 'Points'], group = '🎯 Fixed SL/TP')
fixedStop = input.float(1.0, 'Stop Size', step = 0.1, minval = 0.0, group = '🎯 Fixed SL/TP')

tpCalc(d) =>
    fixedUnit == 'ATR' ? d * atrVal : d

tp1Enable = input.bool(false, 'TP1 Enable', inline = 'tp1', group = '🎯 Fixed SL/TP', tooltip = 'Enable single take profit target')
tp1Size = input.float(1.5, 'TP1 Size', inline = 'tp1', group = '🎯 Fixed SL/TP', tooltip = 'Take profit size in ATR multiples')
// NOTE: Multiple TP targets removed - only single TP supported in current implementation

// Smart Profit Locker (Aggressive Profit Protection)
smartProfitEnable = input.bool(true, '🎯 Enable Smart Profit Locker', group = 'Smart Profit Locker', tooltip = 'Aggressive profit-taking with adjustable pullback sensitivity')
smartProfitType = input.string('ATR', 'Type', options = ['ATR', 'Points', 'Percent'], group = 'Smart Profit Locker')
smartProfitVal = input.float(3.1, 'Value', step = 0.1, group = 'Smart Profit Locker')
smartProfitOffset = input.float(0.10, 'Pullback %', step = 0.05, minval = 0.01, maxval = 1.0, group = 'Smart Profit Locker', tooltip = 'Pullback percentage to trigger exit (0.10 = 10%)')

// TREND CHANGE EXIT SYSTEM
// Simple and effective: exit when any enabled trend indicator gives opposite signal
trendChangeExitEnable = input.bool(false, '📈 DEPRECATED — Legacy Trend Change Exit (DO NOT USE)', group = '🛑 DEPRECATED – Legacy Trend Change Exit', tooltip = 'Deprecated basic trend-change exit.  Use Advanced Trend Exit instead.  Keep OFF for production.')

// REMOVED: Stand-alone Hybrid Exit System - replaced by Advanced Trend Exit's internal hybrid mode
// Use trendExitEnable + hybridModeEnable instead for hybrid functionality

// ═══════════════════ ADVANCED TREND EXIT SYSTEM ═══════════════════
// Linear Regression Candle-based exit with trailing stop protection and re-entry logic

// Enable Trend Exit Modes
trendExitEnable = input.bool(false, '🎯 Enable Advanced Trend Exit', group = '🎯 Advanced Trend Exit', tooltip = 'Advanced exit system based on Linear Regression Candles with trailing stop protection')

// ═══════════════════ FLUID HYBRID SYSTEM ═══════════════════
// Auto-detects when both SPL + Trend Exit are enabled and automatically switches based on position size
hybridSwitchThreshold = input.int(2, 'Auto-Hybrid: Switch at Contracts', minval=1, maxval=10, group = '🔄 Fluid Hybrid System', tooltip='When both SPL + Trend Exit enabled: use SPL for positions < threshold, Trend Exit for positions ≥ threshold')

// FLUID HYBRID SYSTEM INFO (Read-only display)
// This system automatically activates when BOTH Smart Profit Locker + Advanced Trend Exit are enabled
// • Small positions (< threshold): Uses SPL for quick scalping
// • Large positions (≥ threshold): Uses Trend Exit for holding/riding trends  
// • Single system enabled: Functions normally (no hybrid behavior)
// • Re-entry is enabled by default for fluid trading experience

// Phase 1: REMOVED - No competing trailing stops (SPL handles all trailing stop logic)

// Phase 2: Exit Mode Selection  
exitMode = input.string('Color Change', 'Exit Signal Type', options=['Color Change', 'MA Cross'], group = '🎯 Advanced Trend Exit', tooltip = 'Color Change = Exit on Linear Regression candle color change | MA Cross = Exit on Bull/Bear MA crosses')

// Phase 3: Re-Entry System
reEntryEnable = input.bool(true, '🔄 Enable Re-Entry', group = '🔄 Fluid Hybrid System', tooltip = 'After trend exit, re-enter when color changes back (if trend indicators confirm) - DEFAULT ON for fluid trading')
reEntryConfirmation = input.string('Majority', 'Re-Entry Confirmation', options=['All', 'Majority'], group = '🎯 Advanced Trend Exit', tooltip = 'Require All (3/3) or Majority (2/3) trend indicators to confirm re-entry direction')

// Linear Regression Candle Inputs (Primary Exit Signal)
lrcBullColorChange = input.source(close, '🟢 Bull Color Change', group = '📊 Linear Regression Candles', tooltip = 'Connect to Linear Regression Candles Bull Color Change plot')
lrcBearColorChange = input.source(close, '🔴 Bear Color Change', group = '📊 Linear Regression Candles', tooltip = 'Connect to Linear Regression Candles Bear Color Change plot')
lrcBullMAXross = input.source(close, '📈 Bull MA Cross', group = '📊 Linear Regression Candles', tooltip = 'Connect to Linear Regression Candles Bull MA Cross plot')
lrcBearMACross = input.source(close, '📉 Bear MA Cross', group = '📊 Linear Regression Candles', tooltip = 'Connect to Linear Regression Candles Bear MA Cross plot')

// ═══════════════════ OLD TREND SECTION REMOVED ═══════════════════
// Trend detection now uses checkbox system in Multi-Signals section above
// This eliminates redundant configuration and leverages profitable signals for both entry AND trend confirmation

// ─────────────────── BB EXIT VARIABLES (moved up for scope) ────────────
bbExitEnable = input.bool(false, '⚡ BB Exit Logic', group='🎯 Bollinger Band Risk Management', inline='bb2', tooltip='OPTIONAL: When price hits BB extreme during trade, flip to tight Smart Profit Locker.')
bbExitTightness = input.float(0.5, 'Tight Mult', minval=0.1, maxval=1.0, step=0.1, group='🎯 Bollinger Band Risk Management', inline='bb2', tooltip='Smart Profit Locker multiplier when BB exit triggers. 0.5 = half normal distance (tighter).')
var bool bbExitTriggered = false

// ─────────────────── 4. SMART PROFIT LOCKER (Aggressive Profit Protection) ────────────
// HYBRID EXIT INTEGRATION: Switch between Smart Profit Locker and Trend Change Exit

// SMART PROFIT LOCKER - SIMPLIFIED  
// Smart Profit Locker: Uses fluid hybrid auto-detection
// shouldUseSPL is set by the auto-detection logic above
    
if shouldUseSPL
    // Calculate Smart Profit Locker distance and offset
    smartDistance := smartProfitType == 'ATR' ? smartProfitVal * atrVal : smartProfitType == 'Points' ? smartProfitVal : strategyEntryPrice * smartProfitVal / 100.0
    
    // Apply BB Exit tightening if triggered
    if bbExitTriggered
        smartDistance := smartDistance * bbExitTightness
        smartOffset := smartDistance * math.max(smartProfitOffset, 0.01)
        if not trailExitSent  // Only show message once
            debugMessage("INFO", "⚡ BB TIGHT MODE: Smart Profit Locker tightened to " + str.tostring(smartDistance, "#.##") + " pts (" + str.tostring(bbExitTightness * 100) + "% of normal)", color.orange, color.white, 0.05)
    else
        smartOffset := smartDistance * math.max(smartProfitOffset, 0.01)
    
    // Ensure distances are valid
    if na(smartDistance) or smartDistance <= 0
        smartDistance := 50.0  // Safe default value in points
    if na(smartOffset) or smartOffset <= 0
        smartOffset := 5.0  // Safe default offset
    
    if strategy.position_size > 0  // Long position
        strategy.exit('Smart-Long', from_entry='Long', trail_points=math.max(smartDistance, 0.01), trail_offset=math.max(smartOffset, 0.01), comment='Smart Profit Locker')
        if not trailExitSent
            trailExitSent := true
            debugMessage("INFO", "🎯 Smart Profit Locker activated - Distance: " + str.tostring(smartDistance, "#.##") + " pts", color.green, color.white, 0.05)
    else if strategy.position_size < 0  // Short position
        strategy.exit('Smart-Short', from_entry='Short', trail_points=math.max(smartDistance, 0.01), trail_offset=math.max(smartOffset, 0.01), comment='Smart Profit Locker')
        if not trailExitSent
            trailExitSent := true
            debugMessage("INFO", "🎯 Smart Profit Locker activated - Distance: " + str.tostring(smartDistance, "#.##") + " pts", color.green, color.white, 0.05)

// OLD TREND CHANGE EXIT SYSTEM - REMOVED
// This old system was interfering with the new Advanced Trend Exit System
// All trend change exit logic is now handled by the Advanced Trend Exit System below

// RBW DIRECTIONAL FILTER
// Compact multi-column panel for volatility-based directional bias
rbwEnable = input.bool(false, '📊 Enable RBW Filter', group='📊 Relative Bandwidth Filter', inline='rbw0')

// Band Type Selection (Row 1)
rbwBandType = input.string("KC", "Band Type", group='📊 Relative Bandwidth Filter', options=["BB", "KC", "DC"], inline='rbw1')
rbwSource = input.source(close, "Source", group='📊 Relative Bandwidth Filter', inline='rbw1')

// Band Parameters (Row 2) 
rbwLength = input.int(100, "Length", group='📊 Relative Bandwidth Filter', inline='rbw2')
rbwMultiplier = input.float(2.0, "Mult", step=0.5, group='📊 Relative Bandwidth Filter', inline='rbw2')

// Additional Options (Row 3)
rbwUseTR = input.bool(true, "Use TR", group='📊 Relative Bandwidth Filter', inline='rbw3')
rbwUseAltSrc = input.bool(false, "Alt Src", group='📊 Relative Bandwidth Filter', inline='rbw3')

// Signal Configuration (Row 4)
rbwDesiredCond = input.string("Higher Bandwidth", "Condition", group='📊 Relative Bandwidth Filter', options=["Higher Bandwidth", "Lower Bandwidth"], inline='rbw4')
rbwRefBand = input.string("Middle", "Reference", group='📊 Relative Bandwidth Filter', options=["Upper", "Lower", "Middle"], inline='rbw4')

// ATR and Filter Settings (Row 5)
rbwATRLength = input.int(20, "ATR Len", group='📊 Relative Bandwidth Filter', inline='rbw5')
rbwBBType = input.string("sma", "BB Type", group='📊 Relative Bandwidth Filter', options=["sma", "ema", "hma", "rma", "wma", "vwma", "linreg", "median"], inline='rbw5')

// OLD TREND SIGNAL SYSTEM - REPLACED BY ADVANCED TREND EXIT SYSTEM
// This section is kept for compatibility with existing exit logic but will be phased out

// Trend logic simplified: ALL enabled filters must agree (no more voting system)

// BOLLINGER BAND RISK MANAGEMENT
// Critical risk management: Never take signals outside Bollinger Bands

// Bollinger Band Entry Filter (Row 1) - RISK MANAGEMENT
bbEntryFilterEnable = input.bool(false, '🚫 BB Entry Filter', group='🎯 Bollinger Band Risk Management', inline='bb1', tooltip='Ignore buy signals above upper BB and sell signals below lower BB. Prevents gap-open disasters.')
bbLength = input.int(20, 'BB Length', minval=5, maxval=50, group='🎯 Bollinger Band Risk Management', inline='bb1', tooltip='Bollinger Band period for entry filtering. Standard is 20.')
bbMultiplier = input.float(3.0, 'BB Mult', minval=1.0, maxval=5.0, step=0.1, group='🎯 Bollinger Band Risk Management', inline='bb1', tooltip='Bollinger Band standard deviation multiplier. Default is 3.0.')

// Bollinger Band Exit Logic (Row 2) - MOVED EARLIER FOR SCOPE
// bbExitEnable, bbExitTightness, and bbExitTriggered now declared above

// BB Calculation (moved here for BB Exit Logic) - using temp variables for exit logic
bbTemp_Middle = ta.sma(close, bbLength)
bbTemp_StdDev = ta.stdev(close, bbLength)
bbTemp_Upper = bbTemp_Middle + bbTemp_StdDev * bbMultiplier  
bbTemp_Lower = bbTemp_Middle - bbTemp_StdDev * bbMultiplier

// BB Exit Trigger Logic - Check if price hits BB extreme during trade
if bbExitEnable and strategy.position_size != 0
    longAtUpperBB = strategy.position_size > 0 and close >= bbTemp_Upper
    shortAtLowerBB = strategy.position_size < 0 and close <= bbTemp_Lower
    
    if longAtUpperBB or shortAtLowerBB
        bbExitTriggered := true
        if debugEnabled
            exitType = longAtUpperBB ? "Long at Upper BB" : "Short at Lower BB"
            debugMessage("INFO", "⚡ BB EXIT TRIGGER: " + exitType + " - Switching to tight Smart Profit Locker", color.green, color.white, 0.05)
else
    bbExitTriggered := false

// RBW Calculation Logic - Variable Declarations
var float rbwUpper = na
var float rbwLower = na
var float rbwMiddle = na
var float rbwRelativeBandwidth = na
var int rbwSignal = 0
var float rbwBBMiddle = na
var float rbwBBUpper = na
var float rbwBBLower = na
var float rbwBBStdDev = na
var float rbwRef = na
var float rbwStdDev = na
var float rbwATR = na

// Extract ta functions to avoid compilation warnings
rbwSMA = ta.sma(rbwSource, rbwLength)
rbwStdDev_calc = ta.stdev(rbwSource, rbwLength)
rbwATR_calc = rbwUseTR ? ta.atr(rbwLength) : ta.rma(high - low, rbwLength)
rbwBBMiddle_calc = ta.sma(rbwRelativeBandwidth, 100)
rbwBBStdDev_calc = ta.stdev(rbwRelativeBandwidth, 100)

if rbwEnable
    // Bollinger Bands
    if rbwBandType == "BB"
        rbwMiddle := rbwSMA
        rbwStdDev := rbwStdDev_calc
        rbwUpper := rbwMiddle + rbwStdDev * rbwMultiplier
        rbwLower := rbwMiddle - rbwStdDev * rbwMultiplier
    
    // Keltner Channels  
    else if rbwBandType == "KC"
        rbwMiddle := rbwSMA
        rbwATR := rbwATR_calc
        rbwUpper := rbwMiddle + rbwATR * rbwMultiplier
        rbwLower := rbwMiddle - rbwATR * rbwMultiplier
    
    // Donchian Channels
    else if rbwBandType == "DC"
        rbwUpper := ta.highest(rbwUseAltSrc ? high : rbwSource, rbwLength)
        rbwLower := ta.lowest(rbwUseAltSrc ? low : rbwSource, rbwLength)
        rbwMiddle := (rbwUpper + rbwLower) / 2
        rbwATR := ta.atr(rbwATRLength)

    // Relative Bandwidth calculation
    if not na(rbwUpper) and not na(rbwLower)
        // Use pre-calculated ATR
        if not na(rbwATR) and rbwATR > 0
            rbwRelativeBandwidth := (rbwUpper - rbwLower) / rbwATR
            
            // Calculate reference bands for signal (use extracted TA functions)
            rbwBBMiddle := rbwBBMiddle_calc
            rbwBBStdDev := rbwBBStdDev_calc
            rbwBBUpper := rbwBBMiddle + rbwBBStdDev * 1.0
            rbwBBLower := rbwBBMiddle - rbwBBStdDev * 1.0
            
            rbwRef := rbwRefBand == "Middle" ? rbwBBMiddle : rbwRefBand == "Upper" ? rbwBBUpper : rbwBBLower
            rbwSignal := rbwRelativeBandwidth > rbwRef ? 2 : 0
            rbwSignal := rbwDesiredCond == "Lower Bandwidth" ? math.abs(rbwSignal-2) : rbwSignal

// BOLLINGER BAND RISK MANAGEMENT CALCULATION
// Critical entry filtering: Never take signals outside Bollinger Bands

// Bollinger Band Variables
var float bbUpper = na
var float bbLower = na
var float bbMiddle = na
var bool bbEntryFilterOK = true

if bbEntryFilterEnable
    // Calculate standard Bollinger Bands for entry filtering
    bbMiddle := ta.sma(close, bbLength)
    bbStdDev = ta.stdev(close, bbLength)
    bbUpper := bbMiddle + bbStdDev * bbMultiplier
    bbLower := bbMiddle - bbStdDev * bbMultiplier
    
    // Entry filter logic: Block signals outside bands
    bbLongFilterOK := close <= bbUpper  // Allow long entries only when price is NOT above upper band
    bbShortFilterOK := close >= bbLower  // Allow short entries only when price is NOT below lower band
    
    // Debug output for BB entry filter
    if debugEnabled
        if not bbLongFilterOK
            debugMessage("WARN", "🚫 BB ENTRY FILTER: Long signal blocked - Price $" + str.tostring(close, "#.##") + " above upper BB $" + str.tostring(bbUpper, "#.##") + " - Gap/spike protection active", color.orange, color.white, 0.15)
        if not bbShortFilterOK
            debugMessage("WARN", "🚫 BB ENTRY FILTER: Short signal blocked - Price $" + str.tostring(close, "#.##") + " below lower BB $" + str.tostring(bbLower, "#.##") + " - Gap/spike protection active", color.orange, color.white, 0.15)
else
    // When disabled, allow all entries
    bbLongFilterOK := true
    bbShortFilterOK := true

// ═══════════════════ NEW TREND CHECKBOX MAJORITY RULE SYSTEM ═══════════════════
// Trend detection now uses checkbox system from Multi-Signals section
// This leverages profitable signals for BOTH entry AND trend confirmation

// Calculate trend majority from enabled signal checkboxes
calcTrendMajority() =>
    trendEnabledCount = 0
    bullishTrendCount = 0
    bearishTrendCount = 0
    
    // Check each signal's trend checkbox and current signal state
    if signal1TrendEnable and signal1Enable
        trendEnabledCount += 1
        if sig1Long: bullishTrendCount += 1
        if sig1Short: bearishTrendCount += 1
    
    if signal2TrendEnable and signal2Enable
        trendEnabledCount += 1
        if sig2Long: bullishTrendCount += 1
        if sig2Short: bearishTrendCount += 1
        
    if signal3TrendEnable and signal3Enable
        trendEnabledCount += 1
        if sig3Long: bullishTrendCount += 1
        if sig3Short: bearishTrendCount += 1
        
    if signal4TrendEnable and signal4Enable
        trendEnabledCount += 1
        if sig4Long: bullishTrendCount += 1
        if sig4Short: bearishTrendCount += 1
        
    if signal5TrendEnable and signal5Enable
        trendEnabledCount += 1
        if sig5Long: bullishTrendCount += 1
        if sig5Short: bearishTrendCount += 1
        
    if signal6TrendEnable and signal6Enable
        trendEnabledCount += 1
        if sig6Long: bullishTrendCount += 1
        if sig6Short: bearishTrendCount += 1
        
    if signal7TrendEnable and signal7Enable
        trendEnabledCount += 1
        if sig7Long: bullishTrendCount += 1
        if sig7Short: bearishTrendCount += 1
        
    if signal8TrendEnable and signal8Enable
        trendEnabledCount += 1
        if sig8Long: bullishTrendCount += 1
        if sig8Short: bearishTrendCount += 1
        
    if signal9TrendEnable and signal9Enable
        trendEnabledCount += 1
        if sig9Long: bullishTrendCount += 1
        if sig9Short: bearishTrendCount += 1
        
    if signal10TrendEnable and signal10Enable
        trendEnabledCount += 1
        if sig10Long: bullishTrendCount += 1
        if sig10Short: bearishTrendCount += 1
    
    // Return trend majority result (if no trend indicators enabled, default to true)
    trendEnabledCount == 0 ? true : bullishTrendCount > bearishTrendCount

// Calculate current trend consensus
trendsAgree = calcTrendMajority()

// ═══════════════════ LINEAR REGRESSION CANDLE PROCESSING ═══════════════════
// Process Linear Regression Candle signals for advanced trend exit

// Process LRC signals (ignore default 'close' values)
lrcBullColor = lrcBullColorChange != close and (lrcBullColorChange > 0 or bool(lrcBullColorChange) == true)
lrcBearColor = lrcBearColorChange != close and (lrcBearColorChange > 0 or bool(lrcBearColorChange) == true)
lrcBullMA = lrcBullMAXross != close and (lrcBullMAXross > 0 or bool(lrcBullMAXross) == true)
lrcBearMA = lrcBearMACross != close and (lrcBearMACross > 0 or bool(lrcBearMACross) == true)

// Trend confirmation for re-entry (now uses the majority rule from checkbox system)
trendConfirmsLong = trendsAgree  // Simplified: majority rule handles all logic
trendConfirmsShort = not trendsAgree  // Opposite of bullish majority

// ═══════════════════ FLUID HYBRID AUTO-DETECTION LOGIC ═══════════════════
// Automatically activates hybrid mode when both SPL + Trend Exit are enabled
// Natural workflow: SPL for small positions (scalping), Trend Exit for large positions (holding)

currentPositionSize = math.abs(strategy.position_size)
autoHybridMode = smartProfitEnable and trendExitEnable and strategy.position_size != 0

// Unified switching logic based on position size
if autoHybridMode and currentPositionSize >= hybridSwitchThreshold
    shouldUseTrendMode := true   // Large position = hold (Trend Exit)
    shouldUseSPL := false
else if autoHybridMode
    shouldUseTrendMode := false  // Small position = scalp (SPL)
    shouldUseSPL := true
else
    // Single-system mode: use whatever is enabled
    shouldUseTrendMode := trendExitEnable and strategy.position_size != 0
    shouldUseSPL := smartProfitEnable and strategy.position_size != 0

// SIMPLIFIED BIAS LOGIC - ONLY RBW FILTER
// Removed complex trend signal consensus - using position size for confluence instead
// Only RBW (Relative Bandwidth) provides directional bias filtering

longDirectionalBias = rbwEnable ? (rbwSignal == 2) : true    // RBW bullish or disabled (permissive)  
shortDirectionalBias = rbwEnable ? (rbwSignal == 0) : true   // RBW bearish or disabled (permissive)

// TEMPORARY TEST OVERRIDE (recommended by AI analysis) - Set to false after confirming signals work
testModeOverride = input.bool(true, "🧪 Test Mode Override", group="🛠️ Debug System", tooltip="Temporarily override all filters to allow trades for testing")
if testModeOverride
    longDirectionalBias := true
    shortDirectionalBias := true

// TREND-RIDING OVERLAY LOGIC
// Advanced exit system to "let winners run" in strong trending conditions

// Define final entry signals with directional bias and Bollinger Band Filter applied
longEntrySignal := primaryLongSig and longDirectionalBias and bbLongFilterOK
shortEntrySignal := primaryShortSig and shortDirectionalBias and bbShortFilterOK

// Debug: Track what's blocking strategy entries vs virtual accounts
if debugEnabled and (primaryLongSig or primaryShortSig)
    blockingReasons = ""
    if not longDirectionalBias and primaryLongSig
        blockingReasons += "LONG_BIAS_BLOCK "
    if not shortDirectionalBias and primaryShortSig  
        blockingReasons += "SHORT_BIAS_BLOCK "
    if not bbLongFilterOK and primaryLongSig
        blockingReasons += "BB_LONG_BLOCK "
    if not bbShortFilterOK and primaryShortSig
        blockingReasons += "BB_SHORT_BLOCK "
    
    if blockingReasons != ""
        debugMessage("FILTER", "🚫 STRATEGY BLOCKED: " + blockingReasons, color.orange, color.white, 0.6)

// Add re-entry signals to entry logic
if reEntrySignal and exitDirection == 1  // Re-entering long
    longEntrySignal := true
else if reEntrySignal and exitDirection == -1  // Re-entering short  
    shortEntrySignal := true

// Visual indicators for Advanced Trend Exit System
plotchar(inTrendExitMode, title='🎯 Trend Exit Mode', char='🎯', location=location.top, color=color.new(color.blue, 0), size=size.small)
plotchar(inProfitMode, title='💰 Profit Mode', char='💰', location=location.top, color=color.new(color.green, 0), size=size.small)
plotchar(waitingForReEntry, title='⏳ Waiting Re-Entry', char='⏳', location=location.top, color=color.new(color.orange, 0), size=size.small)
plotchar(colorChangeExit, title='🔄 Color Change Exit', char='🔄', location=location.top, color=color.new(color.red, 0), size=size.small)
plotchar(reEntrySignal, title='🚀 Re-Entry Signal', char='🚀', location=location.top, color=color.new(color.purple, 0), size=size.small)

// Plot Linear Regression Candle signals for visibility
plotchar(lrcBullColor, title='🟢 LRC Bull Color', char='🟢', location=location.bottom, color=color.new(color.lime, 0), size=size.tiny)
plotchar(lrcBearColor, title='🔴 LRC Bear Color', char='🔴', location=location.bottom, color=color.new(color.red, 0), size=size.tiny)
plotchar(lrcBullMA, title='📈 LRC Bull MA', char='📈', location=location.bottom, color=color.new(color.blue, 0), size=size.tiny)
plotchar(lrcBearMA, title='📉 LRC Bear MA', char='📉', location=location.bottom, color=color.new(color.maroon, 0), size=size.tiny)

// ═══════════════════ COMPREHENSIVE ENTRY DEBUG PLOTS (STEP 1) ═══════════════════
// Diagnostic plots to identify why trades show in backtest but not on chart

// RAW SIGNAL DETECTION
plotchar(primaryLongSig, title="1️⃣ Primary Long Signal", char='🔵', location=location.bottom, color=color.new(color.blue, 0), size=size.small)
plotchar(primaryShortSig, title="1️⃣ Primary Short Signal", char='🔴', location=location.bottom, color=color.new(color.red, 0), size=size.small)

// DIRECTIONAL BIAS FILTERS
plotchar(longDirectionalBias, title="2️⃣ Long Bias OK", char='📈', location=location.bottom, color=color.new(color.green, 0), size=size.small)
plotchar(shortDirectionalBias, title="2️⃣ Short Bias OK", char='📉', location=location.bottom, color=color.new(color.maroon, 0), size=size.small)

// BOLLINGER BAND FILTERS
plotchar(bbLongFilterOK, title="3️⃣ BB Long Filter OK", char='🟢', location=location.bottom, color=color.new(color.lime, 0), size=size.small)
plotchar(bbShortFilterOK, title="3️⃣ BB Short Filter OK", char='🟠', location=location.bottom, color=color.new(color.orange, 0), size=size.small)

// FINAL FILTERED SIGNALS
plotchar(longEntrySignal, title="4️⃣ FINAL Long Entry", char='⬆️', location=location.bottom, color=color.new(color.white, 0), size=size.large)
plotchar(shortEntrySignal, title="4️⃣ FINAL Short Entry", char='⬇️', location=location.bottom, color=color.new(color.yellow, 0), size=size.large)

// ENTRY PERMISSION STATUS
plotchar(entryAllowed, title="5️⃣ Entry Allowed", char='✅', location=location.bottom, color=color.new(color.aqua, 0), size=size.large)

// POSITION STATUS
plotchar(strategy.position_size > 0, title="📊 Long Position", char='📊', location=location.top, color=color.new(color.green, 50), size=size.small)
plotchar(strategy.position_size < 0, title="📊 Short Position", char='📊', location=location.top, color=color.new(color.red, 50), size=size.small)

// EXECUTION STATUS - Shows when trades actually execute
plotchar(longEntrySignal and entryAllowed, title="🚀 LONG EXECUTION", char='🚀', location=location.belowbar, color=color.new(color.lime, 0), size=size.large)
plotchar(shortEntrySignal and entryAllowed, title="🚀 SHORT EXECUTION", char='🚀', location=location.abovebar, color=color.new(color.red, 0), size=size.large)

// BLOCKING STATUS - Shows when entries are blocked
plotchar(longEntrySignal and not entryAllowed, title="🚫 LONG BLOCKED", char='🚫', location=location.belowbar, color=color.new(color.orange, 0), size=size.large)
plotchar(shortEntrySignal and not entryAllowed, title="🚫 SHORT BLOCKED", char='🚫', location=location.abovebar, color=color.new(color.orange, 0), size=size.large)

// PYRAMID STATUS - Shows position size vs limit
currentPositionSize = math.abs(strategy.position_size)
plotchar(currentPositionSize >= pyramidLimit, title="⚠️ PYRAMID LIMIT", char='⚠️', location=location.top, color=color.new(color.purple, 0), size=size.small)

// Debug warnings when Bollinger Band filter blocks trades (critical risk management)
if debugEnabled and bbEntryFilterEnable
    if primaryLongSig and longDirectionalBias and not bbLongFilterOK
        debugMessage("WARN", "🚫 BB FILTER BLOCKED LONG: Price " + str.tostring(close, "#.##") + " above upper BB " + str.tostring(bbUpper, "#.##") + " - Gap/spike protection active", color.orange, color.white, 0.15)
    if primaryShortSig and shortDirectionalBias and not bbShortFilterOK
        debugMessage("WARN", "🚫 BB FILTER BLOCKED SHORT: Price " + str.tostring(close, "#.##") + " below lower BB " + str.tostring(bbLower, "#.##") + " - Gap/spike protection active", color.orange, color.white, 0.15)

// Enhanced debug logging for all directional bias filters and systems  
if debugEnabled
    // Debug entry signals
    if primaryLongSig or primaryShortSig
        entryMsg = 'ENTRY SIGNALS: Long=' + str.tostring(primaryLongSig) + ' Short=' + str.tostring(primaryShortSig)
        entryMsg += ' | LongBias=' + str.tostring(longDirectionalBias) + ' ShortBias=' + str.tostring(shortDirectionalBias)
        entryMsg += ' | BBFilter: L=' + str.tostring(bbLongFilterOK) + ' S=' + str.tostring(bbShortFilterOK)
        entryMsg += ' | Final: L=' + str.tostring(longEntrySignal) + ' S=' + str.tostring(shortEntrySignal)
        debugMessage("INFO", entryMsg, color.blue, color.white, 0.05)
    
    // Debug Advanced Trend Exit System
    if useAdvancedTrendExit
        trendExitMsg = 'ADVANCED TREND EXIT:'
        trendExitMsg += ' Mode=' + (inTrendExitMode ? 'ACTIVE' : 'OFF')
        trendExitMsg += ' Phase=' + (not inTrendExitMode ? 'NONE' : inProfitMode ? 'PROFIT' : 'PROTECTION')
        trendExitMsg += ' Exit=' + exitMode
        if waitingForReEntry
            trendExitMsg += ' | WAITING_RE-ENTRY (Dir=' + str.tostring(exitDirection) + ')'
        debugMessage("INFO", trendExitMsg, color.purple, color.white, 0.05)
        
        // Debug LRC signals
        if lrcBullColor or lrcBearColor or lrcBullMA or lrcBearMA
            lrcMsg = 'LRC SIGNALS:'
            lrcMsg += ' BullColor=' + str.tostring(lrcBullColor)
            lrcMsg += ' BearColor=' + str.tostring(lrcBearColor) 
            lrcMsg += ' BullMA=' + str.tostring(lrcBullMA)
            lrcMsg += ' BearMA=' + str.tostring(lrcBearMA)
            debugMessage("INFO", lrcMsg, color.yellow, color.black, 0.05)
        
        // Debug trend confirmation
        if enabledTrendCount > 0
            confirmMsg = 'TREND CONFIRMATION:'
            confirmMsg += ' Enabled=' + str.tostring(enabledTrendCount)
            confirmMsg += ' Bull=' + str.tostring(bullishTrendCount) + '/' + str.tostring(enabledTrendCount)
            confirmMsg += ' Bear=' + str.tostring(bearishTrendCount) + '/' + str.tostring(enabledTrendCount)
            confirmMsg += ' ConfirmLong=' + str.tostring(trendConfirmsLong)
            confirmMsg += ' ConfirmShort=' + str.tostring(trendConfirmsShort)
            debugMessage("INFO", confirmMsg, color.orange, color.white, 0.05)
    
    // Show new trend signal system status
    trendStatusMsg = 'TREND SIGNALS:'
    trendStatusMsg += ' T1=' + (trend1Enable ? (trend1Signal == 1 ? 'BULL' : trend1Signal == -1 ? 'BEAR' : 'NEUT') : 'OFF')
    trendStatusMsg += ' T2=' + (trend2Enable ? (trend2Signal == 1 ? 'BULL' : trend2Signal == -1 ? 'BEAR' : 'NEUT') : 'OFF')  
    trendStatusMsg += ' T3=' + (trend3Enable ? (trend3Signal == 1 ? 'BULL' : trend3Signal == -1 ? 'BEAR' : 'NEUT') : 'OFF')
    trendStatusMsg += ' RBW=' + (rbwEnable ? (rbwSignal == 2 ? 'BULL' : rbwSignal == 0 ? 'BEAR' : 'NEUT') : 'OFF')
    trendStatusMsg += ' BB=' + (bbEntryFilterEnable ? ('L:' + (bbLongFilterOK ? 'OK' : 'BLOCK') + ' S:' + (bbShortFilterOK ? 'OK' : 'BLOCK')) : 'OFF')
    debugMessage("INFO", trendStatusMsg, color.green, color.white, 0.05)
    
    // Show simplified bias status (RBW only now)
    consensusMsg = 'BIAS STATUS: RBW-Only Filter | RBW=' + (rbwEnable ? (rbwSignal == 2 ? 'BULL' : rbwSignal == 0 ? 'BEAR' : 'NEUT') : 'OFF')
    consensusMsg += ' | Final: Long=' + (longDirectionalBias ? 'ALLOW' : 'BLOCK') + ' Short=' + (shortDirectionalBias ? 'ALLOW' : 'BLOCK')
    debugMessage("INFO", consensusMsg, color.green, color.white, 0.05)
    
    // Show trend change exit system status
    if trendChangeExitEnable
        trendChangeMsg = 'TREND CHANGE EXIT: Status=' + (trendChangeExitEnable ? 'ENABLED' : 'DISABLED')
        trendChangeMsg += ' | Active=' + (trendChangeExitActive ? 'YES' : 'NO')  
        if trendChangeDetected
            trendChangeMsg += ' | CHANGE DETECTED: ' + trendChangeDetails
        debugMessage("INFO", trendChangeMsg, color.purple, color.white, 0.05)
    
    // Show hybrid exit system status
    // Fluid Hybrid Auto-Detection Status
    if autoHybridMode
        hybridMode = shouldUseTrendMode ? "TREND" : "SPL"
        debugMessage("HYBRID", "🔄 Auto-Hybrid Active: " + hybridMode + " mode (Pos: " + str.tostring(currentPositionSize) + "/" + str.tostring(hybridSwitchThreshold) + ")", color.purple, color.white, 0.1)
    else if smartProfitEnable and trendExitEnable and strategy.position_size == 0
        debugMessage("HYBRID", "💤 Auto-Hybrid Ready: Both SPL + Trend Exit enabled, waiting for position", color.gray, color.white, 0.1)
    else if smartProfitEnable or trendExitEnable
        singleMode = smartProfitEnable ? "SPL-ONLY" : "TREND-ONLY"
        debugMessage("HYBRID", "⚙️ Single-System Mode: " + singleMode, color.blue, color.white, 0.1)

// Debug logging for exit systems (trend-riding system removed)
if debugEnabled and strategy.position_size != 0
    systemMsg = 'EXIT SYSTEMS:'
    systemMsg += ' SPL=' + (shouldUseSPL ? 'ON' : 'OFF')
    systemMsg += ' TCE=' + (trendChangeExitActive ? 'ON' : 'OFF')
    // REMOVED: HYB debug - stand-alone hybrid system removed
    debugMessage("INFO", systemMsg, color.blue, color.white, 0.25)

// Enhanced visual indicators for exit systems  
plotchar(shouldUseSPL, title='Smart Profit Locker', char='🔒', location=location.top, color=color.blue, size=size.small)
plotchar(trendChangeExitEnable and strategy.position_size != 0, title='Trend Change Exit Active', char='📈', location=location.top, color=color.green, size=size.small)




// ──────── REMOVED: CUSTOM EXIT SYSTEM ────────────
// This old custom exit logic was interfering with the trend/hybrid exit system
// All custom exit functionality has been removed to prevent conflicts

// Visual aids for active levels
plot(strategy.position_size > 0 and fixedEnable ? strategyEntryPrice - tpCalc(fixedStop) : na, 'Fixed SL', color.red, style=plot.style_linebr)
plot(strategy.position_size > 0 and fixedEnable and tp1Enable ? strategyEntryPrice + tpCalc(tp1Size) : na, 'Fixed TP', color.green, style=plot.style_linebr)

// ─────────────────── 8 · ENHANCED CHART VISUALS WITH BACKTESTING INTEGRATION ─────────────────────────
// Entry signals - simple visualization
// Removed: Static BUY/SELL arrows - replaced with dynamic signal naming above

// Signal count indicators (for visual reference only - position size determines strategy)
// Removed confluence plots - using position size for trade management instead

// ──────── OPTIMIZED SIGNAL PLOTTING (Consolidated) ────────────
// Removed consolidated signal markers - redundant with main BUY/SELL triangles
// This reduces visual clutter and eliminates duplicate signal indicators

// ═══════════════════ COMPREHENSIVE INDICATOR VISUALIZATION ═══════════════════
// Beautiful, human-readable plotting of all strategy components
// ──────── CORE STRATEGY INDICATORS ────────────
// Moving Average Exit Line (Thick, Color-Coded)
maExitMA = ta.ema(close, 21)  // Using EMA-21 as the primary MA exit
plot(maExitMA, title="📈 MA Exit Line", color=color.new(color.blue, 0), linewidth=3, display=display.all)

// Stop Loss and Profit Lines (Dynamic based on position)
stopLossLine = strategy.position_size > 0 ? strategyEntryPrice - (atrVal * 3.1) : 
               strategy.position_size < 0 ? strategyEntryPrice + (atrVal * 3.1) : na
profitLockerLine = strategy.position_size > 0 ? high - (atrVal * smartProfitVal * smartProfitOffset) :
                   strategy.position_size < 0 ? low + (atrVal * smartProfitVal * smartProfitOffset) : na

plot(stopLossLine, title="🛑 Stop Loss", color=color.new(color.red, 20), linewidth=2, style=plot.style_linebr)
plot(profitLockerLine, title="💰 Profit Locker", color=color.new(color.green, 20), linewidth=2, style=plot.style_linebr)

// ═══════════════════ ENHANCED VIRTUAL SIGNAL ANALYTICS ═══════════════════
// Professional Individual Signal Backtesting with Virtual Account System
// Real-time performance tracking with commission/slippage integration

if showBacktestTable and barstate.islast
    // Simplified Virtual Account Table - Combined P&L (No Long/Short Separation)
    var table virtualSignalTable = table.new(position.bottom_left, columns=7, rows=12, bgcolor=color.new(color.black, 85), border_width=2, border_color=color.new(color.white, 70))
    
    // Simplified Headers - Combined Results for Comparative Analysis
    table.cell(virtualSignalTable, 0, 0, '📊 SIGNAL', text_color=color.white, text_size=size.normal, bgcolor=color.new(color.blue, 80))
    table.cell(virtualSignalTable, 1, 0, 'TRADES', text_color=color.white, text_size=size.small, bgcolor=color.new(color.blue, 80))
    table.cell(virtualSignalTable, 2, 0, 'WIN%', text_color=color.white, text_size=size.small, bgcolor=color.new(color.green, 80))
    table.cell(virtualSignalTable, 3, 0, 'TOTAL P&L($)', text_color=color.white, text_size=size.small, bgcolor=color.new(color.yellow, 80))
    table.cell(virtualSignalTable, 4, 0, 'MAX DD($)', text_color=color.white, text_size=size.small, bgcolor=color.new(color.orange, 80))
    table.cell(virtualSignalTable, 5, 0, 'PF', text_color=color.white, text_size=size.small, bgcolor=color.new(color.purple, 80))
    table.cell(virtualSignalTable, 6, 0, 'STATUS', text_color=color.white, text_size=size.small, bgcolor=color.new(color.blue, 80))
    
    // Process each virtual account for display
    signalEnables = array.from(signal1Enable, signal2Enable, signal3Enable, signal4Enable, signal5Enable, signal6Enable, signal7Enable, signal8Enable, signal9Enable, signal10Enable)
    signalNamesArray = array.from(signal1Name, signal2Name, signal3Name, signal4Name, signal5Name, signal6Name, signal7Name, signal8Name, signal9Name, signal10Name)
    
    currentRow = 1
    for i = 0 to 9
        if array.get(signalEnables, i)
            account = array.get(virtualAccounts, i)
            signalName = array.get(signalNamesArray, i)
            
            // Calculate metrics
            longWinRate = account.longTrades > 0 ? account.longWins / account.longTrades * 100 : 0
            shortWinRate = account.shortTrades > 0 ? account.shortWins / account.shortTrades * 100 : 0
            totalPnL = account.totalPnL
            profitFactor = account.grossLoss > 0 ? account.grossProfit / account.grossLoss : account.grossProfit > 0 ? 999 : 0
            
            // Performance Status Indicators
            overallWinRate = account.totalTrades > 0 ? account.winningTrades / account.totalTrades * 100 : 0
            statusEmoji = overallWinRate >= 70 and profitFactor >= 2.0 and totalPnL > 0 ? '🟢' : overallWinRate >= 50 and profitFactor >= 1.5 and totalPnL > 0 ? '🟡' : overallWinRate >= 40 and profitFactor >= 1.0 ? '🟠' : '🔴'
            
            statusColor = overallWinRate >= 70 and profitFactor >= 2.0 and totalPnL > 0 ? color.new(color.lime, 20) : overallWinRate >= 50 and profitFactor >= 1.5 and totalPnL > 0 ? color.new(color.yellow, 20) : overallWinRate >= 40 and profitFactor >= 1.0 ? color.new(color.orange, 20) : color.new(color.red, 20)
            
            // Action Recommendation
            actionText = totalPnL > 100 and overallWinRate > 60 and profitFactor > 1.5 ? 'KEEP ✅' : totalPnL < -100 or overallWinRate < 40 or profitFactor < 1.0 ? 'CUT ❌' : 'TEST ⚠️'
            
            actionColor = totalPnL > 100 and overallWinRate > 60 and profitFactor > 1.5 ? color.lime : totalPnL < -100 or overallWinRate < 40 or profitFactor < 1.0 ? color.red : color.orange
            
            // Truncate signal name for display
            displayName = str.length(signalName) > 8 ? str.substring(signalName, 0, 8) : signalName
            
            // Populate table row - SIMPLIFIED 7-COLUMN FORMAT (Combined P&L)
            table.cell(virtualSignalTable, 0, currentRow, displayName, text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 80))
            table.cell(virtualSignalTable, 1, currentRow, str.tostring(account.totalTrades), text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 2, currentRow, str.tostring(overallWinRate, '#.#') + '%', text_color=overallWinRate >= 60 ? color.lime : overallWinRate >= 40 ? color.yellow : color.red, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 3, currentRow, '$' + str.tostring(totalPnL, '#.##'), text_color=totalPnL > 0 ? color.lime : color.red, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 4, currentRow, '$' + str.tostring(account.maxDrawdown, '#.##'), text_color=color.white, text_size=size.small, bgcolor=color.new(color.red, 80))
            table.cell(virtualSignalTable, 5, currentRow, str.tostring(profitFactor, '#.##'), text_color=profitFactor >= 2.0 ? color.lime : profitFactor >= 1.5 ? color.yellow : profitFactor >= 1.0 ? color.orange : color.red, text_size=size.small, bgcolor=color.new(color.gray, 90))
            table.cell(virtualSignalTable, 6, currentRow, statusEmoji, text_color=color.white, text_size=size.small, bgcolor=statusColor)
            
            currentRow += 1
    
    // Summary Row with System Status - SIMPLIFIED 7-COLUMN FORMAT
    if currentRow <= 11
        table.cell(virtualSignalTable, 0, 11, '🚀 SYSTEM', text_color=color.white, text_size=size.small, bgcolor=color.new(color.blue, 25))
        table.cell(virtualSignalTable, 1, 11, 'Comm: $' + str.tostring(commissionPerTrade, '#.##'), text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 2, 11, 'Slip: $' + str.tostring(slippagePerTrade, '#.##'), text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 3, 11, 'Size: ' + str.tostring(virtualPositionSize), text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 4, 11, 'Point: $' + str.tostring(syminfo.pointvalue * futuresMultiplier, '#.##'), text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 5, 11, parametersChanged ? 'RESET ⚡' : 'STABLE ✓', text_color=parametersChanged ? color.orange : color.lime, text_size=size.tiny, bgcolor=color.new(color.blue, 35))
        table.cell(virtualSignalTable, 6, 11, 'COMBINED P&L ✅', text_color=color.lime, text_size=size.tiny, bgcolor=color.new(color.green, 35))

// ═══════════════════ INTRABAR EXIT DEBUG SYSTEM ═══════════════════
// Visual monitoring and validation system for robust exit logic

debugOn = input.bool(false, '🔍 Enable Exit Debug Labels', group = '🛠️ Debug System', tooltip = 'Show visual labels when exits trigger to validate anti-spam logic')

if debugOn and barstate.isconfirmed
    // Determine which exit method was triggered (if any)
    exitType = 
      maExitSent ? 'MA' :
      fixedExitSent ? 'Fixed' :
      trailExitSent ? 'Trail' :
      // Removed: customExitSent ? 'Custom' : - old custom exit system
      'None'
    
    // Color coding for different exit types
    labelColor = 
      maExitSent ? color.red : 
      fixedExitSent ? color.orange : 
      trailExitSent ? color.blue : 
      // Removed: customExitSent ? color.teal : - old custom exit system
      color.gray
    
    // Show debug label when an exit is triggered
    if exitType != 'None'
        label.new(bar_index, high * 1.02, 'EXIT: ' + exitType + '\nBar: ' + str.tostring(bar_index) + '\nPrice: ' + str.tostring(close, '#.####') + '\nPos: ' + (strategy.position_size > 0 ? 'Long' : strategy.position_size < 0 ? 'Short' : 'Flat'), color=labelColor, textcolor=color.white, style=label.style_label_down, yloc=yloc.abovebar, size=size.small)
    
    // Show position state changes
    if currentPosition != currentPosition[1]
        stateColor = currentPosition ? color.green : color.red
        stateText = currentPosition ? 'ENTRY' : 'EXIT'
        label.new(bar_index, low * 0.98, stateText + '\nFlags Reset: ' + (currentPosition ? 'YES' : 'NO'), color=stateColor, textcolor=color.white, style=label.style_label_up, yloc=yloc.belowbar, size=size.tiny)

// ──────── STATUS/SETTINGS PANEL (Optional) ────────────
showStatusPanel = input.bool(false, '⚙️ Status/Settings Panel', group = '🛠️ Debug System', tooltip = 'Show comprehensive status and settings for all enabled features')

if showStatusPanel and barstate.isconfirmed
    // Create fixed-size table (3 columns, 8 rows max)  
    var table statusTable = table.new(position.bottom_right, 3, 8, bgcolor = color.new(color.black, 20), border_width = 1)
    
    // Headers
    table.cell(statusTable, 0, 0, '⚙️ FEATURE', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 40))
    table.cell(statusTable, 1, 0, 'STATUS', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 40))
    table.cell(statusTable, 2, 0, 'SETTINGS', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 40))
    
    // Dynamic row counter
    var int currentRow = 1
    currentRow := 1
    
    // MA Exit
    if maExitOn
        maStatus = inPosition and (strategy.position_size > 0 and close < priceMA) or (strategy.position_size < 0 and close > priceMA) ? '🔴 TRIGGERED' : inPosition ? '🟡 MONITORING' : '⚪ STANDBY'
        maStatusColor = inPosition and ((strategy.position_size > 0 and close < priceMA) or (strategy.position_size < 0 and close > priceMA)) ? color.red : inPosition ? color.yellow : color.gray
        maSettings = maType + '-' + str.tostring(maLen)
        
        table.cell(statusTable, 0, currentRow, '📈 MA Exit', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(statusTable, 1, currentRow, maStatus, text_color = maStatusColor, text_size = size.small, bgcolor = color.new(color.gray, 90))
        table.cell(statusTable, 2, currentRow, maSettings, text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 90))
        currentRow += 1
    
    // Fixed SL/TP
    if fixedEnable
        fixedStatus = inPosition ? '🟡 ACTIVE' : '⚪ STANDBY'
        fixedStatusColor = inPosition ? color.yellow : color.gray
        fixedSettings = 'SL:' + str.tostring(fixedStop, '#.1') + ' ' + fixedUnit + ' TP:' + (tp1Enable ? str.tostring(tp1Size, '#.1') : 'OFF')
        
        table.cell(statusTable, 0, currentRow, '🎯 Fixed SL/TP', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(statusTable, 1, currentRow, fixedStatus, text_color = fixedStatusColor, text_size = size.small, bgcolor = color.new(color.gray, 90))
        table.cell(statusTable, 2, currentRow, fixedSettings, text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 90))
        currentRow += 1
    
    // Smart Profit Locker
    if smartProfitEnable
        smartStatus = inPosition ? '🟢 ACTIVE' : '⚪ STANDBY'
        smartStatusColor = inPosition ? color.lime : color.gray
        smartSettings = str.tostring(smartProfitVal, '#.1') + ' ' + smartProfitType + ', ' + str.tostring(smartProfitOffset * 100, '#.1') + '% PB'
        
        table.cell(statusTable, 0, currentRow, '🔒 Smart Locker', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(statusTable, 1, currentRow, smartStatus, text_color = smartStatusColor, text_size = size.small, bgcolor = color.new(color.gray, 90))
        table.cell(statusTable, 2, currentRow, smartSettings, text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 90))
        currentRow += 1
    
    // Trend Change Exit
    if trendChangeExitEnable
        trendChangeStatus = trendChangeExitActive ? '🟢 ACTIVE' : inPosition ? '🟡 MONITORING' : '⚪ STANDBY'
        trendChangeColor = trendChangeExitActive ? color.lime : inPosition ? color.yellow : color.gray
        trendChangeSettings = 'Any trend signal direction change'
        
        table.cell(statusTable, 0, currentRow, '📈 Trend Exit', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(statusTable, 1, currentRow, trendChangeStatus, text_color = trendChangeColor, text_size = size.small, bgcolor = color.new(color.gray, 90))
        table.cell(statusTable, 2, currentRow, trendChangeSettings, text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 90))
        currentRow += 1
    
    // Hybrid Exit System
    // Fluid Hybrid Auto-Detection Status
    fluidHybridStatus = ''
    fluidHybridColor = color.gray
    
    if autoHybridMode
        fluidHybridStatus := shouldUseTrendMode ? '🎯 TREND MODE' : '💰 SPL MODE'
        fluidHybridColor := shouldUseTrendMode ? color.orange : color.blue
    else if smartProfitEnable and trendExitEnable
        fluidHybridStatus := '💤 READY (No Position)'
        fluidHybridColor := color.gray
    else if smartProfitEnable or trendExitEnable
        fluidHybridStatus := smartProfitEnable ? '⚙️ SPL-ONLY' : '⚙️ TREND-ONLY'
        fluidHybridColor := color.white
    else
        fluidHybridStatus := '❌ NO EXIT SYSTEMS'
        fluidHybridColor := color.red
    
    fluidHybridSettings = 'Auto-Switch at ' + str.tostring(hybridSwitchThreshold) + ' contracts'
    
    table.cell(statusTable, 0, currentRow, '🔄 Fluid Hybrid', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
    table.cell(statusTable, 1, currentRow, fluidHybridStatus, text_color = fluidHybridColor, text_size = size.small, bgcolor = color.new(color.gray, 90))
    table.cell(statusTable, 2, currentRow, fluidHybridSettings, text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 90))
    currentRow += 1
    
    // System Status Row  
    table.cell(statusTable, 0, currentRow, '📊 Position', text_color = color.white, text_size = size.small, bgcolor = color.new(color.purple, 60))
    table.cell(statusTable, 1, currentRow, inPosition ? '🟢 IN TRADE' : '⚪ NO POSITION', text_color = inPosition ? color.lime : color.gray, text_size = size.small, bgcolor = color.new(color.purple, 70))
    table.cell(statusTable, 2, currentRow, 'Size: ' + str.tostring(strategy.position_size), text_color = color.white, text_size = size.small, bgcolor = color.new(color.purple, 70))

// ═══════════════════ MASTER PANEL SYSTEM ═══════════════════
// Real-time strategy status panel for enhanced transparency

// Master Panel Enable Toggle
masterPanelEnable = input.bool(true, '📊 Master Panel', group='🎛️ Master Panel', tooltip='Show real-time strategy status panel with key metrics')
bigPositionDisplay = input.bool(true, '💯 Big Position Display', group='🎛️ Master Panel', tooltip='Show large, bold position indicator for instant recognition')

// Big Bold Position Display (Optimized for immediate loading)
if bigPositionDisplay and barstate.isconfirmed
    var label bigPositionLabel = na
    
    // Delete previous label
    if not na(bigPositionLabel)
        label.delete(bigPositionLabel)
    
    // Create new position label
    if strategy.position_size != 0
        positionText = strategy.position_size > 0 ? 'LONG' : 'SHORT'
        positionColor = strategy.position_size > 0 ? color.new(color.lime, 20) : color.new(color.red, 20)
        textColor = strategy.position_size > 0 ? color.lime : color.red
        
        bigPositionLabel := label.new(x = bar_index + 5, y = high + (high - low) * 0.3, text = positionText, style = label.style_label_left, color = positionColor, textcolor = textColor, size = size.huge)

// Session Stats Tracking
var float sessionStartEquity = na
var int sessionTrades = 0
var int sessionWins = 0

// Initialize session stats at start of day
if na(sessionStartEquity) or dayofweek != dayofweek[1]
    sessionStartEquity := strategy.equity
    sessionTrades := 0
    sessionWins := 0

// Track session trades
if strategy.closedtrades > strategy.closedtrades[1]
    sessionTrades := sessionTrades + 1
    if strategy.wintrades > strategy.wintrades[1]
        sessionWins := sessionWins + 1

// Simplified bias calculation (RBW only)
// Removed complex trend consensus logic - using position size for strategy control

// Master Panel Display (Optimized for immediate loading)
if masterPanelEnable and barstate.isconfirmed
    var table masterPanel = table.new(position.top_right, 2, 15, bgcolor = color.new(color.black, 15), border_width = 1)
    
    // Header
    table.cell(masterPanel, 0, 0, '🎛️ MASTER PANEL', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 30))
    table.cell(masterPanel, 1, 0, 'STATUS', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 30))
    

    
    // Bias Filter Status (Simplified - RBW Only)
    biasText = rbwEnable ? 
      (longDirectionalBias ? 'BULLISH' : shortDirectionalBias ? 'BEARISH' : 'NEUTRAL') : 'DISABLED'
    biasColor = longDirectionalBias ? color.lime : shortDirectionalBias ? color.red : color.gray
    table.cell(masterPanel, 0, 2, '📈 RBW Bias', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
    table.cell(masterPanel, 1, 2, biasText, text_color = biasColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Signal Strength Meter Row (expanded to 10 signals)
    activeSignals = (signal1Enable ? 1 : 0) + (signal2Enable ? 1 : 0) + (signal3Enable ? 1 : 0) + (signal4Enable ? 1 : 0) + (signal5Enable ? 1 : 0) + (signal6Enable ? 1 : 0) + (signal7Enable ? 1 : 0) + (signal8Enable ? 1 : 0) + (signal9Enable ? 1 : 0) + (signal10Enable ? 1 : 0)
    longSignalCount := (signal1Enable and sig1Long ? 1 : 0) + (signal2Enable and sig2Long ? 1 : 0) + (signal3Enable and sig3Long ? 1 : 0) + (signal4Enable and sig4Long ? 1 : 0) + (signal5Enable and sig5Long ? 1 : 0) + (signal6Enable and sig6Long ? 1 : 0) + (signal7Enable and sig7Long ? 1 : 0) + (signal8Enable and sig8Long ? 1 : 0) + (signal9Enable and sig9Long ? 1 : 0) + (signal10Enable and sig10Long ? 1 : 0)
    shortSignalCount := (signal1Enable and sig1Short ? 1 : 0) + (signal2Enable and sig2Short ? 1 : 0) + (signal3Enable and sig3Short ? 1 : 0) + (signal4Enable and sig4Short ? 1 : 0) + (signal5Enable and sig5Short ? 1 : 0) + (signal6Enable and sig6Short ? 1 : 0) + (signal7Enable and sig7Short ? 1 : 0) + (signal8Enable and sig8Short ? 1 : 0) + (signal9Enable and sig9Short ? 1 : 0) + (signal10Enable and sig10Short ? 1 : 0)
    
    if activeSignals > 0
        maxSignals = math.max(longSignalCount, shortSignalCount)
        signalStrength = maxSignals / activeSignals * 100
        strengthText = str.tostring(signalStrength, '#') + '% (' + str.tostring(maxSignals) + '/' + str.tostring(activeSignals) + ')'
        strengthColor = signalStrength >= 80 ? color.lime : signalStrength >= 60 ? color.yellow : signalStrength >= 40 ? color.orange : color.red
        table.cell(masterPanel, 0, 3, '📊 Signal Power', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 3, strengthText, text_color = strengthColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Volatility Alert Row (DEFENSIVE PROGRAMMING FIX)
    atrCurrent = atrVal
    // Use pre-calculated atrAvg with defensive check to prevent division by zero
    volatilityRatio := not na(atrAvg) and atrAvg > 0 ? atrCurrent / atrAvg : 1.0
    
    if volatilityRatio > 1.5  // Show alert when ATR is 50% above average
        volText = 'HIGH (' + str.tostring(volatilityRatio, '#.##') + 'x)'
        volColor = volatilityRatio > 2.0 ? color.red : color.orange
        table.cell(masterPanel, 0, 4, '⚡ Volatility', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 4, volText, text_color = volColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Mode Status Row
    // Fluid Hybrid Mode Display
    if smartProfitEnable or trendExitEnable
        modeText = ''
        modeColor = color.gray
        
        if autoHybridMode
            modeText := shouldUseTrendMode ? 'AUTO-TREND' : 'AUTO-SPL'
            modeColor := shouldUseTrendMode ? color.orange : color.blue
        else if smartProfitEnable and trendExitEnable
            modeText := 'AUTO-READY'
            modeColor := color.yellow
        else
            modeText := smartProfitEnable ? 'SPL-ONLY' : 'TREND-ONLY'
            modeColor := color.white
            
        table.cell(masterPanel, 0, 5, '🚀 Mode', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 5, modeText, text_color = modeColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    

    
    // Exit System Status Row - NEW COMPREHENSIVE TRACKING
    if strategy.position_size != 0
        exitSystemText = ''
        exitSystemColor = color.gray
        
        // Determine which exit system is currently active
        if bbExitTriggered
            // BB EXIT MODE: Tight profit locker from BB extreme
            exitSystemText := 'BB TIGHT'
            exitSystemColor := color.yellow
        else if smartProfitEnable and shouldUseSPL
            // NORMAL MODE: Smart profit locker active
            exitSystemText := 'SMART LOCKER'
            exitSystemColor := color.lime
        else if maExitOn
            // MA EXIT MODE: Moving average exit active
            exitSystemText := 'MA EXIT'
            exitSystemColor := color.purple
        else if fixedEnable
            // FIXED MODE: Fixed SL/TP active
            exitSystemText := 'FIXED SL/TP'
            exitSystemColor := color.blue
        else
            // NO EXIT SYSTEM: This shouldn't happen but safety check
            exitSystemText := 'NO EXIT!'
            exitSystemColor := color.red
        
        table.cell(masterPanel, 0, 7, '🎯 Exit System', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 7, exitSystemText, text_color = exitSystemColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Position Status Row
    positionText = strategy.position_size == 0 ? 'FLAT' : strategy.position_size > 0 ? 'LONG' : 'SHORT'
    positionColor = strategy.position_size == 0 ? color.gray : strategy.position_size > 0 ? color.lime : color.red
    table.cell(masterPanel, 0, 8, '📈 Position', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
    table.cell(masterPanel, 1, 8, positionText, text_color = positionColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // P&L Row (only when in position)
    if strategy.position_size != 0
        unrealizedPnL = strategy.openprofit
        pnlText = (unrealizedPnL >= 0 ? '+$' : '-$') + str.tostring(math.abs(unrealizedPnL), '#.##')
        pnlColor = unrealizedPnL > 0 ? color.lime : unrealizedPnL < 0 ? color.red : color.gray
        table.cell(masterPanel, 0, 9, '💰 P&L', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 9, pnlText, text_color = pnlColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Trade Duration Row (only when in position)
    if strategy.position_size != 0
        barsInTrade = bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1)
        durationText = str.tostring(barsInTrade) + ' bars'
        durationColor = barsInTrade > 50 ? color.orange : color.white
        table.cell(masterPanel, 0, 10, '⏱️ Duration', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 10, durationText, text_color = durationColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Entry Price Row (only when in position)
    if strategy.position_size != 0
        float entryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)
        priceText = '$' + str.tostring(entryPrice, '#.##')
        priceDiff = close - entryPrice
        diffText = (priceDiff >= 0 ? '+' : '') + str.tostring(priceDiff, '#.##')
        table.cell(masterPanel, 0, 11, '🎯 Entry Price', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 11, priceText + ' (' + diffText + ')', text_color = color.white, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Risk/Reward Calculator Row (only when in position)
    if strategy.position_size != 0 and smartProfitEnable
        float entryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)
        stopDistance = smartProfitVal * atrVal  // Assuming ATR-based stop
        currentDistance = math.abs(close - entryPrice)
        riskRewardRatio = currentDistance / stopDistance
        rrText = str.tostring(riskRewardRatio, '#.##') + ':1'
        rrColor = riskRewardRatio >= 2.0 ? color.lime : riskRewardRatio >= 1.0 ? color.yellow : color.red
        table.cell(masterPanel, 0, 12, '🎲 R:R Ratio', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 12, rrText, text_color = rrColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Session Stats Row
    if sessionTrades > 0
        sessionPnL = strategy.equity - sessionStartEquity
        sessionWinRate = sessionWins / sessionTrades * 100
        sessionText = str.tostring(sessionWinRate, '#') + '% (' + str.tostring(sessionWins) + '/' + str.tostring(sessionTrades) + ')'
        sessionColor = sessionWinRate >= 70 ? color.lime : sessionWinRate >= 50 ? color.yellow : color.red
        table.cell(masterPanel, 0, 12, '🌅 Today', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 12, sessionText, text_color = sessionColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Next Signal Countdown Row (only when flat)
    if strategy.position_size == 0
        // Simple countdown based on bars since last signal
        barsWithoutSignal = 0
        if not (sig1Long or sig1Short or sig2Long or sig2Short or sig3Long or sig3Short or sig4Long or sig4Short or sig5Long or sig5Short)
            barsWithoutSignal := 1
        
        countdownText = ''
        countdownColor = color.gray
        
        if barsWithoutSignal > 0
            countdownText := 'Waiting...'
            countdownColor := color.gray
        else
            countdownText := 'Signal Active!'
            countdownColor := color.yellow
        
        table.cell(masterPanel, 0, 13, '⏳ Next Signal', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 13, countdownText, text_color = countdownColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))
    
    // Win Rate Row
    if strategy.closedtrades > 0
        winRate = strategy.wintrades / strategy.closedtrades * 100
        winText = str.tostring(winRate, '#.1') + '% (' + str.tostring(strategy.wintrades) + '/' + str.tostring(strategy.closedtrades) + ')'
        winColor = winRate >= 70 ? color.lime : winRate >= 50 ? color.yellow : color.red
        table.cell(masterPanel, 0, 14, '🏆 Win Rate', text_color = color.white, text_size = size.small, bgcolor = color.new(color.gray, 80))
        table.cell(masterPanel, 1, 14, winText, text_color = winColor, text_size = size.normal, bgcolor = color.new(color.gray, 90))

// ═══════════════════ STRATEGY PERFORMANCE TRACKING UPDATES ═══════════════════
// Update signal performance arrays when trades close

// Track peak/trough during open trades for drawdown calculation
if strategy.position_size != 0 and not na(current_trade_entry)
    if strategy.position_size > 0  // Long position
        current_trade_peak := math.max(current_trade_peak, close)
        current_trade_trough := math.min(current_trade_trough, close)
    else  // Short position
        current_trade_peak := math.max(current_trade_peak, current_trade_entry - close)
        current_trade_trough := math.min(current_trade_trough, current_trade_entry - close)

// Update performance arrays when trades close
if strategy.closedtrades > strategy.closedtrades[1]
    // Calculate trade P&L
    trade_pnl = strategy.position_size[1] > 0 ? (close - current_trade_entry) / current_trade_entry * 100 : (current_trade_entry - close) / current_trade_entry * 100
    trade_won = trade_pnl > 0
    
    // Calculate drawdown during this trade
    trade_drawdown = strategy.position_size[1] > 0 ? (current_trade_peak - current_trade_trough) / current_trade_entry * 100 : current_trade_peak
    
    // Update performance for each signal that contributed to this trade (expanded to 10 signals)
    for i = 0 to 9
        if array.get(current_trade_signals, i)
            // Update trade count
            current_trades = array.get(signal_strategy_trades, i)
            array.set(signal_strategy_trades, i, current_trades + 1)
            
            // Update win count
            if trade_won
                current_wins = array.get(signal_strategy_wins, i)
                array.set(signal_strategy_wins, i, current_wins + 1)
            
            // Update cumulative P&L
            current_profit = array.get(signal_strategy_profits, i)
            array.set(signal_strategy_profits, i, current_profit + trade_pnl)
            
            // Update max drawdown (track worst drawdown per signal)
            current_dd = array.get(signal_strategy_drawdowns, i)
            array.set(signal_strategy_drawdowns, i, math.max(current_dd, trade_drawdown))
            
            // Update contribution score (weighted by trade P&L)
            current_contrib = array.get(signal_contributions, i)
            array.set(signal_contributions, i, current_contrib + (trade_pnl * 0.1))  // Weighted contribution
    
    // Reset tracking variables (expanded to 10 signals)
    current_trade_entry := na
    current_trade_peak := na
    current_trade_trough := na
    for i = 0 to 9
        array.set(current_trade_signals, i, false)

// TREND SIGNAL-BASED EXIT DETECTION
// Check for opposite signals from the 5 Trend Signals (correct approach)

// Reset trend change detection each bar
trendChangeDetected := false
trendChangeDetails := ""

// OLD TREND CHANGE EXIT LOGIC - KEPT FOR BASIC COMPATIBILITY
// This is overridden by the Advanced Trend Exit System when enabled
if trendChangeExitEnable and strategy.position_size != 0 and not useAdvancedTrendExit
    // Basic fallback logic (now uses new trend majority system)
    if strategy.position_size > 0 and trendConfirmsShort
        trendChangeDetected := true
        trendChangeDetails := "Basic Trend Exit: Majority trend turned bearish"
    else if strategy.position_size < 0 and trendConfirmsLong
        trendChangeDetected := true
        trendChangeDetails := "Basic Trend Exit: Majority trend turned bullish"

// ═══════════════════ ADVANCED TREND EXIT LOGIC ═══════════════════
// 3-Phase Exit System: Trailing Stop → Color Change Exit → Re-Entry

// State variables for advanced trend exit (declared in global section)

// Determine if we should use advanced trend exit - FLUID HYBRID LOGIC
useAdvancedTrendExit := shouldUseTrendMode  // Set by fluid hybrid auto-detection above

// Reset state when no position
if strategy.position_size == 0
    inTrendExitMode := false
    inProfitMode := false
    trendExitPrice := na
    if not reEntryEnable
        waitingForReEntry := false
        exitDirection := 0

// Initialize trend exit mode on new position
if strategy.position_size != 0 and not inTrendExitMode and useAdvancedTrendExit
    inTrendExitMode := true
    inProfitMode := false
    trendExitPrice := strategy.position_avg_price
    waitingForReEntry := false
    exitDirection := 0

// Phase 1: REMOVED - Advanced Trend Exit is now pure trend-following (no competing trailing stops)
// SPL (Smart Profit Locker) handles ALL trailing stop protection
// Advanced Trend Exit focuses solely on trend change detection and re-entry

// Phase 2: Color Change Exit (SIMPLIFIED - immediate trend change detection)
colorChangeExit := false

if inTrendExitMode and strategy.position_size != 0
    if exitMode == 'Color Change'
        if strategy.position_size > 0 and lrcBearColor  // Long position exits on bear color
            colorChangeExit := true
            exitDirection := 1
        else if strategy.position_size < 0 and lrcBullColor  // Short position exits on bull color
            colorChangeExit := true
            exitDirection := -1
    else if exitMode == 'MA Cross'
        if strategy.position_size > 0 and lrcBearMA  // Long position exits on bear MA cross
            colorChangeExit := true
            exitDirection := 1
        else if strategy.position_size < 0 and lrcBullMA  // Short position exits on bull MA cross
            colorChangeExit := true
            exitDirection := -1

// Phase 3: Re-Entry Logic
reEntrySignal := false

if reEntryEnable and waitingForReEntry and strategy.position_size == 0
    if exitDirection == 1  // Was long, look for bull signal to re-enter long
        if exitMode == 'Color Change' and lrcBullColor and trendConfirmsLong
            reEntrySignal := true
            waitingForReEntry := false
            exitDirection := 0
        else if exitMode == 'MA Cross' and lrcBullMA and trendConfirmsLong
            reEntrySignal := true
            waitingForReEntry := false
            exitDirection := 0
    else if exitDirection == -1  // Was short, look for bear signal to re-enter short
        if exitMode == 'Color Change' and lrcBearColor and trendConfirmsShort
            reEntrySignal := true
            waitingForReEntry := false
            exitDirection := 0
        else if exitMode == 'MA Cross' and lrcBearMA and trendConfirmsShort
            reEntrySignal := true
            waitingForReEntry := false
            exitDirection := 0

// Set waiting for re-entry when color change exit occurs
if colorChangeExit and reEntryEnable
    waitingForReEntry := true

// Set final trend change detection for compatibility with existing exit logic
if colorChangeExit
    trendChangeDetected := true
    trendChangeDetails := "LRC " + exitMode + " Exit"

// ═══════════════════ DYNAMIC SIGNAL NAMING FOR ARROWS ═══════════════════
// Create meaningful arrow labels showing which signal(s) triggered the entry

// Build dynamic signal names for long entries
longSignalName = ""
var int dynamicLongCount = 0
dynamicLongCount := 0
if longEntrySignal
    if sig1Long and signal1Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal1Name
        dynamicLongCount := dynamicLongCount + 1
    if sig2Long and signal2Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal2Name
        dynamicLongCount := dynamicLongCount + 1
    if sig3Long and signal3Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal3Name
        dynamicLongCount := dynamicLongCount + 1
    if sig4Long and signal4Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal4Name
        dynamicLongCount := dynamicLongCount + 1
    if sig5Long and signal5Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal5Name
        dynamicLongCount := dynamicLongCount + 1
    if sig6Long and signal6Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal6Name
        dynamicLongCount := dynamicLongCount + 1
    if sig7Long and signal7Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal7Name
        dynamicLongCount := dynamicLongCount + 1
    if sig8Long and signal8Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal8Name
        dynamicLongCount := dynamicLongCount + 1
    if sig9Long and signal9Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal9Name
        dynamicLongCount := dynamicLongCount + 1
    if sig10Long and signal10Enable
        longSignalName += (dynamicLongCount > 0 ? "+" : "") + signal10Name
        dynamicLongCount := dynamicLongCount + 1

// Build dynamic signal names for short entries
shortSignalName = ""
var int dynamicShortCount = 0
dynamicShortCount := 0
if shortEntrySignal
    if sig1Short and signal1Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal1Name
        dynamicShortCount := dynamicShortCount + 1
    if sig2Short and signal2Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal2Name
        dynamicShortCount := dynamicShortCount + 1
    if sig3Short and signal3Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal3Name
        dynamicShortCount := dynamicShortCount + 1
    if sig4Short and signal4Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal4Name
        dynamicShortCount := dynamicShortCount + 1
    if sig5Short and signal5Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal5Name
        dynamicShortCount := dynamicShortCount + 1
    if sig6Short and signal6Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal6Name
        dynamicShortCount := dynamicShortCount + 1
    if sig7Short and signal7Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal7Name
        dynamicShortCount := dynamicShortCount + 1
    if sig8Short and signal8Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal8Name
        dynamicShortCount := dynamicShortCount + 1
    if sig9Short and signal9Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal9Name
        dynamicShortCount := dynamicShortCount + 1
    if sig10Short and signal10Enable
        shortSignalName += (dynamicShortCount > 0 ? "+" : "") + signal10Name
        dynamicShortCount := dynamicShortCount + 1

// Create final arrow titles with signal names
dynamicLongText = longSignalName != "" ? longSignalName : "MULTI"
dynamicShortText = shortSignalName != "" ? shortSignalName : "MULTI"

// Plot arrows with static titles and use labels for dynamic signal names
plotshape(longEntrySignal, title = "BUY Signal", style = shape.triangleup, location = location.belowbar, color = color.lime, size = size.small)
plotshape(shortEntrySignal, title = "SELL Signal", style = shape.triangledown, location = location.abovebar, color = color.red, size = size.small)

// Add dynamic labels showing which signal(s) triggered the entry
if longEntrySignal
    label.new(bar_index, low - (atrVal * 0.5), dynamicLongText, color = color.new(color.lime, 20), style = label.style_label_up, textcolor = color.white, size = size.small)

if shortEntrySignal
    label.new(bar_index, high + (atrVal * 0.5), dynamicShortText, color = color.new(color.red, 20), style = label.style_label_down, textcolor = color.white, size = size.small)

// ═══════════════════ VIRTUAL ACCOUNT PROCESSING (PROPERLY POSITIONED) ═══════════════════
// Process each signal through its corresponding virtual account
// This creates perfect signal attribution without interference
// NOW POSITIONED AFTER ALL BIAS CALCULATIONS AND ENTRY SIGNAL DEFINITIONS

// Signal names array for debugging
signalNames = array.from(signal1Name, signal2Name, signal3Name, signal4Name, signal5Name, signal6Name, signal7Name, signal8Name, signal9Name, signal10Name)

// Process virtual trades for each signal (SYNCED WITH STRATEGY CONDITIONS)
// Apply the same filters used by the main strategy: longDirectionalBias and bbLongFilterOK
processVirtualTrade(virtualAccount1, sig1Long and longDirectionalBias and bbLongFilterOK, sig1Short and shortDirectionalBias and bbShortFilterOK, signal1Name, 0)
processVirtualTrade(virtualAccount2, sig2Long and longDirectionalBias and bbLongFilterOK, sig2Short and shortDirectionalBias and bbShortFilterOK, signal2Name, 1)
processVirtualTrade(virtualAccount3, sig3Long and longDirectionalBias and bbLongFilterOK, sig3Short and shortDirectionalBias and bbShortFilterOK, signal3Name, 2)
processVirtualTrade(virtualAccount4, sig4Long and longDirectionalBias and bbLongFilterOK, sig4Short and shortDirectionalBias and bbShortFilterOK, signal4Name, 3)
processVirtualTrade(virtualAccount5, sig5Long and longDirectionalBias and bbLongFilterOK, sig5Short and shortDirectionalBias and bbShortFilterOK, signal5Name, 4)
processVirtualTrade(virtualAccount6, sig6Long and longDirectionalBias and bbLongFilterOK, sig6Short and shortDirectionalBias and bbShortFilterOK, signal6Name, 5)
processVirtualTrade(virtualAccount7, sig7Long and longDirectionalBias and bbLongFilterOK, sig7Short and shortDirectionalBias and bbShortFilterOK, signal7Name, 6)
processVirtualTrade(virtualAccount8, sig8Long and longDirectionalBias and bbLongFilterOK, sig8Short and shortDirectionalBias and bbShortFilterOK, signal8Name, 7)
processVirtualTrade(virtualAccount9, sig9Long and longDirectionalBias and bbLongFilterOK, sig9Short and shortDirectionalBias and bbShortFilterOK, signal9Name, 8)
processVirtualTrade(virtualAccount10, sig10Long and longDirectionalBias and bbLongFilterOK, sig10Short and shortDirectionalBias and bbShortFilterOK, signal10Name, 9)

// Process virtual exits (SYNCED WITH STRATEGY CONDITIONS)
// Apply the same filters to exit signals as used for entries
processVirtualExit(virtualAccount1, sig1Short and shortDirectionalBias and bbShortFilterOK, signal1Name, 0)  // Long exit on filtered short signal
processVirtualExit(virtualAccount2, sig2Short and shortDirectionalBias and bbShortFilterOK, signal2Name, 1)
processVirtualExit(virtualAccount3, sig3Short and shortDirectionalBias and bbShortFilterOK, signal3Name, 2)
processVirtualExit(virtualAccount4, sig4Short and shortDirectionalBias and bbShortFilterOK, signal4Name, 3)
processVirtualExit(virtualAccount5, sig5Short and shortDirectionalBias and bbShortFilterOK, signal5Name, 4)
processVirtualExit(virtualAccount6, sig6Short and shortDirectionalBias and bbShortFilterOK, signal6Name, 5)
processVirtualExit(virtualAccount7, sig7Short and shortDirectionalBias and bbShortFilterOK, signal7Name, 6)
processVirtualExit(virtualAccount8, sig8Short and shortDirectionalBias and bbShortFilterOK, signal8Name, 7)
processVirtualExit(virtualAccount9, sig9Short and shortDirectionalBias and bbShortFilterOK, signal9Name, 8)
processVirtualExit(virtualAccount10, sig10Short and shortDirectionalBias and bbShortFilterOK, signal10Name, 9)

// Also process short exits on filtered long signals
if virtualAccount1.direction == "short" and sig1Long and longDirectionalBias and bbLongFilterOK
    processVirtualExit(virtualAccount1, sig1Long and longDirectionalBias and bbLongFilterOK, signal1Name, 0)
if virtualAccount2.direction == "short" and sig2Long and longDirectionalBias and bbLongFilterOK
    processVirtualExit(virtualAccount2, sig2Long and longDirectionalBias and bbLongFilterOK, signal2Name, 1)
if virtualAccount3.direction == "short" and sig3Long and longDirectionalBias and bbLongFilterOK
    processVirtualExit(virtualAccount3, sig3Long and longDirectionalBias and bbLongFilterOK, signal3Name, 2)
if virtualAccount4.direction == "short" and sig4Long and longDirectionalBias and bbLongFilterOK
    processVirtualExit(virtualAccount4, sig4Long and longDirectionalBias and bbLongFilterOK, signal4Name, 3)
if virtualAccount5.direction == "short" and sig5Long and longDirectionalBias and bbLongFilterOK
    processVirtualExit(virtualAccount5, sig5Long and longDirectionalBias and bbLongFilterOK, signal5Name, 4)
if virtualAccount6.direction == "short" and sig6Long and longDirectionalBias and bbLongFilterOK
    processVirtualExit(virtualAccount6, sig6Long and longDirectionalBias and bbLongFilterOK, signal6Name, 5)
if virtualAccount7.direction == "short" and sig7Long and longDirectionalBias and bbLongFilterOK
    processVirtualExit(virtualAccount7, sig7Long and longDirectionalBias and bbLongFilterOK, signal7Name, 6)
if virtualAccount8.direction == "short" and sig8Long and longDirectionalBias and bbLongFilterOK
    processVirtualExit(virtualAccount8, sig8Long and longDirectionalBias and bbLongFilterOK, signal8Name, 7)
if virtualAccount9.direction == "short" and sig9Long and longDirectionalBias and bbLongFilterOK
    processVirtualExit(virtualAccount9, sig9Long and longDirectionalBias and bbLongFilterOK, signal9Name, 8)
if virtualAccount10.direction == "short" and sig10Long and longDirectionalBias and bbLongFilterOK
    processVirtualExit(virtualAccount10, sig10Long and longDirectionalBias and bbLongFilterOK, signal10Name, 9)

// ═══════════════════ STRATEGY EXECUTION ═══════════════════

// ─────────────────── POSITION SIZE CONTROL ───────────────────
pyramidLimit = input.int(5, 'Max Total Contracts', minval = 1, maxval = 100, group = '💼 Position Size', inline='pos2', tooltip = 'Maximum total contracts allowed. Strategy will reject new entries when this limit is reached.')

// ─────────────────── DEBUG CONTROLS ───────────────────
debugEnable = input.bool(true, "🔍 Enable Debug Labels", group="🔧 Debug", tooltip="Show debug labels for entry blocking analysis")
showEntryBlocks = input.bool(true, "Show Entry Blocks", group="🔧 Debug", tooltip="Display labels when entries are blocked")

// ─────────────────── ENTRY LOGIC (EMERGENCY FIX) ───────────────────
// CRITICAL FIX: Replace strategy.position_size checks with entryAllowed flag
// This prevents exit system interference with entry conditions
var bool entryAllowed = true

// Update entry permission each bar – production: allow adds / reversals while in position
// Check pyramid limit - prevent entries if we've reached max contracts (uses currentPositionSize from hybrid exit section)
entryAllowed := currentPositionSize < pyramidLimit  // Respect user's pyramid limit

// EMERGENCY RESET: If strategy thinks it's in position but no open trades exist, force reset
if strategy.position_size != 0 and strategy.opentrades == 0
    entryAllowed := true  // Force allow entries if phantom position detected

// PHANTOM POSITION DETECTOR & AUTO-FIX
var int phantomPositionBars = 0
var bool phantomDetected = false

// Detect phantom positions (position_size != 0 but no open trades)
if strategy.position_size != 0 and strategy.opentrades == 0
    phantomPositionBars := phantomPositionBars + 1
    phantomDetected := true
    
    // Force close phantom position after 1 bar to reset strategy state
    if phantomPositionBars >= 1
        if strategy.position_size > 0
            strategy.close_all("PHANTOM_LONG_RESET")
        else
            strategy.close_all("PHANTOM_SHORT_RESET")
        phantomPositionBars := 0
        phantomDetected := false
        entryAllowed := true
else
    phantomPositionBars := 0
    phantomDetected := false

// Long Entry with improved entry control
if longEntrySignal and entryAllowed
    strategy.entry("Long", strategy.long, qty=positionQty, alert_message=longEntryMsg, comment=dynamicLongText)
    // NOTE: entryAllowed stays true to allow adding/reversing positions

// Short Entry with improved entry control  
if shortEntrySignal and entryAllowed
    strategy.entry("Short", strategy.short, qty=positionQty, alert_message=shortEntryMsg, comment=dynamicShortText)
    // NOTE: entryAllowed stays true to allow adding/reversing positions

// ═══════════════════ STRATEGY EXECUTION DEBUG (CRITICAL) ═══════════════════
// Debug the actual strategy.entry() calls vs our visual indicators

// Show when strategy.entry() is ACTUALLY CALLED
plotchar(longEntrySignal and entryAllowed, title="📞 CALLING strategy.entry LONG", char='📞', location=location.belowbar, color=color.new(color.white, 0), size=size.large)
plotchar(shortEntrySignal and entryAllowed, title="📞 CALLING strategy.entry SHORT", char='📞', location=location.abovebar, color=color.new(color.white, 0), size=size.large)

// Show actual strategy position changes (when fills occur)
var float lastPositionSize = 0
positionChanged = strategy.position_size != lastPositionSize
plotchar(positionChanged and strategy.position_size > lastPositionSize, title="✅ LONG FILL DETECTED", char='✅', location=location.belowbar, color=color.new(color.lime, 0), size=size.huge)
plotchar(positionChanged and strategy.position_size < lastPositionSize, title="✅ SHORT FILL DETECTED", char='✅', location=location.abovebar, color=color.new(color.red, 0), size=size.huge)
lastPositionSize := strategy.position_size

// Show backtest vs live mode detection  
plotchar(barstate.isconfirmed, title="📊 HISTORICAL BAR", char='H', location=location.top, color=color.new(color.gray, 50), size=size.tiny)
plotchar(barstate.isrealtime, title="🔴 REALTIME BAR", char='R', location=location.top, color=color.new(color.red, 0), size=size.tiny)
plotchar(not barstate.isconfirmed and not barstate.isrealtime, title="⏳ ELAPSED REALTIME", char='E', location=location.top, color=color.new(color.orange, 0), size=size.tiny)

// CRITICAL: Compare entry calls vs actual fills by bar type
plotchar(longEntrySignal and entryAllowed and barstate.isconfirmed, title="🏛️ HISTORICAL LONG CALL", char='🏛️', location=location.belowbar, color=color.new(color.gray, 0), size=size.normal)
plotchar(longEntrySignal and entryAllowed and barstate.isrealtime, title="⚡ REALTIME LONG CALL", char='⚡', location=location.belowbar, color=color.new(color.yellow, 0), size=size.normal)

// Show strategy.closedtrades count changes (when trades complete)
var int lastClosedTrades = 0
newTradeCompleted = strategy.closedtrades > lastClosedTrades
plotchar(newTradeCompleted, title="🎯 TRADE COMPLETED", char='🎯', location=location.top, color=color.new(color.purple, 0), size=size.normal)
lastClosedTrades := strategy.closedtrades

// Show position size with numeric display
plotchar(strategy.position_size != 0, title="📈 POSITION: " + str.tostring(strategy.position_size), char='📈', location=location.top, color=strategy.position_size > 0 ? color.green : color.red, size=size.small)

// ─────────────────── ENTRY PRICE TRACKING ───────────────────
// Track entry price and signal attribution when position opens
var bool wasFlat = true

// Detect position state change from flat to open
if strategy.position_size == 0
    wasFlat := true
    // Reset exit flags when flat
    trailExitSent := false
else if strategy.position_size != 0 and wasFlat
    // Position just opened - track entry details
    strategyEntryPrice := strategy.position_avg_price
    current_trade_entry := strategy.position_avg_price
    current_trade_peak := 0.0
    current_trade_trough := 0.0
    wasFlat := false
    
    // Set current_trade_signals flag for contributing signals
    // This tracks which signals contributed to opening this trade
    if signal1Enable and ((signal1Usage == 'Entry All') or (signal1Usage == 'Entry Long Only' and strategy.position_size > 0) or (signal1Usage == 'Entry Short Only' and strategy.position_size < 0))
        if (strategy.position_size > 0 and signal1LongSrc != close) or (strategy.position_size < 0 and signal1ShortSrc != close)
            array.set(current_trade_signals, 0, true)
    if signal2Enable and ((signal2Usage == 'Entry All') or (signal2Usage == 'Entry Long Only' and strategy.position_size > 0) or (signal2Usage == 'Entry Short Only' and strategy.position_size < 0))
        if (strategy.position_size > 0 and signal2LongSrc != close) or (strategy.position_size < 0 and signal2ShortSrc != close)
            array.set(current_trade_signals, 1, true)
    if signal3Enable and ((signal3Usage == 'Entry All') or (signal3Usage == 'Entry Long Only' and strategy.position_size > 0) or (signal3Usage == 'Entry Short Only' and strategy.position_size < 0))
        if (strategy.position_size > 0 and signal3LongSrc != close) or (strategy.position_size < 0 and signal3ShortSrc != close)
            array.set(current_trade_signals, 2, true)
    if signal4Enable and ((signal4Usage == 'Entry All') or (signal4Usage == 'Entry Long Only' and strategy.position_size > 0) or (signal4Usage == 'Entry Short Only' and strategy.position_size < 0))
        if (strategy.position_size > 0 and signal4LongSrc != close) or (strategy.position_size < 0 and signal4ShortSrc != close)
            array.set(current_trade_signals, 3, true)
    if signal5Enable and ((signal5Usage == 'Entry All') or (signal5Usage == 'Entry Long Only' and strategy.position_size > 0) or (signal5Usage == 'Entry Short Only' and strategy.position_size < 0))
        if (strategy.position_size > 0 and signal5LongSrc != close) or (strategy.position_size < 0 and signal5ShortSrc != close)
            array.set(current_trade_signals, 4, true)
    if signal6Enable and ((signal6Usage == 'Entry All') or (signal6Usage == 'Entry Long Only' and strategy.position_size > 0) or (signal6Usage == 'Entry Short Only' and strategy.position_size < 0))
        if (strategy.position_size > 0 and signal6LongSrc != close) or (strategy.position_size < 0 and signal6ShortSrc != close)
            array.set(current_trade_signals, 5, true)
    if signal7Enable and ((signal7Usage == 'Entry All') or (signal7Usage == 'Entry Long Only' and strategy.position_size > 0) or (signal7Usage == 'Entry Short Only' and strategy.position_size < 0))
        if (strategy.position_size > 0 and signal7LongSrc != close) or (strategy.position_size < 0 and signal7ShortSrc != close)
            array.set(current_trade_signals, 6, true)
    if signal8Enable and ((signal8Usage == 'Entry All') or (signal8Usage == 'Entry Long Only' and strategy.position_size > 0) or (signal8Usage == 'Entry Short Only' and strategy.position_size < 0))
        if (strategy.position_size > 0 and signal8LongSrc != close) or (strategy.position_size < 0 and signal8ShortSrc != close)
            array.set(current_trade_signals, 7, true)
    if signal9Enable and ((signal9Usage == 'Entry All') or (signal9Usage == 'Entry Long Only' and strategy.position_size > 0) or (signal9Usage == 'Entry Short Only' and strategy.position_size < 0))
        if (strategy.position_size > 0 and signal9LongSrc != close) or (strategy.position_size < 0 and signal9ShortSrc != close)
            array.set(current_trade_signals, 8, true)
    if signal10Enable and ((signal10Usage == 'Entry All') or (signal10Usage == 'Entry Long Only' and strategy.position_size > 0) or (signal10Usage == 'Entry Short Only' and strategy.position_size < 0))
        if (strategy.position_size > 0 and signal10LongSrc != close) or (strategy.position_size < 0 and signal10ShortSrc != close)
            array.set(current_trade_signals, 9, true)

// ─────────────────── DEBUG ENTRY BLOCKING (ENHANCED) ───────────────────
// Show detailed reasons why entries are blocked
debugEntry() =>
    // Enhanced debug - show ALL entry activity
    if showEntryBlocks
        // Show blocked entries
        if longEntrySignal and not entryAllowed
            blockReason = currentPositionSize >= pyramidLimit ? "PYRAMID_LIMIT (" + str.tostring(currentPositionSize) + "/" + str.tostring(pyramidLimit) + ")" : "OTHER_BLOCK"
            debugText = "🚫 LONG BLOCKED\nReason: " + blockReason + "\nPos: " + str.tostring(strategy.position_size) + "\nEntryFlag: " + str.tostring(entryAllowed)
            label.new(bar_index, high + (atrVal * 0.3), debugText, color=color.new(color.red, 10), style=label.style_label_down, textcolor=color.white, size=size.normal)
        
        if shortEntrySignal and not entryAllowed
            blockReason = currentPositionSize >= pyramidLimit ? "PYRAMID_LIMIT (" + str.tostring(currentPositionSize) + "/" + str.tostring(pyramidLimit) + ")" : "OTHER_BLOCK"
            debugText = "🚫 SHORT BLOCKED\nReason: " + blockReason + "\nPos: " + str.tostring(strategy.position_size) + "\nEntryFlag: " + str.tostring(entryAllowed)
            label.new(bar_index, low - (atrVal * 0.3), debugText, color=color.new(color.red, 10), style=label.style_label_up, textcolor=color.white, size=size.normal)
        
        // Show successful entries
        if longEntrySignal and entryAllowed
            debugText = "✅ LONG ENTRY\nPos: " + str.tostring(strategy.position_size) + "→" + str.tostring(strategy.position_size + positionQty) + "\nContracts: " + str.tostring(currentPositionSize) + "/" + str.tostring(pyramidLimit)
            label.new(bar_index, high + (atrVal * 0.5), debugText, color=color.new(color.green, 20), style=label.style_label_down, textcolor=color.white, size=size.small)
            
        if shortEntrySignal and entryAllowed
            debugText = "✅ SHORT ENTRY\nPos: " + str.tostring(strategy.position_size) + "→" + str.tostring(strategy.position_size - positionQty) + "\nContracts: " + str.tostring(currentPositionSize) + "/" + str.tostring(pyramidLimit)
            label.new(bar_index, low - (atrVal * 0.5), debugText, color=color.new(color.green, 20), style=label.style_label_up, textcolor=color.white, size=size.small)

// Also add position status debugging
debugPositionStatus() =>
    if debugEnable and barstate.islast
        statusText = "📊 POSITION STATUS\nSize: " + str.tostring(strategy.position_size) + "\nAvgPrice: " + str.tostring(strategy.position_avg_price) + "\nEntryAllowed: " + str.tostring(entryAllowed) + "\nClosedTrades: " + str.tostring(strategy.closedtrades) + "\nOpenTrades: " + str.tostring(strategy.opentrades)
        label.new(bar_index, close, statusText, color=color.new(color.blue, 20), style=label.style_label_left, textcolor=color.white, size=size.normal)

if debugEnable
    debugEntry()
    debugPositionStatus()
    
    // Show phantom position reset events
    if phantomDetected and phantomPositionBars == 1
        resetText = "⚠️ PHANTOM RESET\nPos: " + str.tostring(strategy.position_size) + "\nOpenTrades: " + str.tostring(strategy.opentrades) + "\nForcing Close All"
        label.new(bar_index, close, resetText, color=color.new(color.orange, 0), style=label.style_label_center, textcolor=color.black, size=size.large)
    


// ─────────────────── EXIT LOGIC ───────────────────

// MA EXIT LOGIC (UPDATED WITH ENTRY RE-ENABLING)
if maExitOn and strategy.position_size != 0
    longExitCondition = strategy.position_size > 0 and close < priceMA
    shortExitCondition = strategy.position_size < 0 and close > priceMA
    
    if longExitCondition
        strategy.close("Long", comment="MA Exit", alert_message=longExitMsg)
        entryAllowed := true  // Re-enable entries after exit
        
    if shortExitCondition
        strategy.close("Short", comment="MA Exit", alert_message=shortExitMsg)
        entryAllowed := true  // Re-enable entries after exit

// FIXED SL/TP LOGIC
if fixedEnable and strategy.position_size != 0
    if strategy.position_size > 0  // Long position
        stopLevel = strategy.position_avg_price - tpCalc(fixedStop)
        profitLevel = tp1Enable ? strategy.position_avg_price + tpCalc(tp1Size) : na
        strategy.exit("Fixed-Long", from_entry="Long", stop=stopLevel, limit=profitLevel, comment="Fixed SL/TP")
    
    if strategy.position_size < 0  // Short position
        stopLevel = strategy.position_avg_price + tpCalc(fixedStop)
        profitLevel = tp1Enable ? strategy.position_avg_price - tpCalc(tp1Size) : na
        strategy.exit("Fixed-Short", from_entry="Short", stop=stopLevel, limit=profitLevel, comment="Fixed SL/TP")

// ADVANCED TREND EXIT EXECUTION (UPDATED WITH ENTRY RE-ENABLING)
if colorChangeExit and strategy.position_size != 0
    if strategy.position_size > 0
        strategy.close("Long", comment="LRC Exit", alert_message=longExitMsg)
        entryAllowed := true  // Re-enable entries after exit
        
    if strategy.position_size < 0
        strategy.close("Short", comment="LRC Exit", alert_message=shortExitMsg)
        entryAllowed := true  // Re-enable entries after exit

// BASIC TREND CHANGE EXIT EXECUTION (UPDATED WITH ENTRY RE-ENABLING)
if trendChangeDetected and trendChangeExitEnable and strategy.position_size != 0 and not useAdvancedTrendExit
    if strategy.position_size > 0
        strategy.close("Long", comment="Trend Change Exit", alert_message=longExitMsg)
        entryAllowed := true  // Re-enable entries after exit
        
    if strategy.position_size < 0
        strategy.close("Short", comment="Trend Change Exit", alert_message=shortExitMsg)
        entryAllowed := true  // Re-enable entries after exit