// ***************************************** ATTENTION ************************************************
//
// These metrics are not to be reproduced, copied, or distributed to anyone besides the original owner.
// Doing so is in direct violation of Simple Market Metrics policies, and penalties will apply.
//
// https://simplemarketmetrics.gumroad.com/l/ddcud
//
// ****************************************************************************************************

//@version=5
indicator("Simple Market Metrics v5", max_lines_count=500, max_labels_count=500, behind_chart=false) // SMM v5.01

// ________ Rules and FAQ text ___________________________
var const string titleRules = "***** Simple Market Metrics Trading Rules *****"
var const string signalRules = "\n\n1. How to enter a trade:\n• Wait for a Buy or Sell signal to appear"
var const string entryRules = "\n• If the signal remains when the candle closes, enter the trade with a market or limit order"

var const string tpRules = "\n\n2. How to exit a trade:\n• Take profit when the price reaches the profit target line"
var const string exitRules = "\n• Stop out of the trade if the white dot remains on the opposite side of the profit wave only when the candle has closed."
var const string exitExample = "\n\ne.g. If you are in a long trade, and a candle closes with the white dot below the profit wave, close the trade."
var const string tradingRules = titleRules + signalRules + entryRules + tpRules + exitRules + exitExample

var const string faq = "--------| Frequently Asked Questions |--------"
var const string faq1 = "\n\n1. What markets can this be traded with?\n• Simple Market Metrics works with any market, but the ES & NQ Futures are the preferred markets to trade this system with."
var const string faq2 = "\n\n2. What candle type should be used?\n• Simple Market Metrics was designed to be used on Heikin Ashi candles."
var const string faq3 = "\n\n3. What are the preferred trading hours?\n• The preferred hours to trade are during the New York session between 10:00am EST and 3:00pm EST."
var const string faq4 = "\n\n4. What timeframe should I trade?\n• The 1 and 2 minute timeframes are preferred with ES & NQ Futures"
var const string faq5 = "\n\n5. What should I set the profit targets to?\n• ES - 1 min: 4\n• ES - 2 min: 8\n• NQ - 1 min: 20\n• NQ - 2 min: 40"
var const string faq6 = "\n\n6. How many contracts should I start trading with prop firm accounts?\n• 50k - 5 micros on MES or MNQ \n• 150k - 2 minis on ES or NQ"
var const string faqText = faq + faq1 + faq2 + faq3 + faq4 + faq5 + faq6

var const string finalNotes = "Some final notes:\n\nThe Simple Market Metrics trading system has been built specifically for trading the ES & NQ Futures markets, with the goal of small but consistent daily profits."
var const string finalNotes1 = "\n\nAlthough you may trade any market and timeframe you wish, it is up to you to determine the best settings for other markets and timeframes."
var const string finalNotes2 = "\n\nTrading is risky, do not trade with money you are not comfortable losing.\nControl your risk by managing your position size accordingly, and please practice on a sim account before using real money."
var const string finalNotes3 = "\n\nIf you need further assistance, contact us at simplemarketmetrics@gmail.com"
var const string notesText = finalNotes + finalNotes1 + finalNotes2 + finalNotes3



// ________ All Inputs Here ___________________________
var const string startHereGroup = "------------------>  START HERE  <------------------"
rulesCheck = input.bool(false, title="Please Read The Trading Rules  ----->", group=startHereGroup, tooltip=tradingRules)
faqCheck = input.bool(false, title="Frequently Asked Questions  ------->", group=startHereGroup, tooltip=faqText)
notesCheck = input.bool(false, title="Final Notes & Contact Info  --------->", group=startHereGroup, tooltip=notesText)
var bool disableWarning = false

//Signals Inputs
var signalsGroupName = '-----  Signal Settings  -----'
enableBuySellSignals = input.bool(true,title='Enable Buy & Sell Signals', group=signalsGroupName)
enableBuySellPrice = input.bool(true,title='Enable Buy & Sell Price', group=signalsGroupName)
buySignalColor = input.color(color.new(#4caf50, 0),'Buy Signal Color', group=signalsGroupName)
sellSignalColor = input.color(color.new(#b22833, 0), 'Sell Signal Color', group=signalsGroupName)

enableChopFilter = input.bool(true, title='Enable Chop Filter', group=signalsGroupName, tooltip='This helps to reduce signals during choppy markets, and will produce less signals overall when enabled.')
enableMaFilter = input.bool(true, 'Enable MA Filter',group=signalsGroupName)
maFilterType = input.string("EMA","MA Filter Type", options = ["EMA", "SMA", "VWMA", "RMA" , "Hull"],group=signalsGroupName)
maFilterLength = input.int(200, 'MA Filter Period', minval=1,group=signalsGroupName)
maFilterColor = input.color(color.new(color.white, 0), 'MA Filter Color', group=signalsGroupName)

enableTimeFilter = input.bool(false,title='Enable Time Filter', group=signalsGroupName)
usersTimezone = input.string('GMT-5', "Your Timezone", options = ['GMT-12','GMT-11','GMT-10','GMT-9','GMT-8','GMT-7','GMT-6','GMT-5','GMT-4','GMT-3','GMT-2','GMT-1','GMT+0','GMT+1','GMT+2','GMT+3','GMT+4','GMT+5','GMT+6','GMT+7','GMT+8','GMT+9','GMT+10','GMT+11','GMT+12','GMT+13','GMT+14'], group=signalsGroupName)
startEndTime = input.session("0930-1600", "Start - End Time", group=signalsGroupName)



// Profit Inputs
var profitWaveGroupName = '-----  Profit Settings  -----'
enableProfitLines = input.bool(true, title='Enable Profit Target Lines', group=profitWaveGroupName)
profitTarget = input.int(20, title='Profit Target (Ticks/Pips/Cents)', group=profitWaveGroupName, tooltip='Profit target value is based on the minimum move of the instrument. For Futures that is ticks, FX is pips, Stocks are cents, etc.')
profitTargetMaxLines = input.int(10, title='Max Profit Target Lines', group=profitWaveGroupName, tooltip='Maximum amount of profit target lines to display on your chart.')
profitTargetColor = input.color(color.new(color.yellow, 0),'Profit Target Lines Color', group=profitWaveGroupName)
enableProfitWave = input.bool(true, "Enable Profit Wave", group=profitWaveGroupName)
profitWaveUpperBullishColor = input.color(color.new(#00ff8480, 50),'Profit Wave Bullish Top Color', group=profitWaveGroupName)
profitWaveLowerBullishColor = input.color(color.new(color.green, 50), 'Profit Wave Bullish Bottom Color', group=profitWaveGroupName)
profitWaveLowerBearishColor = input.color(color.new(#8c0000, 50), 'Profit Wave Bearish Top Color', group=profitWaveGroupName)
profitWaveUpperBearishColor = input.color(color.new(#ff0000, 50),'Profit Wave Bearish Bottom Color', group=profitWaveGroupName)


// Background Trend Inputs
var backgroundTrendGroupName = '-----  Background Trend Settings  -----'
enableBgColor = input.bool(true, "Enable Background Trend Color", group=backgroundTrendGroupName)
bgTrendBullishCol = input.color(color.new(#66ff00, 70),'Bullish Background Color', group=backgroundTrendGroupName)
bgTrendBearishCol = input.color(color.new(#ff0000, 70), 'Bearish Background Color', group=backgroundTrendGroupName)


// Candle Coloring Inputs
var candleSettings = "-----  Candle Settings  -----"
bullishCandleColor = input.color(color.new(#089981, 0),'Bullish Candle Color', group=candleSettings)
bearishCandleColor = input.color(color.new(#f23645, 0), 'Bearish Candle Color', group=candleSettings)
enableTrendCandleColoring = input.bool(true,title='Enable Candle Color Matching', group=candleSettings)
candleColoringType = input.string("Profit Wave",title='Match Candle Colors To', options=["Profit Wave","Trend"], group=candleSettings)


// Support / Resistance Inputs
var sdGroupName = '-----  Support & Resistance Settings  -----'
ensr = input.bool(true,title='Enable Support & Resistance Lines', group=sdGroupName)
resistanceColor = input.color(#ff0000,'Resistance Lines Color', group=sdGroupName)
supportColor = input.color(#66ff00,'Support Lines Color', group=sdGroupName)
srStyle = input.string("Dotted", options=["Dashed", "Dotted", "Solid"], title="Support & Resistance Lines Style", group=sdGroupName)
srLineWidth = input.int(2, "Support & Resistance Lines Width", minval=1, maxval=5, step=1, group=sdGroupName)
extendLinesType = input.string('Close', title='Extend Lines Until', options=['Touch', 'Close'], group=sdGroupName, tooltip='Extend the lines until price touches them or a candle closes beyond them.')
pivotchopSensitivity = 20
maxSrLines = 50


// Real Price Inputs
var rplGroupName = '-----  Real Price Settings -----'
showrealprice = input(false, title="Enable Real Price Line", group=rplGroupName)
extendLine = input(false, title="Extend Real Price Line", group=rplGroupName)
showrealpricelinecolor = input(color.new(color.white, 0), title="Real Price Line Color", group=rplGroupName)
realpricewidth = input.string("Thin", options=["Thin", "Thick"], title="Real Price Line Width", group=rplGroupName)
realpricestyle = input.string("Dotted", options=["Dotted", "Solid", "Dashed"], title="Real Price Line Style", group=rplGroupName)
plotrealsrcClosedots = input.bool(true, title="Enable Real Close Price Dots", group=rplGroupName)
realsrcClosecolour = input(color.new(color.white, 0), title="Real Close Price Dot Color", group=rplGroupName)
size = input.string("Small", options=["Auto", "Small", "Large"], title="Real Close Price Dot Size", group=rplGroupName)


// Matrix Inputs
var matrixGroupName = '-----  Matrix Settings  -----'
var matrixInlineName = "matrixInlineName"
matrixStyle = input.string("Horizontal", "Layout Style", options=["Horizontal", "Vertical"], group=matrixGroupName)
matrixPosition = input.string("Bottom Right", "Location On Chart", options=["Top Left", "Top Center", "Top Right", "Bottom Left", "Bottom Center", "Bottom Right"], group=matrixGroupName)

matrixTimeframeColor = input.color(color.purple,'Timeframe Cell Color', group=matrixGroupName, inline="matrixTimeframeColors")
matrixTimeframeTextColor = input.color(color.white,'Text Color', group=matrixGroupName, inline="matrixTimeframeColors")
enableMatrixTF1 = input.bool(true, "Enable Matrix Timeframe 1", group=matrixGroupName, inline="matrixRow1")
matrixTF1 = input.timeframe("1", "", group=matrixGroupName, inline="matrixRow1")

enableMatrixTF2 = input.bool(true, "Enable Matrix Timeframe 2", group=matrixGroupName, inline="matrixRow2")
matrixTF2 = input.timeframe("2", "", group=matrixGroupName, inline="matrixRow2")

enableMatrixTF3 = input.bool(true, "Enable Matrix Timeframe 3", group=matrixGroupName, inline="matrixRow3")
matrixTF3 = input.timeframe("5", "", group=matrixGroupName, inline="matrixRow3")

matrixColumn1 = input.bool(true, "Show Avg True Range (ATR)", group=matrixGroupName)
matrixAtrLength = input.int(defval=3, minval=1, title="Avg True Range (ATR) Length", group=matrixGroupName)
matrixAtrColor = input.color(color.blue,'ATR Cell Color', group=matrixGroupName, inline="matrixAtrColors")
matrixAtrTextColor = input.color(color.white,'Text Color', group=matrixGroupName, inline="matrixAtrColors")

matrixColumn2 = input.bool(true, "Show Current Candle Column", group=matrixGroupName)
matrixColumn3 = input.bool(true, "Show Trend Column", group=matrixGroupName)
matrixColumn4 = input.bool(true, "Show Profit Wave Column", group=matrixGroupName)
matrixColumn5 = input.bool(true, "Show Money Flow Column", group=matrixGroupName)

matrixHeaderColor = input.color(color.black,'Header Cell Color', group=matrixGroupName, inline="matrixHeaderColors")
matrixHeaderTextColor = input.color(color.white,'Text Color', group=matrixGroupName, inline="matrixHeaderColors")
matrixBullishColor = input.color(color.green,'Bullish Cell Color', group=matrixGroupName, inline="matrixBullishColors")
matrixBullishTextColor = input.color(color.white,'Text Color', group=matrixGroupName, inline="matrixBullishColors")
matrixBearishColor = input.color(color.red,'Bearish Cell Color', group=matrixGroupName, inline="matrixBearishColors")
matrixBearishTextColor = input.color(color.white,'Text Color', group=matrixGroupName, inline="matrixBearishColors")



// Dashboard Inputs
var dashboardSettings = "-----  Dashboard Settings  -----"
positionMatrixOnTop = input.bool(true, "Show Matrix History Above Money Flow?", group=dashboardSettings)
enableMatrixDashboard1 = input.bool(true, "Enable Matrix History for Timeframe 1", group=dashboardSettings)
enableMatrixDashboard2 = input.bool(true, "Enable Matrix History for Timeframe 2", group=dashboardSettings)
enableMatrixDashboard3 = input.bool(true, "Enable Matrix History for Timeframe 3", group=dashboardSettings)
enableMatrixDashboardLabels = input.bool(true, "Enable Matrix Timeframe Labels", group=dashboardSettings)

enableDashboard = input.bool(true, "Enable Money Flow Display", group=dashboardSettings)
enableDashboardBuySellSignals = input.bool(false,title='Enable Buy & Sell Signals on Dashboard', group=dashboardSettings)
showInsideLines = input.bool(false, "Enable Level Lines", group=dashboardSettings)
levelLinesStyle = input.string("Solid", options=["Solid", "Dotted", "Dashed"], title="Level Lines Style", group=dashboardSettings)
trendDotsSize = input.int(1, "trendSwitch Dots Size", minval=1, maxval=10, step=1, group=dashboardSettings)
crossoverDotsSize = input.int(3, "Signal Dots Size", minval=3, maxval=10, step=1, group=dashboardSettings)
mfiBullishColor = input.color(color.lime,'Money Flow Bullish Color', group=dashboardSettings)
mfiBearishColor = input.color(color.red,'Money Flow Bearish Color', group=dashboardSettings)


// Others
disableWarning := input.bool(false, title="Disable Heikin Ashi Warning", group="Other Settings")


// ----------------------------------------------------------------------------------------------------------------------------------
// startTime = timestamp(year, month, dayofmonth, startHour, startMinute)
// endTime = timestamp(year, month, dayofmonth, endHour, endMinute)
isValidTimeRange = enableTimeFilter ? not na(time(timeframe.period, startEndTime, usersTimezone)) : true
// isValidTimeRange = enableTimeFilter ? (time >= startTime and time < endTime) : true

// ________ Price & Candle Logic ___________________________
var isHAChartType = chart.is_heikinashi
var label myLabel = na
labelDisplayed = false
var const string warningText = "\n⚠️  WARNING!!!  ⚠️\n\nYou MUST set the chart candle type\nto Heikin Ashi for the signals to display correctly.\n\nThis message will disappear when you've done so.\n"
if not isHAChartType and not disableWarning and not labelDisplayed
    enableBgColor := false
    enableBuySellSignals := false
    enableProfitLines := false
    enableTrendCandleColoring := false
    enableProfitWave := false
    ensr := false
    // plotrealsrcClosedots := false
    middle_price = (high + low) / 2
    visible_bar_count = bar_index - ta.valuewhen(time == chart.left_visible_bar_time, bar_index, 0)
    middle_bar_index = bar_index[visible_bar_count / 2]

    if na(myLabel)
        myLabel := label.new(x=middle_bar_index, y=middle_price, text=warningText, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_center, color=color.red, textcolor=color.white, size=size.huge, textalign=text.align_center, force_overlay=true)
    else
        myLabel.set_x(middle_bar_index)
        myLabel.set_y(middle_price)
        labelDisplayed := true

else if isHAChartType or disableWarning
    myLabel := na

srcHlc3 = hlc3
srcOpen = open
srcHigh = high
srcLow = low
srcClose = close

real_price = ticker.new(prefix=syminfo.prefix, ticker=syminfo.ticker)
real_close = request.security(symbol=real_price, timeframe='', expression=close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

profitWaveEmaFast = ta.ema(srcClose, 8)
profitWaveEmaMedium = ta.ema(srcClose, 13)
profitWaveEmaSlow = ta.ema(srcClose, 21)


chopSensitivity = 1
trueRange = math.max(math.max(high-low, math.abs(high-nz(close[1]))), math.abs(low-nz(close[1])))
diPlusCalculation = high-nz(high[1]) > nz(low[1])-low ? math.max(high-nz(high[1]), 0): 0
diMinusCalculation = nz(low[1])-low > high-nz(high[1]) ? math.max(nz(low[1])-low, 0): 0

smoothedTrueRange = 0.0
smoothedTrueRange := nz(smoothedTrueRange[1]) - (nz(smoothedTrueRange[1])/chopSensitivity) + trueRange

smoothedDiPlus = 0.0
smoothedDiPlus := nz(smoothedDiPlus[1]) - (nz(smoothedDiPlus[1])/chopSensitivity) + diPlusCalculation

smoothedDiMinus = 0.0
smoothedDiMinus := nz(smoothedDiMinus[1]) - (nz(smoothedDiMinus[1])/chopSensitivity) + diMinusCalculation

diPlus = smoothedDiPlus / smoothedTrueRange * 100
diMinus = smoothedDiMinus / smoothedTrueRange * 100
dx = math.abs(diPlus-diMinus) / (diPlus+diMinus)*100
ADX = ta.sma(dx, chopSensitivity)

GetTrendDirection(srcHigh, srcLow) =>
    Up = (srcHigh + srcLow) / 2 - (1.3 * ta.atr(8))
    Dn = (srcHigh + srcLow) / 2 + (1.3 * ta.atr(8))

    float trendUp = na
    float trendDown = na
    trendSwitch = 0

    trendUp := srcClose[1] > trendUp[1] ? math.max(Up,trendUp[1]) : Up
    trendDown := srcClose[1] < trendDown[1] ? math.min(Dn,trendDown[1]) : Dn
    trendSwitch := srcClose > trendDown[1] ? 1: srcClose < trendUp[1]? -1: nz(trendSwitch[1],1)
    trendDirection = trendSwitch == 1 ? trendUp : trendDown
    [trendDirection, trendUp, trendDown]

[trendDirection, trendUp, trendDown] = GetTrendDirection(srcHigh, srcLow)
bullishTrend = trendDirection == trendUp
bearishTrend = trendDirection == trendDown

maFilter = switch maFilterType
    "EMA" => ta.ema(srcClose, maFilterLength)
    "SMA" => ta.sma(srcClose, maFilterLength)
    "VWMA" => ta.vwma(srcClose, maFilterLength)
    "RMA" => ta.rma(srcClose, maFilterLength) 
    "Hull" => ta.wma(2*ta.wma(srcClose, maFilterLength/2)-ta.wma(srcClose, maFilterLength), math.floor(math.sqrt(maFilterLength)))
    => na

plot(enableMaFilter ? maFilter : na, force_overlay=true, title = "Filter MA", color=maFilterColor, linewidth=2)


// ________ Background Trend Logic ___________________________

backgroundTrendColor = color.white
if (trendDirection == trendUp)
    backgroundTrendColor := bgTrendBullishCol
else if (trendDirection == trendDown)
    backgroundTrendColor := bgTrendBearishCol
else
    backgroundTrendColor := backgroundTrendColor[1]

bgcolor(enableBgColor ? backgroundTrendColor : na, force_overlay = true)


// Base Candle coloring
candleColor = color.gray
candleColor := if (srcClose > srcOpen)
    bullishCandleColor
else if (srcClose < srcOpen)
    bearishCandleColor
else
    candleColor[1]

if (enableTrendCandleColoring and candleColoringType == "Trend")
    candleColor := if (backgroundTrendColor == bgTrendBullishCol)
        bullishCandleColor
    else if (backgroundTrendColor == bgTrendBearishCol)
        bearishCandleColor
    else
        candleColor[1]
    
else if (enableTrendCandleColoring and candleColoringType == "Profit Wave")
    candleColor := if (real_close > profitWaveEmaSlow)
        bullishCandleColor
    else if (real_close < profitWaveEmaSlow)
        bearishCandleColor
    else
        candleColor[1]

plotcandle(srcOpen, srcHigh, srcLow, srcClose, "SMM Candles", color=candleColor, wickcolor=candleColor, bordercolor=candleColor, force_overlay=true)


// ________ Signals Logic ___________________________
var bool buySignal = false
var bool sellSignal = false

buySignal := trendDirection == trendUp
sellSignal := trendDirection == trendDown

mfl = ta.mfi(srcHlc3, 10)

enum Mode
    buy = "Buy Mode"
    sell = "Sell Mode"
    none = "none"

var Mode currentMode = Mode.none

if (backgroundTrendColor != backgroundTrendColor[1])
    currentMode := Mode.none

strongBullishCandle = srcClose > srcOpen and math.floor(srcOpen) == math.floor(srcLow) and real_close > profitWaveEmaFast and real_close > profitWaveEmaSlow
strongBearishCandle = srcClose < srcOpen and math.floor(srcOpen) == math.floor(srcHigh) and real_close < profitWaveEmaFast and real_close < profitWaveEmaSlow
realClosePriceText = enableBuySellPrice ? "\n$" + str.tostring(real_close, format.mintick) : ""

bool canBuy = true
bool canSell = true
if (enableChopFilter)
    canBuy := math.floor(diPlus) > math.floor(diMinus) and math.floor(diPlus) >= 45
    canSell := math.floor(diMinus) > math.floor(diPlus) and math.floor(diMinus) >= 45
else
    canBuy := true
    canSell := true

var int currentSignalBarIndex = na

// Bullish signals
maFilterBuy = enableMaFilter ? srcClose > maFilter and real_close > maFilter : true
mfiBuy = enableChopFilter ? mfl > 52 : true
buy_con = buySignal and backgroundTrendColor == bgTrendBullishCol and strongBullishCandle and currentMode != Mode.buy and mfiBuy and canBuy
if (buy_con and enableBuySellSignals)
    currentMode := Mode.buy
    if isValidTimeRange and maFilterBuy
        label.new(bar_index, low, style=label.style_label_up, color=buySignalColor, size=size.normal, yloc=yloc.belowbar, text="Buy"+realClosePriceText, textcolor=color.white, force_overlay=true)
        currentSignalBarIndex := bar_index


// Bearish signals
maFilterSell = enableMaFilter ? srcClose < maFilter and real_close < maFilter : true
mfiSell = enableChopFilter ? mfl < 52 : true
sell_con = sellSignal and backgroundTrendColor == bgTrendBearishCol and strongBearishCandle and currentMode != Mode.sell and mfiSell and canSell
if (sell_con and enableBuySellSignals)
    currentMode := Mode.sell
    if isValidTimeRange and maFilterSell
        label.new(bar_index, high, style=label.style_label_down, color=sellSignalColor, size=size.normal, yloc=yloc.abovebar, text="Sell"+realClosePriceText, textcolor=color.white, force_overlay=true)
        currentSignalBarIndex := bar_index


// Profit Target lines
var line[] targetLines = array.new_line(0)
var label[] targetLabels = array.new_label(0)
var float targetPrice = na

if (((buy_con and maFilterBuy) or (sell_con and maFilterSell)) and enableBuySellSignals and enableProfitLines and isValidTimeRange)
    if array.size(targetLines) >= profitTargetMaxLines
        oldestLine = array.get(targetLines, 0)
        oldestLabel = array.get(targetLabels, 0)
        line.delete(oldestLine)
        label.delete(oldestLabel)
        array.remove(targetLines, 0)
        array.remove(targetLabels, 0)
    targetPrice := buy_con ? real_close + (profitTarget * syminfo.mintick) : sell_con ? real_close - (profitTarget * syminfo.mintick) : na    
    newLine = line.new(bar_index-7, targetPrice, bar_index + 5, targetPrice, color=profitTargetColor, width=2, force_overlay=true)
    array.push(targetLines, newLine)
    newLabel = label.new(bar_index-3, targetPrice, text="$"+str.tostring(targetPrice, format.mintick), style=label.style_none, textcolor=profitTargetColor, force_overlay=true)
    array.push(targetLabels, newLabel)


// Reset for more signals within continuous trend
if (currentMode == Mode.buy and real_close < profitWaveEmaSlow and srcClose < profitWaveEmaSlow)
    currentMode := Mode.none
    currentSignalBarIndex := na

if (currentMode == Mode.sell and real_close > profitWaveEmaSlow and srcClose > profitWaveEmaSlow)
    currentMode := Mode.none
    currentSignalBarIndex := na

profitTargetCondition = if not na(currentSignalBarIndex) and bar_index > currentSignalBarIndex
    currentMode == Mode.buy ? srcHigh >= targetPrice : currentMode == Mode.sell ? srcLow <= targetPrice : na

// Signal Alerts
alertcondition(condition=buy_con and maFilterBuy and isValidTimeRange,title='Buy alert', message='Buy')
alertcondition(condition=sell_con and maFilterSell and isValidTimeRange,title='Sell alert', message='Sell')

alertcondition(condition=enableBuySellSignals and enableProfitLines ? profitTargetCondition : na, title="Profit Target", message="Profit Target Hit!")
if profitTargetCondition
    targetPrice := na
    currentSignalBarIndex := na


// ________ Profit Wave Logic ___________________________
pwPlot1 = plot(enableProfitWave ? profitWaveEmaFast : na, title="Profit Wave Line 1", color=color.new(color.white, 100), linewidth=1, force_overlay = true)
pwPlot2 = plot(enableProfitWave ? profitWaveEmaMedium : na, title="Profit Wave Line 2", color=color.new(color.white, 100), linewidth=1, force_overlay = true)
pwPlot3 = plot(enableProfitWave ? profitWaveEmaSlow : na, title="Profit Wave Line 3", color=color.new(color.white, 100), linewidth=1, force_overlay = true)

pwUpperBullishColor = real_close > profitWaveEmaSlow ? profitWaveUpperBullishColor : color.new(color.lime, 100)
pwLowerBullishColor = real_close > profitWaveEmaSlow ? profitWaveLowerBullishColor : color.new(color.green, 100)
fill(pwPlot1, pwPlot2, pwUpperBullishColor)
fill(pwPlot2, pwPlot3, pwLowerBullishColor)

pwUpperBearishColor = real_close < profitWaveEmaSlow ? profitWaveUpperBearishColor : color.new(#ff0000, 100)
pwLowerBearishColor = real_close < profitWaveEmaSlow ? profitWaveLowerBearishColor : color.new(#8c0000, 100)
fill(pwPlot1, pwPlot2, pwUpperBearishColor)
fill(pwPlot2, pwPlot3, pwLowerBearishColor)



// ________ Support / Resistance Logic ___________________________
srLineStyle = switch srStyle
    "Solid" => line.style_solid
    "Dotted" => line.style_dotted
    "Dashed" => line.style_dashed

// Identify pivot highs and pivot lows
pivotHigh = ta.pivothigh(srcHigh, pivotchopSensitivity, pivotchopSensitivity)
pivotLow = ta.pivotlow(srcLow, pivotchopSensitivity, pivotchopSensitivity)

// Initialize arrays to store the lines
var line[] resistanceLines = array.new_line(0)
var line[] supportLines = array.new_line(0)
var int[] resistanceTouchBars = array.new_int(0)
var int[] supportTouchBars = array.new_int(0)
lookbackchopSensitivity = 500

// Function to manage line limits (removing the oldest line if limit is exceeded)
f_manage_line_limit(array<line> linesArray, array<int> touchBarsArray) =>
    if array.size(linesArray) > maxSrLines
        // Delete the first (oldest) line
        line.delete(array.shift(linesArray))
        // Remove the first touch bar value
        array.shift(touchBarsArray)

// Draw new resistance line if a new pivot high is detected
if (ensr and not na(pivotHigh) and bar_index[pivotchopSensitivity] >= bar_index - lookbackchopSensitivity)
    pivotHighPrice = srcHigh[pivotchopSensitivity]
    pivotHighBar = bar_index[pivotchopSensitivity]
    resistanceLine = line.new(pivotHighBar, pivotHighPrice, bar_index + 1, pivotHighPrice, style=srLineStyle, width=srLineWidth, color=resistanceColor, extend=extend.right, force_overlay=true)
    array.push(resistanceLines, resistanceLine)
    array.push(resistanceTouchBars, na)  // No touch yet
    f_manage_line_limit(resistanceLines, resistanceTouchBars)  // Manage the line limit

// Draw new support line if a new pivot low is detected
if (ensr and not na(pivotLow) and bar_index[pivotchopSensitivity] >= bar_index - lookbackchopSensitivity)
    pivotLowPrice = srcLow[pivotchopSensitivity]
    pivotLowBar = bar_index[pivotchopSensitivity]
    supportLine = line.new(pivotLowBar, pivotLowPrice, bar_index + 1, pivotLowPrice, style=srLineStyle, width=srLineWidth, color=supportColor, extend=extend.right, force_overlay=true)
    array.push(supportLines, supportLine)
    array.push(supportTouchBars, na)  // No touch yet
    f_manage_line_limit(supportLines, supportTouchBars)  // Manage the line limit

// Loop through the resistance lines and stop their extension if the price touches them
if array.size(resistanceLines) > 0
    resLineStop = extendLinesType == 'Close' ? srcClose : srcHigh
    for i = 0 to array.size(resistanceLines) - 1
        line currentResistanceLine = array.get(resistanceLines, i)
        resistancePrice = line.get_y1(currentResistanceLine)
        touchBar = array.get(resistanceTouchBars, i)
        
        // Update the line to the current candle unless already touched
        if na(touchBar)
            line.set_x2(currentResistanceLine, bar_index)
            line.set_extend(currentResistanceLine, extend.none)

        // Check if the price touches the resistance and we haven't already stopped the line
        if na(touchBar) and resLineStop >= resistancePrice
            line.set_x2(currentResistanceLine, bar_index)
            line.set_extend(currentResistanceLine, extend.none)
            array.set(resistanceTouchBars, i, bar_index)  // Store the bar where the price touched

// Loop through the support lines and stop their extension if the price touches them
if array.size(supportLines) > 0
    supLineStop = extendLinesType == 'Close' ? srcClose : srcLow
    for i = 0 to array.size(supportLines) - 1
        line currentSupportLine = array.get(supportLines, i)
        supportPrice = line.get_y1(currentSupportLine)
        touchBar = array.get(supportTouchBars, i)
        
        // Update the line to the current candle unless already touched
        if na(touchBar)
            line.set_x2(currentSupportLine, bar_index)
            line.set_extend(currentSupportLine, extend.none)

        // Check if the price touches the support and we haven't already stopped the line
        if na(touchBar) and supLineStop <= supportPrice
            line.set_x2(currentSupportLine, bar_index)
            line.set_extend(currentSupportLine, extend.none)
            array.set(supportTouchBars, i, bar_index)  // Store the bar where the price touched



// ________ Real Price Logic ___________________________Original open source code from Real Price + Dots by PHVNTOM_TRADER
showrealpricemicrodotsauto = (plotrealsrcClosedots and size=="Auto" ? display.all : display.none)
showrealpricemicrodotssmall = (plotrealsrcClosedots and size=="Small" ? display.all : display.none)
showrealpricedotslarge = (plotrealsrcClosedots and size=="Large" ? display.all : display.none)

_width = switch realpricewidth
    "Thin" => 1
    "Thick" => 2

// Real Price Line
if(showrealprice and (realpricestyle == "Solid"))
    real_price_line = line.new(bar_index[1], real_close, bar_index, real_close, xloc.bar_index, (extendLine ? extend.both : extend.right), showrealpricelinecolor, line.style_solid, _width, force_overlay = true)
    line.delete(real_price_line[1])
    
if(showrealprice and (realpricestyle == "Dotted"))
    real_price_line = line.new(bar_index[1], real_close, bar_index, real_close, xloc.bar_index, (extendLine ? extend.both : extend.right), showrealpricelinecolor, line.style_dotted, _width, force_overlay = true)
    line.delete(real_price_line[1])
    
if(showrealprice and (realpricestyle == "Dashed"))
    real_price_line = line.new(bar_index[1], real_close, bar_index, real_close, xloc.bar_index, (extendLine ? extend.both : extend.right), showrealpricelinecolor, line.style_dashed, _width, force_overlay = true)
    line.delete(real_price_line[1])

// Real Price srcClose Dots
plotchar(series=real_close, title="Real Close dots", location=location.absolute, color=realsrcClosecolour, editable=false, char="•", size=size.auto, display=showrealpricemicrodotsauto, force_overlay = true)
plotchar(series=real_close, title="Real Close dots", location=location.absolute, color=realsrcClosecolour, editable=false, char="•", size=size.tiny, display=showrealpricemicrodotssmall, force_overlay = true)
plotshape(series=real_close, title="Real Close dots", location=location.absolute, color=realsrcClosecolour, editable=false, style=shape.circle, size=size.auto, display=showrealpricedotslarge, force_overlay = true)



// ________ Dashboard Oscillator Logic ___________________________
hlineStyle = switch levelLinesStyle
    "Dotted" => hline.style_dotted
    "Dashed" => hline.style_dashed
    => hline.style_solid

top_1 = hline(enableDashboard ? 100 : na,color=color.new(#ff1b1b,50),linestyle=hline.style_solid)
top_2 = hline(enableDashboard ? 90 : na,color=color.new(#ff2626,50),linestyle=hline.style_solid)
top_3 = hline(enableDashboard ? 80 : na,color=color.new(#ff3f3f,50),linestyle=hline.style_solid)
top_4 = hline(showInsideLines and enableDashboard ? 70 : na,color=color.new(#ff5050,50),linestyle=hlineStyle)
top_5 = hline(showInsideLines and enableDashboard ? 60 : na,color=color.new(#ff6464,50),linestyle=hlineStyle)
top_6 = hline(showInsideLines and enableDashboard ? 50 : na,color=color.new(#ff6464,100),linestyle=hlineStyle)

bottom_1 = hline(enableDashboard ? 0 : na,color=color.new(#047200,50),linestyle=hline.style_solid)
bottom_2 = hline(enableDashboard ? 10 : na,color=color.new(#047e00,50),linestyle=hline.style_solid)
bottom_3 = hline(enableDashboard ? 20 : na,color=color.new(#048900,50),linestyle=hline.style_solid)
bottom_4 = hline(showInsideLines and enableDashboard ? 30 : na,color=color.new(#059f00,50),linestyle=hlineStyle)
bottom_5 = hline(showInsideLines and enableDashboard ? 40 : na,color=color.new(#06b200,50),linestyle=hlineStyle)
bottom_6 = hline(showInsideLines and enableDashboard ? 50 : na,color=color.new(#06b200,100),linestyle=hlineStyle)

fill(top_1, top_2, color=color.new(#ff1b1b,20), title="Overbought Extreme Background")
fill(top_2, top_3, color=color.new(#ff2626,40), title="Overbought Start Background")
fill(bottom_1, bottom_2, color=color.new(#047200,10), title="Oversold Start Background")
fill(bottom_3, bottom_2, color=color.new(#047e00,40), title="Oversold Extreme Background")

dotsColor = bullishTrend ? #66ff00 : #ff0000
plot(enableDashboard ? 50 : na,color=dotsColor,style= plot.style_circles, title="Dashboard Center Line trendSwitch Dots", linewidth=trendDotsSize)

plotDashboardBuy = buy_con and enableDashboardBuySellSignals and isValidTimeRange and maFilterBuy
plotDashboardSell = sell_con and enableDashboardBuySellSignals and isValidTimeRange and maFilterSell
plotshape(plotDashboardBuy and enableDashboard ? 10 : na,title='Dashboard Buy Signal',style=shape.labelup,location=location.absolute,text='Buy',textcolor=color.white,color=buySignalColor)
plotshape(plotDashboardSell and enableDashboard ? 90 : na,title='Dashboard Sell Signal',style=shape.labeldown,location=location.absolute,text='Sell',textcolor=color.white,color=sellSignalColor)


mfiTrendColor = if (mfl > 50)
    mfiBullishColor
else if (mfl < 50)
    mfiBearishColor
else
    color.white

plot(enableDashboard ? mfl : na, "Dashboard Money Flow Line", color=mfiTrendColor, style=plot.style_stepline)
plot(plotDashboardBuy and enableDashboard ? 50 : na, color=#66ff00, style=plot.style_circles,linewidth=crossoverDotsSize,title='Dashboard Crossover Up Dots')
plot(plotDashboardSell and enableDashboard ? 50 : na, color=#ff0000, style=plot.style_circles,linewidth=crossoverDotsSize,title='Dashboard Crossover Down Dots')


// ________ Matrix Data Table Logic ___________________________

getMatrixRealClose(ticker, timeframe) =>
    request.security(ticker, timeframe, close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

getMatrixTrendData(timeframe) =>
    [mTrendDirection, mTrendUp, mTrendDown] = request.security(syminfo.tickerid, timeframe, GetTrendDirection(srcHigh, srcLow))
    mBackgroundTrendColor = color.gray
    mTrendTextColor = color.white
    mTrendStatus = ""
    if (mTrendDirection == mTrendUp)
        mBackgroundTrendColor := matrixBullishColor
        mTrendTextColor := matrixBullishTextColor
        mTrendStatus := "Bullish"
    else if (mTrendDirection == mTrendDown)
        mBackgroundTrendColor := matrixBearishColor
        mTrendTextColor := matrixBearishTextColor
        mTrendStatus := "Bearish"
    else
        mBackgroundTrendColor := mBackgroundTrendColor[1]
        mTrendTextColor := mTrendTextColor[1]
        mTrendStatus := mTrendStatus[1]
    [mTrendStatus, mBackgroundTrendColor, mTrendTextColor]

getMatrixProfitWaveData(timeframe, realClose) =>
    mProfitWaveEmaSlow = request.security(syminfo.tickerid, timeframe, ta.ema(srcClose, 21))
    mProfitWaveColor = color.gray
    mProfitWaveTextColor = color.white
    mProfitWaveStatus = ""
    if realClose > mProfitWaveEmaSlow
        mProfitWaveColor := color.new(matrixBullishColor,0)
        mProfitWaveTextColor := matrixBullishTextColor
        mProfitWaveStatus := "Bullish"
    else if realClose < mProfitWaveEmaSlow
        mProfitWaveColor := color.new(matrixBearishColor,0)
        mProfitWaveTextColor := matrixBearishTextColor
        mProfitWaveStatus := "Bearish"
    else
        mProfitWaveColor := mProfitWaveColor[1]
        mProfitWaveTextColor := mProfitWaveTextColor[1]
        mProfitWaveStatus := mProfitWaveStatus[1]
    [mProfitWaveStatus, mProfitWaveColor, mProfitWaveTextColor]

getMatrixCandleData(timeframe, trendStatus, profitWaveStatus) =>
    [mOpen, mClose] = request.security(syminfo.tickerid, timeframe, [srcOpen, srcClose])
    mCandleColor = color.gray
    mCandleStatus = ""
    if (mClose > mOpen)
        mCandleColor := matrixBullishColor
        mCandleStatus := "↑"
    else if (mClose < mOpen)
        mCandleColor := matrixBearishColor
        mCandleStatus := "↓"
    else
        mCandleColor := mCandleColor[1]
        mCandleStatus := mCandleStatus[1]

    if (enableTrendCandleColoring and candleColoringType == "Trend")
        if (trendStatus == "Bullish")
            mCandleColor := matrixBullishColor
            mCandleStatus := "↑"
        else if (trendStatus == "Bearish")
            mCandleColor := matrixBearishColor
            mCandleStatus := "↓"
        else
            mCandleColor := mCandleColor[1]
            mCandleStatus := mCandleStatus[1]
    else if (enableTrendCandleColoring and candleColoringType == "Profit Wave")
        if (profitWaveStatus == "Bullish")
            mCandleColor := matrixBullishColor
            mCandleStatus := "↑"
        else if (profitWaveStatus == "Bearish")
            mCandleColor := matrixBearishColor
            mCandleStatus := "↓"
        else
            mCandleColor := mCandleColor[1]
            mCandleStatus := mCandleStatus[1]
        
    [mCandleStatus, mCandleColor]

getMatrixMfiData(timeframe) =>
    mMfi = request.security(syminfo.tickerid, timeframe, ta.mfi(srcHlc3, 10))
    mMfiColor = color.gray
    mMfiTextColor = color.white
    mMfiStatus = ""
    if (mMfi > 50)
        mMfiColor := matrixBullishColor
        mMfiTextColor := matrixBullishTextColor
        mMfiStatus := "Bullish"
    else if (mMfi < 50)
        mMfiColor := matrixBearishColor
        mMfiTextColor := matrixBearishTextColor
        mMfiStatus := "Bearish"
    else
        mMfiColor := mMfiColor[1]
        mMfiTextColor := mMfiTextColor[1]
        mMfiStatus := mMfiStatus[1]

    [str.tostring(mMfi, "#"), mMfiColor, mMfiTextColor]

getMatrixAtr(timeframe) =>
    atrValue = request.security(syminfo.tickerid, timeframe, ta.atr(matrixAtrLength))
    str.tostring(atrValue, "#.#")

getMatrixHeaderCol(col) =>
    matrixStyle == "Vertical" ? 0 : col
getMatrixHeaderRow(row) =>
    matrixStyle == "Vertical" ? row : 0
getMatrixTfCol(col) =>
    matrixStyle == "Vertical" ? col : 0
getMatrixTfRow(tf, row) =>
    matrixStyle == "Vertical" ? row : tf
getMatrixDataCol(tf, col) =>
    matrixStyle == "Vertical" ? tf : col
getMatrixDataRow(tf, row) =>
    matrixStyle == "Vertical" ? row : tf

m1RealClose = getMatrixRealClose(real_price, matrixTF1)
[m1TrendStatus, m1BackgroundTrendColor, m1TrendTextColor] = getMatrixTrendData(matrixTF1)
[m1ProfitWaveStatus, m1ProfitWaveColor, m1ProfitWaveTextColor] = getMatrixProfitWaveData(matrixTF1, m1RealClose)
[m1MfiStatus, m1MfiColor, m1MfiTextColor] = getMatrixMfiData(matrixTF1)

m2RealClose = getMatrixRealClose(real_price, matrixTF2)
[m2TrendStatus, m2BackgroundTrendColor, m2TrendTextColor] = getMatrixTrendData(matrixTF2)
[m2ProfitWaveStatus, m2ProfitWaveColor, m2ProfitWaveTextColor] = getMatrixProfitWaveData(matrixTF2, m2RealClose)
[m2MfiStatus, m2MfiColor, m2MfiTextColor] = getMatrixMfiData(matrixTF2)

m3RealClose = getMatrixRealClose(real_price, matrixTF3)
[m3TrendStatus, m3BackgroundTrendColor, m3TrendTextColor] = getMatrixTrendData(matrixTF3)
[m3ProfitWaveStatus, m3ProfitWaveColor, m3ProfitWaveTextColor] = getMatrixProfitWaveData(matrixTF3, m3RealClose)
[m3MfiStatus, m3MfiColor, m3MfiTextColor] = getMatrixMfiData(matrixTF3)

if enableMatrixTF1 or enableMatrixTF2 or enableMatrixTF3
    tablePosition = switch matrixPosition
        "Top Left" => position.top_left
        "Top Center" => position.top_center
        "Top Right" => position.top_right
        "Bottom Left" => position.bottom_left
        "Bottom Center" => position.bottom_center
        => position.bottom_right

    var columns = 6
    var rows = 4

    if matrixStyle == "Vertical"
        columns := 4
        rows := 6


    var table matrixDataTable = table.new(position=tablePosition, columns=columns, rows=rows, frame_color=color.gray, frame_width=1, border_width=1, bgcolor=color.new(color.gray, 0), force_overlay=true)
    table.cell(matrixDataTable, 0, 0, text="TimeFrame", text_color=matrixHeaderTextColor, bgcolor=matrixHeaderColor)
    if matrixColumn1
        atrText = "ATR(" + str.tostring(matrixAtrLength) + ")"
        table.cell(matrixDataTable, getMatrixHeaderCol(1), getMatrixHeaderRow(1), text=atrText, text_color=matrixHeaderTextColor, bgcolor=matrixHeaderColor)
    if matrixColumn2
        table.cell(matrixDataTable, getMatrixHeaderCol(2), getMatrixHeaderRow(2), text="Candle", text_color=matrixHeaderTextColor, bgcolor=matrixHeaderColor)
    if matrixColumn3
        table.cell(matrixDataTable, getMatrixHeaderCol(3), getMatrixHeaderRow(3), text="Background", text_color=matrixHeaderTextColor, bgcolor=matrixHeaderColor)
    if matrixColumn4
        table.cell(matrixDataTable, getMatrixHeaderCol(4), getMatrixHeaderRow(4), text="Profit Wave", text_color=matrixHeaderTextColor, bgcolor=matrixHeaderColor)
    if matrixColumn5
        table.cell(matrixDataTable, getMatrixHeaderCol(5), getMatrixHeaderRow(5), text="Money Flow", text_color=matrixHeaderTextColor, bgcolor=matrixHeaderColor)
    
    if enableMatrixTF1
        m1Atr = getMatrixAtr(matrixTF1)
        [m1CandleStatus, m1CandleColor] = getMatrixCandleData(matrixTF1, m1TrendStatus, m1ProfitWaveStatus)

        table.cell(matrixDataTable, getMatrixTfCol(1), getMatrixTfRow(1, 0), text=matrixTF1, text_color=matrixTimeframeTextColor, bgcolor=matrixTimeframeColor)
        if matrixColumn1
            table.cell(matrixDataTable, getMatrixDataCol(1,1), getMatrixDataRow(1,1), text=m1Atr, text_color=matrixAtrTextColor, bgcolor=matrixAtrColor)
        if matrixColumn2
            table.cell(matrixDataTable, getMatrixDataCol(1,2), getMatrixDataRow(1,2), text=m1CandleStatus, text_color=color.white, bgcolor=m1CandleColor)
        if matrixColumn3
            table.cell(matrixDataTable, getMatrixDataCol(1,3), getMatrixDataRow(1,3), text=m1TrendStatus, text_color=m1TrendTextColor, bgcolor=color.new(m1BackgroundTrendColor,0))
        if matrixColumn4
            table.cell(matrixDataTable, getMatrixDataCol(1,4), getMatrixDataRow(1,4), text=m1ProfitWaveStatus, text_color=m1ProfitWaveTextColor, bgcolor=m1ProfitWaveColor)
        if matrixColumn5
            table.cell(matrixDataTable, getMatrixDataCol(1,5), getMatrixDataRow(1,5), text=m1MfiStatus, text_color=m1MfiTextColor, bgcolor=m1MfiColor)

    if enableMatrixTF2
        m2Atr = getMatrixAtr(matrixTF2)
        [m2CandleStatus, m2CandleColor] = getMatrixCandleData(matrixTF2, m2TrendStatus, m2ProfitWaveStatus)

        table.cell(matrixDataTable, getMatrixTfCol(2), getMatrixTfRow(2, 0), text=matrixTF2, text_color=matrixTimeframeTextColor, bgcolor=matrixTimeframeColor)
        if matrixColumn1
            table.cell(matrixDataTable, getMatrixDataCol(2,1), getMatrixDataRow(2,1), text=m2Atr, text_color=matrixAtrTextColor, bgcolor=matrixAtrColor)
        if matrixColumn2
            table.cell(matrixDataTable, getMatrixDataCol(2,2), getMatrixDataRow(2,2), text=m2CandleStatus, text_color=color.white, bgcolor=m2CandleColor)
        if matrixColumn3
            table.cell(matrixDataTable, getMatrixDataCol(2,3), getMatrixDataRow(2,3), text=m2TrendStatus, text_color=m2TrendTextColor, bgcolor=color.new(m2BackgroundTrendColor,0))
        if matrixColumn4
            table.cell(matrixDataTable, getMatrixDataCol(2,4), getMatrixDataRow(2,4), text=m2ProfitWaveStatus, text_color=m2ProfitWaveTextColor, bgcolor=m2ProfitWaveColor)
        if matrixColumn5
            table.cell(matrixDataTable, getMatrixDataCol(2,5), getMatrixDataRow(2,5), text=m2MfiStatus, text_color=m2MfiTextColor, bgcolor=m2MfiColor)

    if enableMatrixTF3
        m3Atr = getMatrixAtr(matrixTF3)
        [m3CandleStatus, m3CandleColor] = getMatrixCandleData(matrixTF3, m3TrendStatus, m3ProfitWaveStatus)

        table.cell(matrixDataTable, getMatrixTfCol(3), getMatrixTfRow(3, 0), text=matrixTF3, text_color=matrixTimeframeTextColor, bgcolor=matrixTimeframeColor)
        if matrixColumn1
            table.cell(matrixDataTable, getMatrixDataCol(3,1), getMatrixDataRow(3,1), text=m3Atr, text_color=matrixAtrTextColor, bgcolor=matrixAtrColor)
        if matrixColumn2
            table.cell(matrixDataTable, getMatrixDataCol(3,2), getMatrixDataRow(3,2), text=m3CandleStatus, text_color=color.white, bgcolor=m3CandleColor)
        if matrixColumn3
            table.cell(matrixDataTable, getMatrixDataCol(3,3), getMatrixDataRow(3,3), text=m3TrendStatus, text_color=m3TrendTextColor, bgcolor=color.new(m3BackgroundTrendColor,0))
        if matrixColumn4
            table.cell(matrixDataTable, getMatrixDataCol(3,4), getMatrixDataRow(3,4), text=m3ProfitWaveStatus, text_color=m3ProfitWaveTextColor, bgcolor=m3ProfitWaveColor)
        if matrixColumn5
            table.cell(matrixDataTable, getMatrixDataCol(3,5), getMatrixDataRow(3,5), text=m3MfiStatus, text_color=m3MfiTextColor, bgcolor=m3MfiColor)


lw_plots = 4
plotStyle = plot.style_stepline

var int md1Trend = enableMatrixDashboard1 ? -10 : 0
var int md1Profit = enableMatrixDashboard1 ? -15 : 0
var int md1Mfi = enableMatrixDashboard1 ? -20 : 0
var int md2Trend = enableMatrixDashboard2 ? md1Mfi - 10 : md1Trend
var int md2Profit = enableMatrixDashboard2 ? md2Trend - 5 : md1Profit
var int md2Mfi = enableMatrixDashboard2 ? md2Profit - 5 : md1Mfi
var int md3Trend = enableMatrixDashboard3 ? md2Mfi - 10 : 0
var int md3Profit = enableMatrixDashboard3 ? md3Trend - 5 : 0
var int md3Mfi = enableMatrixDashboard3 ? md3Profit - 5 : 0

if positionMatrixOnTop
    md1Trend := enableMatrixDashboard1 ? md1Profit + 5 : 100
    md1Profit := enableMatrixDashboard1 ? md1Mfi + 5 : 100
    md1Mfi := enableMatrixDashboard1 ? md2Trend + 10 : 100
    md2Trend := enableMatrixDashboard2 ? md2Profit + 5 : md3Trend
    md2Profit := enableMatrixDashboard2 ? md2Mfi + 5 : md3Profit
    md2Mfi := enableMatrixDashboard2 ? md3Trend + 10 : md3Mfi
    md3Trend := enableMatrixDashboard3 ? 120 : 100
    md3Profit := enableMatrixDashboard3 ? 115 : 100
    md3Mfi := enableMatrixDashboard3 ? 110 : 100


var label md1TrendLabel = na
var label md1ProfitLabel = na
var label md1MfiLabel = na

var label md2TrendLabel = na
var label md2ProfitLabel = na
var label md2MfiLabel = na

var label md3TrendLabel = na
var label md3ProfitLabel = na
var label md3MfiLabel = na

if barstate.islast and enableMatrixDashboardLabels
    if enableMatrixDashboard1 and na(md1TrendLabel)
        md1TrendLabel := label.new(x=bar_index[0], y=md1Trend, text="Background - "+matrixTF1, style=label.style_label_left, textcolor=color.white, color=color.new(color.white, 100), size=size.tiny)
        md1ProfitLabel := label.new(x=bar_index[0], y=md1Profit, text="Profit Wave - "+matrixTF1, style=label.style_label_left, textcolor=color.white, color=color.new(color.white, 100), size=size.tiny)
        md1MfiLabel := label.new(x=bar_index[0], y=md1Mfi, text="Money Flow - "+matrixTF1, style=label.style_label_left, textcolor=color.white, color=color.new(color.white, 100), size=size.tiny)
    else if enableMatrixDashboard1
        label.set_x(md1TrendLabel, bar_index[0])
        label.set_x(md1ProfitLabel, bar_index[0])
        label.set_x(md1MfiLabel, bar_index[0])

    if enableMatrixDashboard2 and na(md2TrendLabel)
        md2TrendLabel := label.new(x=bar_index[0], y=md2Trend, text="Background - "+matrixTF2, style=label.style_label_left, textcolor=color.white, color=color.new(color.white, 100), size=size.tiny)
        md2ProfitLabel := label.new(x=bar_index[0], y=md2Profit, text="Profit Wave - "+matrixTF2, style=label.style_label_left, textcolor=color.white, color=color.new(color.white, 100), size=size.tiny)
        md2MfiLabel := label.new(x=bar_index[0], y=md2Mfi, text="Money Flow - "+matrixTF2, style=label.style_label_left, textcolor=color.white, color=color.new(color.white, 100), size=size.tiny)
    else if enableMatrixDashboard2
        label.set_x(md2TrendLabel, bar_index[0])
        label.set_x(md2ProfitLabel, bar_index[0])
        label.set_x(md2MfiLabel, bar_index[0])

    if enableMatrixDashboard3 and na(md3TrendLabel)
        md3TrendLabel := label.new(x=bar_index[0], y=md3Trend, text="Background - "+matrixTF3, style=label.style_label_left, textcolor=color.white, color=color.new(color.white, 100), size=size.tiny)
        md3ProfitLabel := label.new(x=bar_index[0], y=md3Profit, text="Profit Wave - "+matrixTF3, style=label.style_label_left, textcolor=color.white, color=color.new(color.white, 100), size=size.tiny)
        md3MfiLabel := label.new(x=bar_index[0], y=md3Mfi, text="Money Flow - "+matrixTF3, style=label.style_label_left, textcolor=color.white, color=color.new(color.white, 100), size=size.tiny)
    else if enableMatrixDashboard3
        label.set_x(md3TrendLabel, bar_index[0])
        label.set_x(md3ProfitLabel, bar_index[0])
        label.set_x(md3MfiLabel, bar_index[0])
else
    label.delete(md1TrendLabel)
    md1TrendLabel := na
    label.delete(md1ProfitLabel)
    md1ProfitLabel := na
    label.delete(md1MfiLabel)
    md1MfiLabel := na
    label.delete(md2TrendLabel)
    md2TrendLabel := na
    label.delete(md2ProfitLabel)
    md2ProfitLabel := na
    label.delete(md2MfiLabel)
    md2MfiLabel := na
    label.delete(md3TrendLabel)
    md3TrendLabel := na
    label.delete(md3ProfitLabel)
    md3ProfitLabel := na
    label.delete(md3MfiLabel)
    md3MfiLabel := na

plot(series=enableMatrixDashboard1 ? md1Trend : na, title="Trend", color=m1BackgroundTrendColor, linewidth=lw_plots, style=plotStyle, editable=false)
plot(series=enableMatrixDashboard1 ? md1Profit : na, title="Profit Wave", color=m1ProfitWaveColor, linewidth=lw_plots, style=plotStyle, editable=false)
plot(series=enableMatrixDashboard1 ? md1Mfi : na, title="MFI", color=m1MfiColor, linewidth=lw_plots, style=plotStyle, editable=false)

plot(series=enableMatrixDashboard2 ? md2Trend : na, title="Trend 2", color=m2BackgroundTrendColor, linewidth=lw_plots, style=plotStyle, editable=false)
plot(series=enableMatrixDashboard2 ? md2Profit : na, title="Profit Wave 2", color=m2ProfitWaveColor, linewidth=lw_plots, style=plotStyle, editable=false)
plot(series=enableMatrixDashboard2 ? md2Mfi : na, title="MFI 2", color=m2MfiColor, linewidth=lw_plots, style=plotStyle, editable=false)

plot(series=enableMatrixDashboard3 ? md3Trend : na, title="Trend 3", color=m3BackgroundTrendColor, linewidth=lw_plots, style=plotStyle, editable=false)
plot(series=enableMatrixDashboard3 ? md3Profit : na, title="Profit Wave 3", color=m3ProfitWaveColor, linewidth=lw_plots, style=plotStyle, editable=false)
plot(series=enableMatrixDashboard3 ? md3Mfi : na, title="MFI 3", color=m3MfiColor, linewidth=lw_plots, style=plotStyle, editable=false)
